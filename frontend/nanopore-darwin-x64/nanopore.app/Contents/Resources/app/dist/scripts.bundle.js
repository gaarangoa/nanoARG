var Circos = function(t) {
    function n(r) { if (e[r]) return e[r].exports; var i = e[r] = { i: r, l: !1, exports: {} }; return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports } var e = {}; return n.m = t, n.c = e, n.d = function(t, e, r) { n.o(t, e) || Object.defineProperty(t, e, { configurable: !1, enumerable: !0, get: r }) }, n.n = function(t) { var e = t && t.__esModule ? function() { return t.default } : function() { return t }; return n.d(e, "a", e), e }, n.o = function(t, n) { return Object.prototype.hasOwnProperty.call(t, n) }, n.p = "", n(n.s = 235) }([function(t, n, e) { "use strict";
    n.a = function(t) { for (var n = t.length / 6 | 0, e = new Array(n), r = 0; r < n;) e[r] = "#" + t.slice(6 * r, 6 * ++r); return e } }, function(t, n, e) { "use strict"; var r = e(12);
    n.a = function(t) { return Object(r.e)(t[t.length - 1]) } }, function(t, n) { var e = Array.isArray;
    t.exports = e }, function(t, n, e) { "use strict";
    Object.defineProperty(n, "__esModule", { value: !0 }); var r = e(86);
    e.d(n, "creator", function() { return r.a }); var i = e(309);
    e.d(n, "local", function() { return i.a }); var a = e(158);
    e.d(n, "matcher", function() { return a.a }); var o = e(310);
    e.d(n, "mouse", function() { return o.a }); var u = e(87);
    e.d(n, "namespace", function() { return u.a }); var c = e(88);
    e.d(n, "namespaces", function() { return c.a }); var f = e(311);
    e.d(n, "select", function() { return f.a }); var s = e(339);
    e.d(n, "selectAll", function() { return s.a }); var l = e(8);
    e.d(n, "selection", function() { return l.b }); var d = e(92);
    e.d(n, "selector", function() { return d.a }); var h = e(159);
    e.d(n, "selectorAll", function() { return h.a }); var p = e(162);
    e.d(n, "style", function() { return p.b }); var b = e(340);
    e.d(n, "touch", function() { return b.a }); var v = e(341);
    e.d(n, "touches", function() { return v.a }); var y = e(93);
    e.d(n, "window", function() { return y.a }); var _ = e(90);
    e.d(n, "event", function() { return _.c }), e.d(n, "customEvent", function() { return _.a }) }, function(t, n, e) { "use strict";

    function r(t, n, e, o) {
        function u(n) { return t(n = new Date(+n)), n } return u.floor = u, u.ceil = function(e) { return t(e = new Date(e - 1)), n(e, 1), t(e), e }, u.round = function(t) { var n = u(t),
                e = u.ceil(t); return t - n < e - t ? n : e }, u.offset = function(t, e) { return n(t = new Date(+t), null == e ? 1 : Math.floor(e)), t }, u.range = function(e, r, i) { var a = []; if (e = u.ceil(e), i = null == i ? 1 : Math.floor(i), !(e < r && i > 0)) return a;
            do { a.push(new Date(+e)) } while (n(e, i), t(e), e < r); return a }, u.filter = function(e) { return r(function(n) { if (n >= n)
                    for (; t(n), !e(n);) n.setTime(n - 1) }, function(t, r) { if (t >= t)
                    if (r < 0)
                        for (; ++r <= 0;)
                            for (; n(t, -1), !e(t););
                    else
                        for (; --r >= 0;)
                            for (; n(t, 1), !e(t);); }) }, e && (u.count = function(n, r) { return i.setTime(+n), a.setTime(+r), t(i), t(a), Math.floor(e(i, a)) }, u.every = function(t) { return t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? u.filter(o ? function(n) { return o(n) % t == 0 } : function(n) { return u.count(0, n) % t == 0 }) : u : null }), u }
    n.a = r; var i = new Date,
        a = new Date }, function(t, n, e) { var r = e(124),
        i = "object" == typeof self && self && self.Object === Object && self,
        a = r || i || Function("return this")();
    t.exports = a }, function(t, n) {
    function e(t) { var n = typeof t; return null != t && ("object" == n || "function" == n) }
    t.exports = e }, function(t, n, e) { "use strict";
    Object.defineProperty(n, "__esModule", { value: !0 }); var r = e(180);
    e.d(n, "bisect", function() { return r.c }), e.d(n, "bisectRight", function() { return r.b }), e.d(n, "bisectLeft", function() { return r.a }); var i = e(36);
    e.d(n, "ascending", function() { return i.a }); var a = e(181);
    e.d(n, "bisector", function() { return a.a }); var o = e(390);
    e.d(n, "cross", function() { return o.a }); var u = e(391);
    e.d(n, "descending", function() { return u.a }); var c = e(183);
    e.d(n, "deviation", function() { return c.a }); var f = e(185);
    e.d(n, "extent", function() { return f.a }); var s = e(392);
    e.d(n, "histogram", function() { return s.a }); var l = e(395);
    e.d(n, "thresholdFreedmanDiaconis", function() { return l.a }); var d = e(396);
    e.d(n, "thresholdScott", function() { return d.a }); var h = e(189);
    e.d(n, "thresholdSturges", function() { return h.a }); var p = e(397);
    e.d(n, "max", function() { return p.a }); var b = e(398);
    e.d(n, "mean", function() { return b.a }); var v = e(399);
    e.d(n, "median", function() { return v.a }); var y = e(400);
    e.d(n, "merge", function() { return y.a }); var _ = e(190);
    e.d(n, "min", function() { return _.a }); var g = e(182);
    e.d(n, "pairs", function() { return g.a }); var m = e(401);
    e.d(n, "permute", function() { return m.a }); var x = e(103);
    e.d(n, "quantile", function() { return x.a }); var w = e(187);
    e.d(n, "range", function() { return w.a }); var j = e(402);
    e.d(n, "scan", function() { return j.a }); var O = e(403);
    e.d(n, "shuffle", function() { return O.a }); var M = e(404);
    e.d(n, "sum", function() { return M.a }); var k = e(188);
    e.d(n, "ticks", function() { return k.a }), e.d(n, "tickIncrement", function() { return k.b }), e.d(n, "tickStep", function() { return k.c }); var A = e(191);
    e.d(n, "transpose", function() { return A.a }); var T = e(184);
    e.d(n, "variance", function() { return T.a }); var R = e(405);
    e.d(n, "zip", function() { return R.a }) }, function(t, n, e) { "use strict";

    function r(t, n) { this._groups = t, this._parents = n }

    function i() { return new r([
            [document.documentElement]
        ], N) }
    e.d(n, "c", function() { return N }), n.a = r; var a = e(312),
        o = e(313),
        u = e(314),
        c = e(315),
        f = e(160),
        s = e(317),
        l = e(318),
        d = e(319),
        h = e(320),
        p = e(321),
        b = e(322),
        v = e(323),
        y = e(324),
        _ = e(325),
        g = e(326),
        m = e(327),
        x = e(162),
        w = e(328),
        j = e(329),
        O = e(330),
        M = e(331),
        k = e(332),
        A = e(333),
        T = e(334),
        R = e(335),
        P = e(336),
        S = e(337),
        C = e(90),
        E = e(338),
        N = [null];
    r.prototype = i.prototype = { constructor: r, select: a.a, selectAll: o.a, filter: u.a, data: c.a, enter: f.b, exit: s.a, merge: l.a, order: d.a, sort: h.a, call: p.a, nodes: b.a, node: v.a, size: y.a, empty: _.a, each: g.a, attr: m.a, style: x.a, property: w.a, classed: j.a, text: O.a, html: M.a, raise: k.a, lower: A.a, append: T.a, insert: R.a, remove: P.a, datum: S.a, on: C.b, dispatch: E.a }, n.b = i }, function(t, n, e) { "use strict";

    function r(t, n) { var e = t.__transition; if (!e || !(e = e[n]) || e.state > l) throw new Error("too late"); return e }

    function i(t, n) { var e = t.__transition; if (!e || !(e = e[n]) || e.state > h) throw new Error("too late"); return e }

    function a(t, n) { var e = t.__transition; if (!e || !(e = e[n])) throw new Error("too late"); return e }

    function o(t, n, e) {
        function r(t) { e.state = d, e.timer.restart(i, e.delay, e.time), e.delay <= t && i(t - e.delay) }

        function i(r) { var s, l, v, _; if (e.state !== d) return o(); for (s in f)
                if (_ = f[s], _.name === e.name) { if (_.state === p) return Object(c.b)(i);
                    _.state === b ? (_.state = y, _.timer.stop(), _.on.call("interrupt", t, t.__data__, _.index, _.group), delete f[s]) : +s < n && (_.state = y, _.timer.stop(), delete f[s]) }
            if (Object(c.b)(function() { e.state === p && (e.state = b, e.timer.restart(a, e.delay, e.time), a(r)) }), e.state = h, e.on.call("start", t, t.__data__, e.index, e.group), e.state === h) { for (e.state = p, u = new Array(v = e.tween.length), s = 0, l = -1; s < v; ++s)(_ = e.tween[s].value.call(t, t.__data__, e.index, e.group)) && (u[++l] = _);
                u.length = l + 1 } }

        function a(n) { for (var r = n < e.duration ? e.ease.call(null, n / e.duration) : (e.timer.restart(o), e.state = v, 1), i = -1, a = u.length; ++i < a;) u[i].call(null, r);
            e.state === v && (e.on.call("end", t, t.__data__, e.index, e.group), o()) }

        function o() { e.state = y, e.timer.stop(), delete f[n]; for (var r in f) return;
            delete t.__transition } var u, f = t.__transition;
        f[n] = e, e.timer = Object(c.c)(r, 0, e.time) }
    e.d(n, "c", function() { return d }), e.d(n, "d", function() { return h }), e.d(n, "b", function() { return v }), e.d(n, "a", function() { return y }), n.g = r, n.h = i, n.f = a; var u = e(194),
        c = e(195),
        f = Object(u.dispatch)("start", "end", "interrupt"),
        s = [],
        l = 0,
        d = 1,
        h = 2,
        p = 3,
        b = 4,
        v = 5,
        y = 6;
    n.e = function(t, n, e, r, i, a) { var u = t.__transition; if (u) { if (e in u) return } else t.__transition = {};
        o(t, e, { name: n, index: r, group: i, on: f, tween: s, time: a.time, delay: a.delay, duration: a.duration, ease: a.ease, timer: null, state: l }) } }, function(t, n) {
    function e(t) { return null != t && "object" == typeof t }
    t.exports = e }, function(t, n, e) { "use strict";
    Object.defineProperty(n, "__esModule", { value: !0 }); var r = e(365);
    e.d(n, "arc", function() { return r.a }); var i = e(166);
    e.d(n, "area", function() { return i.a }); var a = e(99);
    e.d(n, "line", function() { return a.a }); var o = e(367);
    e.d(n, "pie", function() { return o.a }); var u = e(370);
    e.d(n, "areaRadial", function() { return u.a }), e.d(n, "radialArea", function() { return u.a }); var c = e(168);
    e.d(n, "lineRadial", function() { return c.a }), e.d(n, "radialLine", function() { return c.a }); var f = e(169);
    e.d(n, "pointRadial", function() { return f.a }); var s = e(371);
    e.d(n, "linkHorizontal", function() { return s.a }), e.d(n, "linkVertical", function() { return s.c }), e.d(n, "linkRadial", function() { return s.b }); var l = e(372);
    e.d(n, "symbol", function() { return l.a }), e.d(n, "symbols", function() { return l.b }); var d = e(171);
    e.d(n, "symbolCircle", function() { return d.a }); var h = e(172);
    e.d(n, "symbolCross", function() { return h.a }); var p = e(173);
    e.d(n, "symbolDiamond", function() { return p.a }); var b = e(175);
    e.d(n, "symbolSquare", function() { return b.a }); var v = e(174);
    e.d(n, "symbolStar", function() { return v.a }); var y = e(176);
    e.d(n, "symbolTriangle", function() { return y.a }); var _ = e(177);
    e.d(n, "symbolWye", function() { return _.a }); var g = e(373);
    e.d(n, "curveBasisClosed", function() { return g.a }); var m = e(374);
    e.d(n, "curveBasisOpen", function() { return m.a }); var x = e(66);
    e.d(n, "curveBasis", function() { return x.b }); var w = e(375);
    e.d(n, "curveBundle", function() { return w.a }); var j = e(178);
    e.d(n, "curveCardinalClosed", function() { return j.b }); var O = e(179);
    e.d(n, "curveCardinalOpen", function() { return O.b }); var M = e(67);
    e.d(n, "curveCardinal", function() { return M.b }); var k = e(376);
    e.d(n, "curveCatmullRomClosed", function() { return k.a }); var A = e(377);
    e.d(n, "curveCatmullRomOpen", function() { return A.a }); var T = e(101);
    e.d(n, "curveCatmullRom", function() { return T.a }); var R = e(378);
    e.d(n, "curveLinearClosed", function() { return R.a }); var P = e(64);
    e.d(n, "curveLinear", function() { return P.a }); var S = e(379);
    e.d(n, "curveMonotoneX", function() { return S.a }), e.d(n, "curveMonotoneY", function() { return S.b }); var C = e(380);
    e.d(n, "curveNatural", function() { return C.a }); var E = e(381);
    e.d(n, "curveStep", function() { return E.a }), e.d(n, "curveStepAfter", function() { return E.b }), e.d(n, "curveStepBefore", function() { return E.c }); var N = e(382);
    e.d(n, "stack", function() { return N.a }); var I = e(383);
    e.d(n, "stackOffsetExpand", function() { return I.a }); var D = e(384);
    e.d(n, "stackOffsetDiverging", function() { return D.a }); var B = e(43);
    e.d(n, "stackOffsetNone", function() { return B.a }); var z = e(385);
    e.d(n, "stackOffsetSilhouette", function() { return z.a }); var L = e(386);
    e.d(n, "stackOffsetWiggle", function() { return L.a }); var F = e(102);
    e.d(n, "stackOrderAscending", function() { return F.a }); var U = e(387);
    e.d(n, "stackOrderDescending", function() { return U.a }); var W = e(388);
    e.d(n, "stackOrderInsideOut", function() { return W.a }); var Y = e(44);
    e.d(n, "stackOrderNone", function() { return Y.a }); var q = e(389);
    e.d(n, "stackOrderReverse", function() { return q.a }) }, function(t, n, e) { "use strict"; var r = e(105);
    e.d(n, "a", function() { return r.a }); var i = (e(200), e(108), e(198), e(201), e(68));
    e.d(n, "c", function() { return i.a }); var a = (e(202), e(417));
    e.d(n, "f", function() { return a.a }); var o = e(203);
    e.d(n, "g", function() { return o.a }); var u = e(418);
    e.d(n, "h", function() { return u.a }), e.d(n, "i", function() { return u.b }); var c = (e(421), e(197));
    e.d(n, "d", function() { return c.a }), e.d(n, "e", function() { return c.b }); var f = (e(422), e(423), e(424), e(425));
    e.d(n, "b", function() { return f.a });
    e(426) }, function(t, n, e) { "use strict"; var r = e(106);
    e.d(n, "a", function() { return r.e }), e.d(n, "f", function() { return r.g }), e.d(n, "d", function() { return r.f }); var i = e(415);
    e.d(n, "e", function() { return i.a }), e.d(n, "c", function() { return i.b }); var a = e(416);
    e.d(n, "b", function() { return a.a }) }, function(t, n, e) { var r = e(83),
        i = e(31),
        a = e(138),
        o = e(16),
        u = e(56),
        c = e(17),
        f = Object.prototype,
        s = f.hasOwnProperty,
        l = a(function(t, n) { if (u(n) || o(n)) return void i(n, c(n), t); for (var e in n) s.call(n, e) && r(t, e, n[e]) });
    t.exports = l }, function(t, n, e) { "use strict";
    e.d(n, "d", function() { return r }), e.d(n, "c", function() { return i }), e.d(n, "b", function() { return a }), e.d(n, "a", function() { return o }), e.d(n, "e", function() { return u }); var r = 1e3,
        i = 6e4,
        a = 36e5,
        o = 864e5,
        u = 6048e5 }, function(t, n, e) {
    function r(t) { return null != t && a(t.length) && !i(t) } var i = e(23),
        a = e(81);
    t.exports = r }, function(t, n, e) {
    function r(t) { return o(t) ? i(t) : a(t) } var i = e(137),
        a = e(139),
        o = e(16);
    t.exports = r }, function(t, n, e) { "use strict";

    function r(t, n) { if (!(t instanceof n)) throw new TypeError("Cannot call a class as a function") }
    Object.defineProperty(n, "__esModule", { value: !0 }); var i = function() {
            function t(t, n) { for (var e = 0; e < n.length; e++) { var r = n[e];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } return function(n, e, r) { return e && t(n.prototype, e), r && t(n, r), n } }(),
        a = e(192),
        o = e(194),
        u = e(11),
        c = e(3),
        f = e(458),
        s = e(205),
        l = e(548),
        d = e(585),
        h = function() {
            function t(n, e, i, a, u) { r(this, t), this.dispatch = (0, o.dispatch)("mouseover", "mouseout"), this.parseData = u, this.loadData(a, n), this.conf = (0, f.getConf)(e, i, this.meta, n), this.conf.colorValue = (0, l.buildColorValue)(this.conf.color, this.conf.cmin, this.conf.cmax, this.conf.logScale, this.conf.logScaleBase), this.scale = (0, s.buildScale)(this.conf.cmin, this.conf.cmax, this.conf.outerRadius - this.conf.innerRadius, this.conf.logScale, this.conf.logScaleBase) } return i(t, [{ key: "loadData", value: function(t, n) { var e = this.parseData(t, n._layout.summary());
                    this.data = e.data, this.meta = e.meta } }, { key: "render", value: function(t, n, e) { var r = this;
                    n.select("." + e).remove(); var i = n.append("g").attr("class", e).attr("z-index", this.conf.zIndex),
                        o = this.renderBlock(i, this.data, t._layout, this.conf);
                    this.conf.axes && this.conf.axes.length > 0 && (0, d.renderAxes)(o, this.conf, t, this.scale); var u = this.renderDatum(o, this.conf, t._layout); return this.conf.tooltipContent && (0, a.registerTooltip)(this, t, u, this.conf), u.on("mouseover", function(n, e) { r.dispatch.call("mouseover", r, n), r.conf.tooltipContent && t.clipboard.attr("value", r.conf.tooltipContent(n)) }), u.on("mouseout", function(t, n) { r.dispatch.call("mouseout", r, t) }), Object.keys(this.conf.events).forEach(function(t) { var n = r.conf;
                        u.on(t, function(e, r, i) { n.events[t](e, r, i, c.event) }) }), this } }, { key: "renderBlock", value: function(t, n, e, r) { var i = this,
                        a = t.selectAll(".block").data(n).enter().append("g").attr("class", "block").attr("transform", function(t) { return "rotate(" + 360 * e.blocks[t.key].start / (2 * Math.PI) + ")" }); return r.backgrounds && a.selectAll(".background").data(function(t) { return r.backgrounds.map(function(n) { return { start: n.start || r.cmin, end: n.end || r.cmax, angle: e.blocks[t.key].end - e.blocks[t.key].start, color: n.color, opacity: n.opacity } }) }).enter().append("path").attr("class", "background").attr("fill", function(t) { return t.color }).attr("opacity", function(t) { return t.opacity || 1 }).attr("d", (0, u.arc)().innerRadius(function(t) { return "in" === r.direction ? r.outerRadius - i.scale(t.start) : r.innerRadius + i.scale(t.start) }).outerRadius(function(t) { return "in" === r.direction ? r.outerRadius - i.scale(t.end) : r.innerRadius + i.scale(t.end) }).startAngle(0).endAngle(function(t) { return t.angle })), a } }, { key: "theta", value: function(t, n) { return t / n.len * (n.end - n.start) } }, { key: "x", value: function(t, n, e) { var r = this.scale(t.value),
                        i = "in" === e.direction ? e.outerRadius - r : e.innerRadius + r,
                        a = this.theta(t.position, n.blocks[t.block_id]) - Math.PI / 2; return i * Math.cos(a) } }, { key: "y", value: function(t, n, e) { var r = this.scale(t.value),
                        i = "in" === e.direction ? e.outerRadius - r : e.innerRadius + r,
                        a = this.theta(t.position, n.blocks[t.block_id]) - Math.PI / 2; return i * Math.sin(a) } }]), t }();
    n.default = h }, function(t, n, e) { "use strict";

    function r(t, n, e, r) { this._groups = t, this._parents = n, this._name = e, this._id = r }

    function i(t) { return Object(o.selection)().transition(t) }

    function a() { return ++O }
    n.a = r, n.b = i, n.c = a; var o = e(3),
        u = e(414),
        c = e(427),
        f = e(428),
        s = e(429),
        l = e(430),
        d = e(431),
        h = e(432),
        p = e(433),
        b = e(434),
        v = e(435),
        y = e(436),
        _ = e(437),
        g = e(438),
        m = e(439),
        x = e(440),
        w = e(441),
        j = e(69),
        O = 0,
        M = o.selection.prototype;
    r.prototype = i.prototype = { constructor: r, select: v.a, selectAll: y.a, filter: d.a, merge: h.a, selection: _.a, transition: w.a, call: M.call, nodes: M.nodes, node: M.node, size: M.size, empty: M.empty, each: M.each, on: p.a, attr: u.a, attrTween: c.a, style: g.a, styleTween: m.a, text: x.a, remove: b.a, tween: j.a, delay: f.a, duration: s.a, ease: l.a } }, function(t, n, e) { "use strict";

    function r(t) { return t && t.__esModule ? t : { default: t } }

    function i(t, n, e, r) { return !!(0, b.default)((0, h.default)(e), t) || (x.log(1, "datum", "unknown parent id", { line: n + 1, value: t, header: r, layoutSummary: e }), !1) }

    function a(t, n) { return (0, y.default)(t, function(t, e) { return !isNaN(t) || (x.log(1, "datum", "not a number", { line: n + 1, value: t, header: e }), !1) }) }

    function o(t) { return { data: (0, g.nest)().key(function(t) { return t.block_id }).entries(t), meta: { min: (0, m.min)(t, function(t) { return t.value }), max: (0, m.max)(t, function(t) { return t.value }) } } }

    function u(t, n) { return 0 === t.length ? { data: [], meta: { min: null, max: null } } : o(t.filter(function(t, e) { return i(t.block_id, e, n, "parent") })) }

    function c(t, n) { return 0 === t.length ? { data: [], meta: { min: null, max: null } } : o(t.filter(function(t, e) { return i(t.block_id, e, n, "parent") }).filter(function(t, n) { return a({ start: t.start, end: t.end }, n) }).filter(function(t) { return !(t.start < 0 || t.end > n[t.block_id]) || (x.log(2, "position", "position inconsistency", { datum: t, layoutSummary: n }), !1) })) }

    function f(t, n) { return 0 === t.length ? { data: [], meta: { min: null, max: null } } : o(t.filter(function(t, e) { return i(t.block_id, e, n, "parent") }).filter(function(t, n) { return a({ position: t.position, value: t.value }, n) })) }

    function s(t, n) { return 0 === t.length ? { data: [], meta: { min: null, max: null } } : o(t.filter(function(t, e) { return i(t.block_id, e, n, "parent") }).filter(function(t, n) { return a({ position: t.position }, n) })) }

    function l(t, n) { if (0 === t.length) return { data: [], meta: { min: null, max: null } }; var e = t.filter(function(t, e) { return t.source ? i(t.source.id, e, n, "sourceId") : (x.warn("No source for data at index " + e), !1) }).filter(function(t, e) { return t.target ? i(t.target.id, e, n, "targetId") : (x.warn("No target for data at index " + e), !1) }).filter(function(t, n) { return a({ sourceStart: t.source.start, sourceEnd: t.source.end, targetStart: t.target.start, targetEnd: t.target.end, value: t.value || 1 }, n) }); return { data: e, meta: { min: (0, m.min)(e, function(t) { return t.value }), max: (0, m.max)(e, function(t) { return t.value }) } } }
    Object.defineProperty(n, "__esModule", { value: !0 }), n.parseSpanValueData = u, n.parseSpanStringData = c, n.parsePositionValueData = f, n.parsePositionTextData = s, n.parseChordData = l; var d = e(17),
        h = r(d),
        p = e(590),
        b = r(p),
        v = e(594),
        y = r(v),
        _ = e(140),
        g = (r(_), e(222)),
        m = e(7),
        x = console }, function(t, n, e) { "use strict";
    Object.defineProperty(n, "__esModule", { value: !0 }); var r = { axes: { value: [], iteratee: !1 }, showAxesTooltip: { value: !0, iteratee: !1 } },
        i = { colorPaletteSize: { value: 9, iteratee: !1 }, colorPalette: { value: "YlGnBu", iteratee: !1 }, usePalette: { value: !0, iteratee: !1 }, colorPaletteReverse: { value: !0, iteratee: !1 } },
        a = { innerRadius: { value: 0, iteratee: !1 }, outerRadius: { value: 0, iteratee: !1 } },
        o = { min: { value: null, iteratee: !1 }, max: { value: null, iteratee: !1 }, logScale: { value: !1, iteratee: !1 }, logScaleBase: { value: Math.E, iteratee: !1 } },
        u = { zIndex: { value: !1, iteratee: !1 }, opacity: { value: 1, iteratee: !0 }, tooltipContent: { value: null, iteratee: !1 }, events: { value: {}, iteratee: !1 } };
    n.axes = r, n.palette = i, n.radial = a, n.values = o, n.common = u }, function(t, n, e) {
    function r(t, n) { var e = a(t, n); return i(e) ? e : void 0 } var i = e(238),
        a = e(243);
    t.exports = r }, function(t, n, e) {
    function r(t) { if (!a(t)) return !1; var n = i(t); return n == u || n == c || n == o || n == f } var i = e(24),
        a = e(6),
        o = "[object AsyncFunction]",
        u = "[object Function]",
        c = "[object GeneratorFunction]",
        f = "[object Proxy]";
    t.exports = r }, function(t, n, e) {
    function r(t) { return null == t ? void 0 === t ? c : u : f && f in Object(t) ? a(t) : o(t) } var i = e(29),
        a = e(239),
        o = e(240),
        u = "[object Null]",
        c = "[object Undefined]",
        f = i ? i.toStringTag : void 0;
    t.exports = r }, function(t, n, e) { "use strict";
    n.a = function(t) { return function() { return t } } }, function(t, n) { t.exports = {} }, function(t, n, e) { "use strict";
    e.d(n, "a", function() { return i }), e.d(n, "b", function() { return a }); var r = Array.prototype,
        i = r.map,
        a = r.slice }, function(t, n) {
    function e(t) { return t }
    t.exports = e }, function(t, n, e) { var r = e(5),
        i = r.Symbol;
    t.exports = i }, function(t, n) {
    function e(t, n) { var e = -1,
            r = t.length; for (n || (n = Array(r)); ++e < r;) n[e] = t[e]; return n }
    t.exports = e }, function(t, n, e) {
    function r(t, n, e, r) { var o = !e;
        e || (e = {}); for (var u = -1, c = n.length; ++u < c;) { var f = n[u],
                s = r ? r(e[f], t[f], f, e, t) : void 0;
            void 0 === s && (s = t[f]), o ? a(e, f, s) : i(e, f, s) } return e } var i = e(83),
        a = e(77);
    t.exports = r }, function(t, n, e) {
    function r(t, n) { return (u(t) ? i : a)(t, o(n)) } var i = e(62),
        a = e(39),
        o = e(283),
        u = e(2);
    t.exports = r }, function(t, n, e) {
    function r(t) { return "function" == typeof t ? t : null == t ? o : "object" == typeof t ? u(t) ? a(t[0], t[1]) : i(t) : c(t) } var i = e(284),
        a = e(298),
        o = e(28),
        u = e(2),
        c = e(306);
    t.exports = r }, function(t, n, e) {
    function r(t) { return "symbol" == typeof t || a(t) && i(t) == o } var i = e(24),
        a = e(10),
        o = "[object Symbol]";
    t.exports = r }, function(t, n, e) { "use strict"; var r = e(366);
    e.d(n, "a", function() { return r.a }) }, function(t, n, e) { "use strict";
    n.a = function(t, n) { return t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN } }, function(t, n, e) {
    function r(t, n, e) { return i(a, t, n, e) } var i = e(460),
        a = e(462);
    t.exports = r }, function(t, n) {
    function e(t, n) { return t === n || t !== t && n !== n }
    t.exports = e }, function(t, n, e) { var r = e(280),
        i = e(282),
        a = i(r);
    t.exports = a }, function(t, n) {
    function e(t, n) { for (var e = -1, r = null == t ? 0 : t.length, i = Array(r); ++e < r;) i[e] = n(t[e], e, t); return i }
    t.exports = e }, function(t, n, e) {
    function r(t) { if ("string" == typeof t || i(t)) return t; var n = t + ""; return "0" == n && 1 / t == -a ? "-0" : n } var i = e(34),
        a = 1 / 0;
    t.exports = r }, function(t, n, e) { "use strict";

    function r(t) { return t > 1 ? 0 : t < -1 ? h : Math.acos(t) }

    function i(t) { return t >= 1 ? p : t <= -1 ? -p : Math.asin(t) }
    e.d(n, "a", function() { return a }), e.d(n, "d", function() { return o }), e.d(n, "e", function() { return u }), e.d(n, "h", function() { return c }), e.d(n, "i", function() { return f }), e.d(n, "k", function() { return s }), e.d(n, "l", function() { return l }), e.d(n, "f", function() { return d }), e.d(n, "j", function() { return h }), e.d(n, "g", function() { return p }), e.d(n, "m", function() { return b }), n.b = r, n.c = i; var a = Math.abs,
        o = Math.atan2,
        u = Math.cos,
        c = Math.max,
        f = Math.min,
        s = Math.sin,
        l = Math.sqrt,
        d = 1e-12,
        h = Math.PI,
        p = h / 2,
        b = 2 * h }, function(t, n, e) { "use strict";
    n.a = function(t, n) { if ((i = t.length) > 1)
            for (var e, r, i, a = 1, o = t[n[0]], u = o.length; a < i; ++a)
                for (r = o, o = t[n[a]], e = 0; e < u; ++e) o[e][1] += o[e][0] = isNaN(r[e][1]) ? r[e][0] : r[e][1] } }, function(t, n, e) { "use strict";
    n.a = function(t) { for (var n = t.length, e = new Array(n); --n >= 0;) e[n] = n; return e } }, function(t, n, e) { "use strict";
    n.a = function(t) { return null === t ? NaN : +t } }, function(t, n, e) { "use strict";

    function r(t, n) { return function(e) { return t + e * n } }

    function i(t, n, e) { return t = Math.pow(t, e), n = Math.pow(n, e) - t, e = 1 / e,
            function(r) { return Math.pow(t + r * n, e) } }

    function a(t, n) { var e = n - t; return e ? r(t, e > 180 || e < -180 ? e - 360 * Math.round(e / 360) : e) : Object(c.a)(isNaN(t) ? n : t) }

    function o(t) { return 1 == (t = +t) ? u : function(n, e) { return e - n ? i(n, e, t) : Object(c.a)(isNaN(n) ? e : n) } }

    function u(t, n) { var e = n - t; return e ? r(t, e) : Object(c.a)(isNaN(t) ? n : t) }
    n.c = a, n.b = o, n.a = u; var c = e(199) }, function(t, n, e) { "use strict";

    function r(t) { var n = t.domain; return t.ticks = function(t) { var e = n(); return Object(a.ticks)(e[0], e[e.length - 1], null == t ? 10 : t) }, t.tickFormat = function(t, e) { return Object(c.a)(n(), t, e) }, t.nice = function(e) { null == e && (e = 10); var r, i = n(),
                o = 0,
                u = i.length - 1,
                c = i[o],
                f = i[u]; return f < c && (r = c, c = f, f = r, r = o, o = u, u = r), r = Object(a.tickIncrement)(c, f, e), r > 0 ? (c = Math.floor(c / r) * r, f = Math.ceil(f / r) * r, r = Object(a.tickIncrement)(c, f, e)) : r < 0 && (c = Math.ceil(c * r) / r, f = Math.floor(f * r) / r, r = Object(a.tickIncrement)(c, f, e)), r > 0 ? (i[o] = Math.floor(c / r) * r, i[u] = Math.ceil(f / r) * r, n(i)) : r < 0 && (i[o] = Math.ceil(c * r) / r, i[u] = Math.floor(f * r) / r, n(i)), t }, t }

    function i() { var t = Object(u.b)(u.c, o.c); return t.copy = function() { return Object(u.a)(t, i()) }, r(t) }
    n.b = r, n.a = i; var a = e(7),
        o = e(12),
        u = e(71),
        c = e(509) }, function(t, n, e) { "use strict";
    n.a = function(t) { return t.match(/.{6}/g).map(function(t) { return "#" + t }) } }, function(t, n) {
    function e(t, n, e) { switch (e.length) {
            case 0:
                return t.call(n);
            case 1:
                return t.call(n, e[0]);
            case 2:
                return t.call(n, e[0], e[1]);
            case 3:
                return t.call(n, e[0], e[1], e[2]) } return t.apply(n, e) }
    t.exports = e }, function(t, n, e) {
    function r(t) { var n = this.__data__ = new i(t);
        this.size = n.size } var i = e(51),
        a = e(250),
        o = e(251),
        u = e(252),
        c = e(253),
        f = e(254);
    r.prototype.clear = a, r.prototype.delete = o, r.prototype.get = u, r.prototype.has = c, r.prototype.set = f, t.exports = r }, function(t, n, e) {
    function r(t) { var n = -1,
            e = null == t ? 0 : t.length; for (this.clear(); ++n < e;) { var r = t[n];
            this.set(r[0], r[1]) } } var i = e(245),
        a = e(246),
        o = e(247),
        u = e(248),
        c = e(249);
    r.prototype.clear = i, r.prototype.delete = a, r.prototype.get = o, r.prototype.has = u, r.prototype.set = c, t.exports = r }, function(t, n, e) {
    function r(t, n) { for (var e = t.length; e--;)
            if (i(t[e][0], n)) return e;
        return -1 } var i = e(38);
    t.exports = r }, function(t, n, e) { var r = e(22),
        i = r(Object, "create");
    t.exports = i }, function(t, n, e) {
    function r(t, n) { var e = t.__data__; return i(n) ? e["string" == typeof n ? "string" : "hash"] : e.map } var i = e(263);
    t.exports = r }, function(t, n, e) { var r = e(6),
        i = Object.create,
        a = function() {
            function t() {} return function(n) { if (!r(n)) return {}; if (i) return i(n);
                t.prototype = n; var e = new t; return t.prototype = void 0, e } }();
    t.exports = a }, function(t, n) {
    function e(t) { var n = t && t.constructor; return t === ("function" == typeof n && n.prototype || r) } var r = Object.prototype;
    t.exports = e }, function(t, n, e) { var r = e(269),
        i = e(10),
        a = Object.prototype,
        o = a.hasOwnProperty,
        u = a.propertyIsEnumerable,
        c = r(function() { return arguments }()) ? r : function(t) { return i(t) && o.call(t, "callee") && !u.call(t, "callee") };
    t.exports = c }, function(t, n, e) {
    (function(t) { var r = e(5),
            i = e(271),
            a = "object" == typeof n && n && !n.nodeType && n,
            o = a && "object" == typeof t && t && !t.nodeType && t,
            u = o && o.exports === a,
            c = u ? r.Buffer : void 0,
            f = c ? c.isBuffer : void 0,
            s = f || i;
        t.exports = s }).call(n, e(78)(t)) }, function(t, n, e) {
    function r(t) { return o(t) ? i(t, !0) : a(t) } var i = e(137),
        a = e(277),
        o = e(16);
    t.exports = r }, function(t, n) {
    function e(t, n) { return !!(n = null == n ? r : n) && ("number" == typeof t || i.test(t)) && t > -1 && t % 1 == 0 && t < n } var r = 9007199254740991,
        i = /^(?:0|[1-9]\d*)$/;
    t.exports = e }, function(t, n, e) {
    function r(t, n, e) { if (!u(e)) return !1; var r = typeof n; return !!("number" == r ? a(e) && o(n, e.length) : "string" == r && n in e) && i(e[n], t) } var i = e(38),
        a = e(16),
        o = e(60),
        u = e(6);
    t.exports = r }, function(t, n) {
    function e(t, n) { for (var e = -1, r = null == t ? 0 : t.length; ++e < r && !1 !== n(t[e], e, t);); return t }
    t.exports = e }, function(t, n) {
    function e(t, n) { for (var e = -1, r = n.length, i = t.length; ++e < r;) t[i + e] = n[e]; return t }
    t.exports = e }, function(t, n, e) { "use strict";

    function r(t) { this._context = t }
    r.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._point = 0 }, lineEnd: function() {
            (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function(t, n) { switch (t = +t, n = +n, this._point) {
                case 0:
                    this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break;
                case 1:
                    this._point = 2;
                default:
                    this._context.lineTo(t, n) } } }, n.a = function(t) { return new r(t) } }, function(t, n, e) { "use strict";
    n.a = function() {} }, function(t, n, e) { "use strict";

    function r(t, n, e) { t._context.bezierCurveTo((2 * t._x0 + t._x1) / 3, (2 * t._y0 + t._y1) / 3, (t._x0 + 2 * t._x1) / 3, (t._y0 + 2 * t._y1) / 3, (t._x0 + 4 * t._x1 + n) / 6, (t._y0 + 4 * t._y1 + e) / 6) }

    function i(t) { this._context = t }
    n.c = r, n.a = i, i.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0 }, lineEnd: function() { switch (this._point) {
                case 3:
                    r(this, this._x1, this._y1);
                case 2:
                    this._context.lineTo(this._x1, this._y1) }(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function(t, n) { switch (t = +t, n = +n, this._point) {
                case 0:
                    this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break;
                case 1:
                    this._point = 2; break;
                case 2:
                    this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
                default:
                    r(this, t, n) }
            this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n } }, n.b = function(t) { return new i(t) } }, function(t, n, e) { "use strict";

    function r(t, n, e) { t._context.bezierCurveTo(t._x1 + t._k * (t._x2 - t._x0), t._y1 + t._k * (t._y2 - t._y0), t._x2 + t._k * (t._x1 - n), t._y2 + t._k * (t._y1 - e), t._x2, t._y2) }

    function i(t, n) { this._context = t, this._k = (1 - n) / 6 }
    n.c = r, n.a = i, i.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0 }, lineEnd: function() { switch (this._point) {
                case 2:
                    this._context.lineTo(this._x2, this._y2); break;
                case 3:
                    r(this, this._x1, this._y1) }(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function(t, n) { switch (t = +t, n = +n, this._point) {
                case 0:
                    this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break;
                case 1:
                    this._point = 2, this._x1 = t, this._y1 = n; break;
                case 2:
                    this._point = 3;
                default:
                    r(this, t, n) }
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }, n.b = function t(n) {
        function e(t) { return new i(t, n) } return e.tension = function(n) { return t(+n) }, e }(0) }, function(t, n, e) { "use strict";
    n.a = function(t, n) { return t = +t, n -= t,
            function(e) { return t + n * e } } }, function(t, n, e) { "use strict";

    function r(t, n) { var e, r; return function() { var i = Object(o.h)(this, t),
                a = i.tween; if (a !== e) { r = e = a; for (var u = 0, c = r.length; u < c; ++u)
                    if (r[u].name === n) { r = r.slice(), r.splice(u, 1); break } }
            i.tween = r } }

    function i(t, n, e) { var r, i; if ("function" != typeof e) throw new Error; return function() { var a = Object(o.h)(this, t),
                u = a.tween; if (u !== r) { i = (r = u).slice(); for (var c = { name: n, value: e }, f = 0, s = i.length; f < s; ++f)
                    if (i[f].name === n) { i[f] = c; break }
                f === s && i.push(c) }
            a.tween = i } }

    function a(t, n, e) { var r = t._id; return t.each(function() { var t = Object(o.h)(this, r);
                (t.value || (t.value = {}))[n] = e.apply(this, arguments) }),
            function(t) { return Object(o.f)(t, r).value[n] } }
    n.b = a; var o = e(9);
    n.a = function(t, n) { var e = this._id; if (t += "", arguments.length < 2) { for (var a, u = Object(o.f)(this.node(), e).tween, c = 0, f = u.length; c < f; ++c)
                if ((a = u[c]).name === t) return a.value;
            return null } return this.each((null == n ? r : i)(e, t, n)) } }, function(t, n, e) {
    function r(t) { return function() { var n = arguments; switch (n.length) {
                case 0:
                    return new t;
                case 1:
                    return new t(n[0]);
                case 2:
                    return new t(n[0], n[1]);
                case 3:
                    return new t(n[0], n[1], n[2]);
                case 4:
                    return new t(n[0], n[1], n[2], n[3]);
                case 5:
                    return new t(n[0], n[1], n[2], n[3], n[4]);
                case 6:
                    return new t(n[0], n[1], n[2], n[3], n[4], n[5]);
                case 7:
                    return new t(n[0], n[1], n[2], n[3], n[4], n[5], n[6]) } var e = i(t.prototype),
                r = t.apply(e, n); return a(r) ? r : e } } var i = e(55),
        a = e(6);
    t.exports = r }, function(t, n, e) { "use strict";

    function r(t, n) { return (n -= t = +t) ? function(e) { return (e - t) / n } : Object(h.a)(n) }

    function i(t) { return function(n, e) { var r = t(n = +n, e = +e); return function(t) { return t <= n ? 0 : t >= e ? 1 : r(t) } } }

    function a(t) { return function(n, e) { var r = t(n = +n, e = +e); return function(t) { return t <= 0 ? n : t >= 1 ? e : r(t) } } }

    function o(t, n, e, r) { var i = t[0],
            a = t[1],
            o = n[0],
            u = n[1]; return a < i ? (i = e(a, i), o = r(u, o)) : (i = e(i, a), o = r(o, u)),
            function(t) { return o(i(t)) } }

    function u(t, n, e, r) { var i = Math.min(t.length, n.length) - 1,
            a = new Array(i),
            o = new Array(i),
            u = -1; for (t[i] < t[0] && (t = t.slice().reverse(), n = n.slice().reverse()); ++u < i;) a[u] = e(t[u], t[u + 1]), o[u] = r(n[u], n[u + 1]); return function(n) { var e = Object(s.bisect)(t, n, 1, i) - 1; return o[e](a[e](n)) } }

    function c(t, n) { return n.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()) }

    function f(t, n) {
        function e() { return f = Math.min(v.length, y.length) > 2 ? u : o, s = h = null, c }

        function c(n) { return (s || (s = f(v, y, g ? i(t) : t, _)))(+n) } var f, s, h, v = b,
            y = b,
            _ = l.a,
            g = !1; return c.invert = function(t) { return (h || (h = f(y, v, r, g ? a(n) : n)))(+t) }, c.domain = function(t) { return arguments.length ? (v = d.a.call(t, p.a), e()) : v.slice() }, c.range = function(t) { return arguments.length ? (y = d.b.call(t), e()) : y.slice() }, c.rangeRound = function(t) { return y = d.b.call(t), _ = l.f, e() }, c.clamp = function(t) { return arguments.length ? (g = !!t, e()) : g }, c.interpolate = function(t) { return arguments.length ? (_ = t, e()) : _ }, e() }
    n.c = r, n.a = c, n.b = f; var s = e(7),
        l = e(12),
        d = e(27),
        h = e(117),
        p = e(223),
        b = [0, 1] }, function(t, n, e) { "use strict"; var r = e(118);
    n.a = function(t) { return t = Object(r.a)(Math.abs(t)), t ? t[1] : NaN } }, function(t, n, e) {
    function r(t, n) { return o(a(t, n, i), t + "") } var i = e(28),
        a = e(122),
        o = e(74);
    t.exports = r }, function(t, n, e) { var r = e(236),
        i = e(127),
        a = i(r);
    t.exports = a }, function(t, n, e) { var r = e(22),
        i = e(5),
        a = r(i, "Map");
    t.exports = a }, function(t, n, e) {
    function r(t) { var n = -1,
            e = null == t ? 0 : t.length; for (this.clear(); ++n < e;) { var r = t[n];
            this.set(r[0], r[1]) } } var i = e(255),
        a = e(262),
        o = e(264),
        u = e(265),
        c = e(266);
    r.prototype.clear = i, r.prototype.delete = a, r.prototype.get = o, r.prototype.has = u, r.prototype.set = c, t.exports = r }, function(t, n, e) {
    function r(t, n, e) { "__proto__" == n && i ? i(t, n, { configurable: !0, enumerable: !0, value: e, writable: !0 }) : t[n] = e } var i = e(123);
    t.exports = r }, function(t, n) { t.exports = function(t) { return t.webpackPolyfill || (t.deprecate = function() {}, t.paths = [], t.children || (t.children = []), Object.defineProperty(t, "loaded", { enumerable: !0, get: function() { return t.l } }), Object.defineProperty(t, "id", { enumerable: !0, get: function() { return t.i } }), t.webpackPolyfill = 1), t } }, function(t, n, e) {
    function r(t) { var n = new t.constructor(t.byteLength); return new i(n).set(new i(t)), n } var i = e(133);
    t.exports = r }, function(t, n, e) { var r = e(135),
        i = r(Object.getPrototypeOf, Object);
    t.exports = i }, function(t, n) {
    function e(t) { return "number" == typeof t && t > -1 && t % 1 == 0 && t <= r } var r = 9007199254740991;
    t.exports = e }, function(t, n, e) { var r = e(273),
        i = e(136),
        a = e(274),
        o = a && a.isTypedArray,
        u = o ? i(o) : r;
    t.exports = u }, function(t, n, e) {
    function r(t, n, e) { var r = t[n];
        u.call(t, n) && a(r, e) && (void 0 !== e || n in t) || i(t, n, e) } var i = e(77),
        a = e(38),
        o = Object.prototype,
        u = o.hasOwnProperty;
    t.exports = r }, function(t, n, e) { var r = e(147),
        i = e(148),
        a = Object.prototype,
        o = a.propertyIsEnumerable,
        u = Object.getOwnPropertySymbols,
        c = u ? function(t) { return null == t ? [] : (t = Object(t), r(u(t), function(n) { return o.call(t, n) })) } : i;
    t.exports = c }, function(t, n, e) {
    function r(t, n) { if (i(t)) return !1; var e = typeof t; return !("number" != e && "symbol" != e && "boolean" != e && null != t && !a(t)) || (u.test(t) || !o.test(t) || null != n && t in Object(n)) } var i = e(2),
        a = e(34),
        o = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        u = /^\w*$/;
    t.exports = r }, function(t, n, e) { "use strict";

    function r(t) { return function() { var n = this.ownerDocument,
                e = this.namespaceURI; return e === o.b && n.documentElement.namespaceURI === o.b ? n.createElement(t) : n.createElementNS(e, t) } }

    function i(t) { return function() { return this.ownerDocument.createElementNS(t.space, t.local) } } var a = e(87),
        o = e(88);
    n.a = function(t) { var n = Object(a.a)(t); return (n.local ? i : r)(n) } }, function(t, n, e) { "use strict"; var r = e(88);
    n.a = function(t) { var n = t += "",
            e = n.indexOf(":"); return e >= 0 && "xmlns" !== (n = t.slice(0, e)) && (t = t.slice(e + 1)), r.a.hasOwnProperty(n) ? { space: r.a[n], local: t } : t } }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return r }); var r = "http://www.w3.org/1999/xhtml";
    n.a = { svg: "http://www.w3.org/2000/svg", xhtml: r, xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" } }, function(t, n, e) { "use strict"; var r = e(90);
    n.a = function() { for (var t, n = r.c; t = n.sourceEvent;) n = t; return n } }, function(t, n, e) { "use strict";

    function r(t, n, e) { return t = i(t, n, e),
            function(n) { var e = n.relatedTarget;
                e && (e === this || 8 & e.compareDocumentPosition(this)) || t.call(this, n) } }

    function i(t, n, e) { return function(r) { var i = s;
            s = r; try { t.call(this, this.__data__, n, e) } finally { s = i } } }

    function a(t) { return t.trim().split(/^|\s+/).map(function(t) { var n = "",
                e = t.indexOf("."); return e >= 0 && (n = t.slice(e + 1), t = t.slice(0, e)), { type: t, name: n } }) }

    function o(t) { return function() { var n = this.__on; if (n) { for (var e, r = 0, i = -1, a = n.length; r < a; ++r) e = n[r], t.type && e.type !== t.type || e.name !== t.name ? n[++i] = e : this.removeEventListener(e.type, e.listener, e.capture);++i ? n.length = i : delete this.__on } } }

    function u(t, n, e) { var a = f.hasOwnProperty(t.type) ? r : i; return function(r, i, o) { var u, c = this.__on,
                f = a(n, i, o); if (c)
                for (var s = 0, l = c.length; s < l; ++s)
                    if ((u = c[s]).type === t.type && u.name === t.name) return this.removeEventListener(u.type, u.listener, u.capture), this.addEventListener(u.type, u.listener = f, u.capture = e), void(u.value = n);
            this.addEventListener(t.type, f, e), u = { type: t.type, name: t.name, value: n, listener: f, capture: e }, c ? c.push(u) : this.__on = [u] } }

    function c(t, n, e, r) { var i = s;
        t.sourceEvent = s, s = t; try { return n.apply(e, r) } finally { s = i } }
    e.d(n, "c", function() { return s }), n.a = c; var f = {},
        s = null; if ("undefined" != typeof document) { "onmouseenter" in document.documentElement || (f = { mouseenter: "mouseover", mouseleave: "mouseout" }) }
    n.b = function(t, n, e) { var r, i, c = a(t + ""),
            f = c.length; { if (!(arguments.length < 2)) { for (s = n ? u : o, null == e && (e = !1), r = 0; r < f; ++r) this.each(s(c[r], n, e)); return this } var s = this.node().__on; if (s)
                for (var l, d = 0, h = s.length; d < h; ++d)
                    for (r = 0, l = s[d]; r < f; ++r)
                        if ((i = c[r]).type === l.type && i.name === l.name) return l.value } } }, function(t, n, e) { "use strict";
    n.a = function(t, n) { var e = t.ownerSVGElement || t; if (e.createSVGPoint) { var r = e.createSVGPoint(); return r.x = n.clientX, r.y = n.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y] } var i = t.getBoundingClientRect(); return [n.clientX - i.left - t.clientLeft, n.clientY - i.top - t.clientTop] } }, function(t, n, e) { "use strict";

    function r() {}
    n.a = function(t) { return null == t ? r : function() { return this.querySelector(t) } } }, function(t, n, e) { "use strict";
    n.a = function(t) { return t.ownerDocument && t.ownerDocument.defaultView || t.document && t || t.defaultView } }, function(t, n, e) {
    function r(t, n, e, S, C, E) { var N, I = n & j,
            D = n & O,
            B = n & M; if (e && (N = C ? e(t, S, C, E) : e(t)), void 0 !== N) return N; if (!x(t)) return t; var z = g(t); if (z) { if (N = v(t), !I) return s(t, N) } else { var L = b(t),
                F = L == A || L == T; if (m(t)) return f(t, I); if (L == R || L == k || F && !C) { if (N = D || F ? {} : _(t), !I) return D ? d(t, c(N, t)) : l(t, u(N, t)) } else { if (!P[L]) return C ? t : {};
                N = y(t, L, r, I) } }
        E || (E = new i); var U = E.get(t); if (U) return U;
        E.set(t, N); var W = B ? D ? p : h : D ? keysIn : w,
            Y = z ? void 0 : W(t); return a(Y || t, function(i, a) { Y && (a = i, i = t[a]), o(N, a, r(i, n, e, a, t, E)) }), N } var i = e(50),
        a = e(62),
        o = e(83),
        u = e(164),
        c = e(343),
        f = e(131),
        s = e(30),
        l = e(344),
        d = e(345),
        h = e(145),
        p = e(346),
        b = e(149),
        v = e(347),
        y = e(348),
        _ = e(134),
        g = e(2),
        m = e(58),
        x = e(6),
        w = e(17),
        j = 1,
        O = 2,
        M = 4,
        k = "[object Arguments]",
        A = "[object Function]",
        T = "[object GeneratorFunction]",
        R = "[object Object]",
        P = {};
    P[k] = P["[object Array]"] = P["[object ArrayBuffer]"] = P["[object DataView]"] = P["[object Boolean]"] = P["[object Date]"] = P["[object Float32Array]"] = P["[object Float64Array]"] = P["[object Int8Array]"] = P["[object Int16Array]"] = P["[object Int32Array]"] = P["[object Map]"] = P["[object Number]"] = P[R] = P["[object RegExp]"] = P["[object Set]"] = P["[object String]"] = P["[object Symbol]"] = P["[object Uint8Array]"] = P["[object Uint8ClampedArray]"] = P["[object Uint16Array]"] = P["[object Uint32Array]"] = !0, P["[object Error]"] = P[A] = P["[object WeakMap]"] = !1, t.exports = r }, function(t, n) {
    function e(t, n, e, r) { var i = -1,
            a = null == t ? 0 : t.length; for (r && a && (e = t[++i]); ++i < a;) e = n(e, t[i], i, t); return e }
    t.exports = e }, function(t, n, e) {
    function r(t, n, e) { var r = c(t) ? i : u,
            f = arguments.length < 3; return r(t, o(n, 4), e, f, a) } var i = e(95),
        a = e(39),
        o = e(33),
        u = e(356),
        c = e(2);
    t.exports = r }, function(t, n, e) { var r = e(98),
        i = e(360),
        a = e(73),
        o = e(61),
        u = a(function(t, n) { if (null == t) return []; var e = n.length; return e > 1 && o(t, n[0], n[1]) ? n = [] : e > 2 && o(n[0], n[1], n[2]) && (n = [n[0]]), i(t, r(n, 1), []) });
    t.exports = u }, function(t, n, e) {
    function r(t, n, e, o, u) { var c = -1,
            f = t.length; for (e || (e = a), u || (u = []); ++c < f;) { var s = t[c];
            n > 0 && e(s) ? n > 1 ? r(s, n - 1, e, o, u) : i(u, s) : o || (u[u.length] = s) } return u } var i = e(63),
        a = e(359);
    t.exports = r }, function(t, n, e) { "use strict"; var r = e(35),
        i = e(25),
        a = e(64),
        o = e(100);
    n.a = function() {
        function t(t) { var i, a, o, l = t.length,
                d = !1; for (null == c && (s = f(o = Object(r.a)())), i = 0; i <= l; ++i) !(i < l && u(a = t[i], i, t)) === d && ((d = !d) ? s.lineStart() : s.lineEnd()), d && s.point(+n(a, i, t), +e(a, i, t)); if (o) return s = null, o + "" || null } var n = o.a,
            e = o.b,
            u = Object(i.a)(!0),
            c = null,
            f = a.a,
            s = null; return t.x = function(e) { return arguments.length ? (n = "function" == typeof e ? e : Object(i.a)(+e), t) : n }, t.y = function(n) { return arguments.length ? (e = "function" == typeof n ? n : Object(i.a)(+n), t) : e }, t.defined = function(n) { return arguments.length ? (u = "function" == typeof n ? n : Object(i.a)(!!n), t) : u }, t.curve = function(n) { return arguments.length ? (f = n, null != c && (s = f(c)), t) : f }, t.context = function(n) { return arguments.length ? (null == n ? c = s = null : s = f(c = n), t) : c }, t } }, function(t, n, e) { "use strict";

    function r(t) { return t[0] }

    function i(t) { return t[1] }
    n.a = r, n.b = i }, function(t, n, e) { "use strict";

    function r(t, n, e) { var r = t._x1,
            i = t._y1,
            o = t._x2,
            u = t._y2; if (t._l01_a > a.f) { var c = 2 * t._l01_2a + 3 * t._l01_a * t._l12_a + t._l12_2a,
                f = 3 * t._l01_a * (t._l01_a + t._l12_a);
            r = (r * c - t._x0 * t._l12_2a + t._x2 * t._l01_2a) / f, i = (i * c - t._y0 * t._l12_2a + t._y2 * t._l01_2a) / f } if (t._l23_a > a.f) { var s = 2 * t._l23_2a + 3 * t._l23_a * t._l12_a + t._l12_2a,
                l = 3 * t._l23_a * (t._l23_a + t._l12_a);
            o = (o * s + t._x1 * t._l23_2a - n * t._l12_2a) / l, u = (u * s + t._y1 * t._l23_2a - e * t._l12_2a) / l }
        t._context.bezierCurveTo(r, i, o, u, t._x2, t._y2) }

    function i(t, n) { this._context = t, this._alpha = n }
    n.b = r; var a = e(42),
        o = e(67);
    i.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0 }, lineEnd: function() { switch (this._point) {
                case 2:
                    this._context.lineTo(this._x2, this._y2); break;
                case 3:
                    this.point(this._x2, this._y2) }(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function(t, n) { if (t = +t, n = +n, this._point) { var e = this._x2 - t,
                    i = this._y2 - n;
                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + i * i, this._alpha)) } switch (this._point) {
                case 0:
                    this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break;
                case 1:
                    this._point = 2; break;
                case 2:
                    this._point = 3;
                default:
                    r(this, t, n) }
            this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }, n.a = function t(n) {
        function e(t) { return n ? new i(t, n) : new o.a(t, 0) } return e.alpha = function(n) { return t(+n) }, e }(.5) }, function(t, n, e) { "use strict";

    function r(t) { for (var n, e = 0, r = -1, i = t.length; ++r < i;)(n = +t[r][1]) && (e += n); return e }
    n.b = r; var i = e(44);
    n.a = function(t) { var n = t.map(r); return Object(i.a)(t).sort(function(t, e) { return n[t] - n[e] }) } }, function(t, n, e) { "use strict"; var r = e(45);
    n.a = function(t, n, e) { if (null == e && (e = r.a), i = t.length) { if ((n = +n) <= 0 || i < 2) return +e(t[0], 0, t); if (n >= 1) return +e(t[i - 1], i - 1, t); var i, a = (i - 1) * n,
                o = Math.floor(a),
                u = +e(t[o], o, t); return u + (+e(t[o + 1], o + 1, t) - u) * (a - o) } } }, function(t, n, e) { "use strict";

    function r() { return g || (w(i), g = x.now() + m) }

    function i() { g = 0 }

    function a() { this._call = this._time = this._next = null }

    function o(t, n, e) { var r = new a; return r.restart(t, n, e), r }

    function u() { r(), ++p; for (var t, n = d; n;)(t = g - n._time) >= 0 && n._call.call(null, t), n = n._next;--p }

    function c() { g = (_ = x.now()) + m, p = b = 0; try { u() } finally { p = 0, s(), g = 0 } }

    function f() { var t = x.now(),
            n = t - _;
        n > y && (m -= n, _ = t) }

    function s() { for (var t, n, e = d, r = 1 / 0; e;) e._call ? (r > e._time && (r = e._time), t = e, e = e._next) : (n = e._next, e._next = null, e = t ? t._next = n : d = n);
        h = t, l(r) }

    function l(t) { if (!p) { b && (b = clearTimeout(b));
            t - g > 24 ? (t < 1 / 0 && (b = setTimeout(c, t - x.now() - m)), v && (v = clearInterval(v))) : (v || (_ = x.now(), v = setInterval(f, y)), p = 1, w(c)) } }
    n.b = r, n.a = a, n.c = o; var d, h, p = 0,
        b = 0,
        v = 0,
        y = 1e3,
        _ = 0,
        g = 0,
        m = 0,
        x = "object" == typeof performance && performance.now ? performance : Date,
        w = "object" == typeof window && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t) { setTimeout(t, 17) };
    a.prototype = o.prototype = { constructor: a, restart: function(t, n, e) { if ("function" != typeof t) throw new TypeError("callback is not a function");
            e = (null == e ? r() : +e) + (null == n ? 0 : +n), this._next || h === this || (h ? h._next = this : d = this, h = this), this._call = t, this._time = e, l() }, stop: function() { this._call && (this._call = null, this._time = 1 / 0, l()) } } }, function(t, n, e) { "use strict"; var r = e(13),
        i = e(197),
        a = e(200),
        o = e(201),
        u = e(68),
        c = e(202),
        f = e(203),
        s = e(199);
    n.a = function(t, n) { var e, l = typeof n; return null == n || "boolean" === l ? Object(s.a)(n) : ("number" === l ? u.a : "string" === l ? (e = Object(r.a)(n)) ? (n = e, i.a) : f.a : n instanceof r.a ? i.a : n instanceof Date ? o.a : Array.isArray(n) ? a.a : "function" != typeof n.valueOf && "function" != typeof n.toString || isNaN(n) ? c.a : u.a)(t, n) } }, function(t, n, e) { "use strict";

    function r() {}

    function i(t) { var n; return t = (t + "").trim().toLowerCase(), (n = x.exec(t)) ? (n = parseInt(n[1], 16), new f(n >> 8 & 15 | n >> 4 & 240, n >> 4 & 15 | 240 & n, (15 & n) << 4 | 15 & n, 1)) : (n = w.exec(t)) ? a(parseInt(n[1], 16)) : (n = j.exec(t)) ? new f(n[1], n[2], n[3], 1) : (n = O.exec(t)) ? new f(255 * n[1] / 100, 255 * n[2] / 100, 255 * n[3] / 100, 1) : (n = M.exec(t)) ? o(n[1], n[2], n[3], n[4]) : (n = k.exec(t)) ? o(255 * n[1] / 100, 255 * n[2] / 100, 255 * n[3] / 100, n[4]) : (n = A.exec(t)) ? s(n[1], n[2] / 100, n[3] / 100, 1) : (n = T.exec(t)) ? s(n[1], n[2] / 100, n[3] / 100, n[4]) : R.hasOwnProperty(t) ? a(R[t]) : "transparent" === t ? new f(NaN, NaN, NaN, 0) : null }

    function a(t) { return new f(t >> 16 & 255, t >> 8 & 255, 255 & t, 1) }

    function o(t, n, e, r) { return r <= 0 && (t = n = e = NaN), new f(t, n, e, r) }

    function u(t) { return t instanceof r || (t = i(t)), t ? (t = t.rgb(), new f(t.r, t.g, t.b, t.opacity)) : new f }

    function c(t, n, e, r) { return 1 === arguments.length ? u(t) : new f(t, n, e, null == r ? 1 : r) }

    function f(t, n, e, r) { this.r = +t, this.g = +n, this.b = +e, this.opacity = +r }

    function s(t, n, e, r) { return r <= 0 ? t = n = e = NaN : e <= 0 || e >= 1 ? t = n = NaN : n <= 0 && (t = NaN), new h(t, n, e, r) }

    function l(t) { if (t instanceof h) return new h(t.h, t.s, t.l, t.opacity); if (t instanceof r || (t = i(t)), !t) return new h; if (t instanceof h) return t;
        t = t.rgb(); var n = t.r / 255,
            e = t.g / 255,
            a = t.b / 255,
            o = Math.min(n, e, a),
            u = Math.max(n, e, a),
            c = NaN,
            f = u - o,
            s = (u + o) / 2; return f ? (c = n === u ? (e - a) / f + 6 * (e < a) : e === u ? (a - n) / f + 2 : (n - e) / f + 4, f /= s < .5 ? u + o : 2 - u - o, c *= 60) : f = s > 0 && s < 1 ? 0 : c, new h(c, f, s, t.opacity) }

    function d(t, n, e, r) { return 1 === arguments.length ? l(t) : new h(t, n, e, null == r ? 1 : r) }

    function h(t, n, e, r) { this.h = +t, this.s = +n, this.l = +e, this.opacity = +r }

    function p(t, n, e) { return 255 * (t < 60 ? n + (e - n) * t / 60 : t < 180 ? e : t < 240 ? n + (e - n) * (240 - t) / 60 : n) }
    n.a = r, e.d(n, "d", function() { return v }), e.d(n, "c", function() { return y }), n.e = i, n.h = u, n.g = c, n.b = f, n.f = d; var b = e(107),
        v = .7,
        y = 1 / v,
        _ = "\\s*([+-]?\\d+)\\s*",
        g = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        m = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        x = /^#([0-9a-f]{3})$/,
        w = /^#([0-9a-f]{6})$/,
        j = new RegExp("^rgb\\(" + [_, _, _] + "\\)$"),
        O = new RegExp("^rgb\\(" + [m, m, m] + "\\)$"),
        M = new RegExp("^rgba\\(" + [_, _, _, g] + "\\)$"),
        k = new RegExp("^rgba\\(" + [m, m, m, g] + "\\)$"),
        A = new RegExp("^hsl\\(" + [g, m, m] + "\\)$"),
        T = new RegExp("^hsla\\(" + [g, m, m, g] + "\\)$"),
        R = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 };
    Object(b.a)(r, i, { displayable: function() { return this.rgb().displayable() }, toString: function() { return this.rgb() + "" } }), Object(b.a)(f, c, Object(b.b)(r, { brighter: function(t) { return t = null == t ? y : Math.pow(y, t), new f(this.r * t, this.g * t, this.b * t, this.opacity) }, darker: function(t) { return t = null == t ? v : Math.pow(v, t), new f(this.r * t, this.g * t, this.b * t, this.opacity) }, rgb: function() { return this }, displayable: function() { return 0 <= this.r && this.r <= 255 && 0 <= this.g && this.g <= 255 && 0 <= this.b && this.b <= 255 && 0 <= this.opacity && this.opacity <= 1 }, toString: function() { var t = this.opacity; return t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t)), (1 === t ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (1 === t ? ")" : ", " + t + ")") } })), Object(b.a)(h, d, Object(b.b)(r, { brighter: function(t) { return t = null == t ? y : Math.pow(y, t), new h(this.h, this.s, this.l * t, this.opacity) }, darker: function(t) { return t = null == t ? v : Math.pow(v, t), new h(this.h, this.s, this.l * t, this.opacity) }, rgb: function() { var t = this.h % 360 + 360 * (this.h < 0),
                n = isNaN(t) || isNaN(this.s) ? 0 : this.s,
                e = this.l,
                r = e + (e < .5 ? e : 1 - e) * n,
                i = 2 * e - r; return new f(p(t >= 240 ? t - 240 : t + 120, i, r), p(t, i, r), p(t < 120 ? t + 240 : t - 120, i, r), this.opacity) }, displayable: function() { return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1 } })) }, function(t, n, e) { "use strict";

    function r(t, n) { var e = Object.create(t.prototype); for (var r in n) e[r] = n[r]; return e }
    n.b = r, n.a = function(t, n, e) { t.prototype = n.prototype = e, e.constructor = t } }, function(t, n, e) { "use strict";

    function r(t, n, e, r, i) { var a = t * t,
            o = a * t; return ((1 - 3 * t + 3 * a - o) * n + (4 - 6 * a + 3 * o) * e + (1 + 3 * t + 3 * a - 3 * o) * r + o * i) / 6 }
    n.a = r, n.b = function(t) { var n = t.length - 1; return function(e) { var i = e <= 0 ? e = 0 : e >= 1 ? (e = 1, n - 1) : Math.floor(e * n),
                a = t[i],
                o = t[i + 1],
                u = i > 0 ? t[i - 1] : 2 * a - o,
                c = i < n - 1 ? t[i + 2] : 2 * o - a; return r((e - i / n) * n, u, a, o, c) } } }, function(t, n, e) {
    function r(t, n, e, r, w, j, O, M) { var k = n & v; if (!k && "function" != typeof t) throw new TypeError(p); var A = r ? r.length : 0; if (A || (n &= ~(g | m), r = w = void 0), O = void 0 === O ? O : x(h(O), 0), M = void 0 === M ? M : h(M), A -= w ? w.length : 0, n & m) { var T = r,
                R = w;
            r = w = void 0 } var P = k ? void 0 : f(t),
            S = [t, n, e, r, w, T, R, j, O, M]; if (P && s(S, P), t = S[0], n = S[1], e = S[2], r = S[3], w = S[4], M = S[9] = void 0 === S[9] ? k ? 0 : t.length : x(S[9] - A, 0), !M && n & (y | _) && (n &= ~(y | _)), n && n != b) C = n == y || n == _ ? o(t, n, M) : n != g && n != (b | g) || w.length ? u.apply(void 0, S) : c(t, n, e, r);
        else var C = a(t, n, e); return d((P ? i : l)(C, S), t, n) } var i = e(206),
        a = e(464),
        o = e(465),
        u = e(208),
        c = e(479),
        f = e(112),
        s = e(480),
        l = e(214),
        d = e(215),
        h = e(115),
        p = "Expected a function",
        b = 1,
        v = 2,
        y = 8,
        _ = 16,
        g = 32,
        m = 64,
        x = Math.max;
    t.exports = r }, function(t, n, e) {
    function r(t) { this.__wrapped__ = t, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = o, this.__views__ = [] } var i = e(55),
        a = e(111),
        o = 4294967295;
    r.prototype = i(a.prototype), r.prototype.constructor = r, t.exports = r }, function(t, n) {
    function e() {}
    t.exports = e }, function(t, n, e) { var r = e(207),
        i = e(467),
        a = r ? function(t) { return r.get(t) } : i;
    t.exports = a }, function(t, n, e) {
    function r(t, n) { this.__wrapped__ = t, this.__actions__ = [], this.__chain__ = !!n, this.__index__ = 0, this.__values__ = void 0 } var i = e(55),
        a = e(111);
    r.prototype = i(a.prototype), r.prototype.constructor = r, t.exports = r }, function(t, n) {
    function e(t, n) { for (var e = -1, i = t.length, a = 0, o = []; ++e < i;) { var u = t[e];
            u !== n && u !== r || (t[e] = r, o[a++] = e) } return o } var r = "__lodash_placeholder__";
    t.exports = e }, function(t, n, e) {
    function r(t) { var n = i(t),
            e = n % 1; return n === n ? e ? n - e : n : 0 } var i = e(218);
    t.exports = r }, function(t, n, e) { "use strict";

    function r() {}

    function i(t, n) { var e = new r; if (t instanceof r) t.each(function(t, n) { e.set(n, t) });
        else if (Array.isArray(t)) { var i, a = -1,
                o = t.length; if (null == n)
                for (; ++a < o;) e.set(a, t[a]);
            else
                for (; ++a < o;) e.set(n(i = t[a], a, t), i) } else if (t)
            for (var u in t) e.set(u, t[u]); return e }
    e.d(n, "b", function() { return a }); var a = "$";
    r.prototype = i.prototype = { constructor: r, has: function(t) { return a + t in this }, get: function(t) { return this[a + t] }, set: function(t, n) { return this[a + t] = n, this }, remove: function(t) { var n = a + t; return n in this && delete this[n] }, clear: function() { for (var t in this) t[0] === a && delete this[t] }, keys: function() { var t = []; for (var n in this) n[0] === a && t.push(n.slice(1)); return t }, values: function() { var t = []; for (var n in this) n[0] === a && t.push(this[n]); return t }, entries: function() { var t = []; for (var n in this) n[0] === a && t.push({ key: n.slice(1), value: this[n] }); return t }, size: function() { var t = 0; for (var n in this) n[0] === a && ++t; return t }, empty: function() { for (var t in this)
                if (t[0] === a) return !1;
            return !0 }, each: function(t) { for (var n in this) n[0] === a && t(this[n], n.slice(1), this) } }, n.a = i }, function(t, n, e) { "use strict";
    n.a = function(t) { return function() { return t } } }, function(t, n, e) { "use strict";
    n.a = function(t, n) { if ((e = (t = n ? t.toExponential(n - 1) : t.toExponential()).indexOf("e")) < 0) return null; var e, r = t.slice(0, e); return [r.length > 1 ? r[0] + r.slice(2) : r, +t.slice(e + 1)] } }, function(t, n, e) { "use strict"; var r = (e(4), e(524));
    e.d(n, "c", function() { return r.a }), e.d(n, "m", function() { return r.a }); var i = e(525);
    e.d(n, "g", function() { return i.a }), e.d(n, "q", function() { return i.a }); var a = e(526);
    e.d(n, "d", function() { return a.a }); var o = e(527);
    e.d(n, "b", function() { return o.a }); var u = e(528);
    e.d(n, "a", function() { return u.a }); var c = e(529);
    e.d(n, "i", function() { return c.b }), e.d(n, "h", function() { return c.b }), e.d(n, "e", function() { return c.a }); var f = e(530);
    e.d(n, "f", function() { return f.a }); var s = e(531);
    e.d(n, "j", function() { return s.a }); var l = e(532);
    e.d(n, "n", function() { return l.a }); var d = e(533);
    e.d(n, "l", function() { return d.a }); var h = e(534);
    e.d(n, "k", function() { return h.a }); var p = e(535);
    e.d(n, "s", function() { return p.b }), e.d(n, "r", function() { return p.b }), e.d(n, "o", function() { return p.a }); var b = e(536);
    e.d(n, "p", function() { return b.a }); var v = e(537);
    e.d(n, "t", function() { return v.a }) }, function(t, n, e) { "use strict";
    e.d(n, "a", function() { return i }), e.d(n, "b", function() { return o }), e.d(n, "c", function() { return u }); var r, i, a, o, u, c = e(232);! function(t) { r = Object(c.a)(t), i = r.format, a = r.parse, o = r.utcFormat, u = r.utcParse }({ dateTime: "%x, %X", date: "%-m/%-d/%Y", time: "%-I:%M:%S %p", periods: ["AM", "PM"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"] }) }, function(t, n, e) { var r = e(49),
        i = e(73),
        a = e(244),
        o = e(279),
        u = i(function(t) { return t.push(void 0, a), r(o, void 0, t) });
    t.exports = u }, function(t, n, e) {
    function r(t, n, e) { return n = a(void 0 === n ? t.length - 1 : n, 0),
            function() { for (var r = arguments, o = -1, u = a(r.length - n, 0), c = Array(u); ++o < u;) c[o] = r[n + o];
                o = -1; for (var f = Array(n + 1); ++o < n;) f[o] = r[o]; return f[n] = e(c), i(t, this, f) } } var i = e(49),
        a = Math.max;
    t.exports = r }, function(t, n, e) { var r = e(22),
        i = function() { try { var t = r(Object, "defineProperty"); return t({}, "", {}), t } catch (t) {} }();
    t.exports = i }, function(t, n, e) {
    (function(n) { var e = "object" == typeof n && n && n.Object === Object && n;
        t.exports = e }).call(n, e(125)) }, function(t, n) { var e;
    e = function() { return this }(); try { e = e || Function("return this")() || (0, eval)("this") } catch (t) { "object" == typeof window && (e = window) }
    t.exports = e }, function(t, n) {
    function e(t) { if (null != t) { try { return i.call(t) } catch (t) {} try { return t + "" } catch (t) {} } return "" } var r = Function.prototype,
        i = r.toString;
    t.exports = e }, function(t, n) {
    function e(t) { var n = 0,
            e = 0; return function() { var o = a(),
                u = i - (o - e); if (e = o, u > 0) { if (++n >= r) return arguments[0] } else n = 0; return t.apply(void 0, arguments) } } var r = 800,
        i = 16,
        a = Date.now;
    t.exports = e }, function(t, n, e) {
    function r(t, n, e, s, l) { t !== n && o(n, function(o, f) { if (c(o)) l || (l = new i), u(t, n, f, e, r, s, l);
            else { var d = s ? s(t[f], o, f + "", t, n, l) : void 0;
                void 0 === d && (d = o), a(t, f, d) } }, f) } var i = e(50),
        a = e(129),
        o = e(130),
        u = e(268),
        c = e(6),
        f = e(59);
    t.exports = r }, function(t, n, e) {
    function r(t, n, e) {
        (void 0 === e || a(t[n], e)) && (void 0 !== e || n in t) || i(t, n, e) } var i = e(77),
        a = e(38);
    t.exports = r }, function(t, n, e) { var r = e(267),
        i = r();
    t.exports = i }, function(t, n, e) {
    (function(t) {
        function r(t, n) { if (n) return t.slice(); var e = t.length,
                r = f ? f(e) : new t.constructor(e); return t.copy(r), r } var i = e(5),
            a = "object" == typeof n && n && !n.nodeType && n,
            o = a && "object" == typeof t && t && !t.nodeType && t,
            u = o && o.exports === a,
            c = u ? i.Buffer : void 0,
            f = c ? c.allocUnsafe : void 0;
        t.exports = r }).call(n, e(78)(t)) }, function(t, n, e) {
    function r(t, n) { var e = n ? i(t.buffer) : t.buffer; return new t.constructor(e, t.byteOffset, t.length) } var i = e(79);
    t.exports = r }, function(t, n, e) { var r = e(5),
        i = r.Uint8Array;
    t.exports = i }, function(t, n, e) {
    function r(t) { return "function" != typeof t.constructor || o(t) ? {} : i(a(t)) } var i = e(55),
        a = e(80),
        o = e(56);
    t.exports = r }, function(t, n) {
    function e(t, n) { return function(e) { return t(n(e)) } }
    t.exports = e }, function(t, n) {
    function e(t) { return function(n) { return t(n) } }
    t.exports = e }, function(t, n, e) {
    function r(t, n) { var e = o(t),
            r = !e && a(t),
            s = !e && !r && u(t),
            d = !e && !r && !s && f(t),
            h = e || r || s || d,
            p = h ? i(t.length, String) : [],
            b = p.length; for (var v in t) !n && !l.call(t, v) || h && ("length" == v || s && ("offset" == v || "parent" == v) || d && ("buffer" == v || "byteLength" == v || "byteOffset" == v) || c(v, b)) || p.push(v); return p } var i = e(276),
        a = e(57),
        o = e(2),
        u = e(58),
        c = e(60),
        f = e(82),
        s = Object.prototype,
        l = s.hasOwnProperty;
    t.exports = r }, function(t, n, e) {
    function r(t) { return i(function(n, e) { var r = -1,
                i = e.length,
                o = i > 1 ? e[i - 1] : void 0,
                u = i > 2 ? e[2] : void 0; for (o = t.length > 3 && "function" == typeof o ? (i--, o) : void 0, u && a(e[0], e[1], u) && (o = i < 3 ? void 0 : o, i = 1), n = Object(n); ++r < i;) { var c = e[r];
                c && t(n, c, r, o) } return n }) } var i = e(73),
        a = e(61);
    t.exports = r }, function(t, n, e) {
    function r(t) { if (!i(t)) return a(t); var n = []; for (var e in Object(t)) u.call(t, e) && "constructor" != e && n.push(e); return n } var i = e(56),
        a = e(281),
        o = Object.prototype,
        u = o.hasOwnProperty;
    t.exports = r }, function(t, n, e) {
    function r(t, n) { return (u(t) ? i : o)(t, a(n, 3)) } var i = e(40),
        a = e(33),
        o = e(157),
        u = e(2);
    t.exports = r }, function(t, n, e) {
    function r(t, n, e, o, u) { return t === n || (null == t || null == n || !a(t) && !a(n) ? t !== t && n !== n : i(t, n, e, o, r, u)) } var i = e(286),
        a = e(10);
    t.exports = r }, function(t, n, e) {
    function r(t, n, e, r, f, s) { var l = e & u,
            d = t.length,
            h = n.length; if (d != h && !(l && h > d)) return !1; var p = s.get(t); if (p && s.get(n)) return p == n; var b = -1,
            v = !0,
            y = e & c ? new i : void 0; for (s.set(t, n), s.set(n, t); ++b < d;) { var _ = t[b],
                g = n[b]; if (r) var m = l ? r(g, _, b, n, t, s) : r(_, g, b, t, n, s); if (void 0 !== m) { if (m) continue;
                v = !1; break } if (y) { if (!a(n, function(t, n) { if (!o(y, n) && (_ === t || f(_, t, e, r, s))) return y.push(n) })) { v = !1; break } } else if (_ !== g && !f(_, g, e, r, s)) { v = !1; break } } return s.delete(t), s.delete(n), v } var i = e(287),
        a = e(290),
        o = e(291),
        u = 1,
        c = 2;
    t.exports = r }, function(t, n) {
    function e(t) { var n = -1,
            e = Array(t.size); return t.forEach(function(t, r) { e[++n] = [r, t] }), e }
    t.exports = e }, function(t, n) {
    function e(t) { var n = -1,
            e = Array(t.size); return t.forEach(function(t) { e[++n] = t }), e }
    t.exports = e }, function(t, n, e) {
    function r(t) { return i(t, o, a) } var i = e(146),
        a = e(84),
        o = e(17);
    t.exports = r }, function(t, n, e) {
    function r(t, n, e) { var r = n(t); return a(t) ? r : i(r, e(t)) } var i = e(63),
        a = e(2);
    t.exports = r }, function(t, n) {
    function e(t, n) { for (var e = -1, r = null == t ? 0 : t.length, i = 0, a = []; ++e < r;) { var o = t[e];
            n(o, e, t) && (a[i++] = o) } return a }
    t.exports = e }, function(t, n) {
    function e() { return [] }
    t.exports = e }, function(t, n, e) { var r = e(294),
        i = e(75),
        a = e(295),
        o = e(296),
        u = e(150),
        c = e(24),
        f = e(126),
        s = f(r),
        l = f(i),
        d = f(a),
        h = f(o),
        p = f(u),
        b = c;
    (r && "[object DataView]" != b(new r(new ArrayBuffer(1))) || i && "[object Map]" != b(new i) || a && "[object Promise]" != b(a.resolve()) || o && "[object Set]" != b(new o) || u && "[object WeakMap]" != b(new u)) && (b = function(t) { var n = c(t),
            e = "[object Object]" == n ? t.constructor : void 0,
            r = e ? f(e) : ""; if (r) switch (r) {
            case s:
                return "[object DataView]";
            case l:
                return "[object Map]";
            case d:
                return "[object Promise]";
            case h:
                return "[object Set]";
            case p:
                return "[object WeakMap]" }
        return n }), t.exports = b }, function(t, n, e) { var r = e(22),
        i = e(5),
        a = r(i, "WeakMap");
    t.exports = a }, function(t, n, e) {
    function r(t) { return t === t && !i(t) } var i = e(6);
    t.exports = r }, function(t, n) {
    function e(t, n) { return function(e) { return null != e && (e[t] === n && (void 0 !== n || t in Object(e))) } }
    t.exports = e }, function(t, n, e) {
    function r(t, n) { n = i(n, t); for (var e = 0, r = n.length; null != t && e < r;) t = t[a(n[e++])]; return e && e == r ? t : void 0 } var i = e(154),
        a = e(41);
    t.exports = r }, function(t, n, e) {
    function r(t, n) { return i(t) ? t : a(t, n) ? [t] : o(u(t)) } var i = e(2),
        a = e(85),
        o = e(155),
        u = e(156);
    t.exports = r }, function(t, n, e) { var r = e(300),
        i = /^\./,
        a = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
        o = /\\(\\)?/g,
        u = r(function(t) { var n = []; return i.test(t) && n.push(""), t.replace(a, function(t, e, r, i) { n.push(r ? i.replace(o, "$1") : e || t) }), n });
    t.exports = u }, function(t, n, e) {
    function r(t) { return null == t ? "" : i(t) } var i = e(302);
    t.exports = r }, function(t, n, e) {
    function r(t, n) { var e = -1,
            r = a(t) ? Array(t.length) : []; return i(t, function(t, i, a) { r[++e] = n(t, i, a) }), r } var i = e(39),
        a = e(16);
    t.exports = r }, function(t, n, e) { "use strict"; var r = function(t) { return function() { return this.matches(t) } }; if ("undefined" != typeof document) { var i = document.documentElement; if (!i.matches) { var a = i.webkitMatchesSelector || i.msMatchesSelector || i.mozMatchesSelector || i.oMatchesSelector;
            r = function(t) { return function() { return a.call(this, t) } } } }
    n.a = r }, function(t, n, e) { "use strict";

    function r() { return [] }
    n.a = function(t) { return null == t ? r : function() { return this.querySelectorAll(t) } } }, function(t, n, e) { "use strict";

    function r(t, n) { this.ownerDocument = t.ownerDocument, this.namespaceURI = t.namespaceURI, this._next = null, this._parent = t, this.__data__ = n }
    n.a = r; var i = e(161),
        a = e(8);
    n.b = function() { return new a.a(this._enter || this._groups.map(i.a), this._parents) }, r.prototype = { constructor: r, appendChild: function(t) { return this._parent.insertBefore(t, this._next) }, insertBefore: function(t, n) { return this._parent.insertBefore(t, n) }, querySelector: function(t) { return this._parent.querySelector(t) }, querySelectorAll: function(t) { return this._parent.querySelectorAll(t) } } }, function(t, n, e) { "use strict";
    n.a = function(t) { return new Array(t.length) } }, function(t, n, e) { "use strict";

    function r(t) { return function() { this.style.removeProperty(t) } }

    function i(t, n, e) { return function() { this.style.setProperty(t, n, e) } }

    function a(t, n, e) { return function() { var r = n.apply(this, arguments);
            null == r ? this.style.removeProperty(t) : this.style.setProperty(t, r, e) } }

    function o(t, n) { return t.style.getPropertyValue(n) || Object(u.a)(t).getComputedStyle(t, null).getPropertyValue(n) }
    n.b = o; var u = e(93);
    n.a = function(t, n, e) { return arguments.length > 1 ? this.each((null == n ? r : "function" == typeof n ? a : i)(t, n, null == e ? "" : e)) : o(this.node(), t) } }, function(t, n, e) {
    function r(t) { return i(t, a | o) } var i = e(94),
        a = 1,
        o = 4;
    t.exports = r }, function(t, n, e) {
    function r(t, n) { return t && i(n, a(n), t) } var i = e(31),
        a = e(17);
    t.exports = r }, function(t, n, e) { var r = e(63),
        i = e(80),
        a = e(84),
        o = e(148),
        u = Object.getOwnPropertySymbols,
        c = u ? function(t) { for (var n = []; t;) r(n, a(t)), t = i(t); return n } : o;
    t.exports = c }, function(t, n, e) { "use strict"; var r = e(35),
        i = e(25),
        a = e(64),
        o = e(99),
        u = e(100);
    n.a = function() {
        function t(t) { var n, i, a, o, u, b = t.length,
                v = !1,
                y = new Array(b),
                _ = new Array(b); for (null == d && (p = h(u = Object(r.a)())), n = 0; n <= b; ++n) { if (!(n < b && l(o = t[n], n, t)) === v)
                    if (v = !v) i = n, p.areaStart(), p.lineStart();
                    else { for (p.lineEnd(), p.lineStart(), a = n - 1; a >= i; --a) p.point(y[a], _[a]);
                        p.lineEnd(), p.areaEnd() }
                v && (y[n] = +e(o, n, t), _[n] = +f(o, n, t), p.point(c ? +c(o, n, t) : y[n], s ? +s(o, n, t) : _[n])) } if (u) return p = null, u + "" || null }

        function n() { return Object(o.a)().defined(l).curve(h).context(d) } var e = u.a,
            c = null,
            f = Object(i.a)(0),
            s = u.b,
            l = Object(i.a)(!0),
            d = null,
            h = a.a,
            p = null; return t.x = function(n) { return arguments.length ? (e = "function" == typeof n ? n : Object(i.a)(+n), c = null, t) : e }, t.x0 = function(n) { return arguments.length ? (e = "function" == typeof n ? n : Object(i.a)(+n), t) : e }, t.x1 = function(n) { return arguments.length ? (c = null == n ? null : "function" == typeof n ? n : Object(i.a)(+n), t) : c }, t.y = function(n) { return arguments.length ? (f = "function" == typeof n ? n : Object(i.a)(+n), s = null, t) : f }, t.y0 = function(n) { return arguments.length ? (f = "function" == typeof n ? n : Object(i.a)(+n), t) : f }, t.y1 = function(n) { return arguments.length ? (s = null == n ? null : "function" == typeof n ? n : Object(i.a)(+n), t) : s }, t.lineX0 = t.lineY0 = function() { return n().x(e).y(f) }, t.lineY1 = function() { return n().x(e).y(s) }, t.lineX1 = function() { return n().x(c).y(f) }, t.defined = function(n) { return arguments.length ? (l = "function" == typeof n ? n : Object(i.a)(!!n), t) : l }, t.curve = function(n) { return arguments.length ? (h = n, null != d && (p = h(d)), t) : h }, t.context = function(n) { return arguments.length ? (null == n ? d = p = null : p = h(d = n), t) : d }, t } }, function(t, n, e) { "use strict";

    function r(t) { this._curve = t }

    function i(t) {
        function n(n) { return new r(t(n)) } return n._curve = t, n }
    e.d(n, "a", function() { return o }), n.b = i; var a = e(64),
        o = i(a.a);
    r.prototype = { areaStart: function() { this._curve.areaStart() }, areaEnd: function() { this._curve.areaEnd() }, lineStart: function() { this._curve.lineStart() }, lineEnd: function() { this._curve.lineEnd() }, point: function(t, n) { this._curve.point(n * Math.sin(t), n * -Math.cos(t)) } } }, function(t, n, e) { "use strict";

    function r(t) { var n = t.curve; return t.angle = t.x, delete t.x, t.radius = t.y, delete t.y, t.curve = function(t) { return arguments.length ? n(Object(i.b)(t)) : n()._curve }, t }
    n.b = r; var i = e(167),
        a = e(99);
    n.a = function() { return r(Object(a.a)().curve(i.a)) } }, function(t, n, e) { "use strict";
    n.a = function(t, n) { return [(n = +n) * Math.cos(t -= Math.PI / 2), n * Math.sin(t)] } }, function(t, n, e) { "use strict";
    e.d(n, "a", function() { return r }); var r = Array.prototype.slice }, function(t, n, e) { "use strict"; var r = e(42);
    n.a = { draw: function(t, n) { var e = Math.sqrt(n / r.j);
            t.moveTo(e, 0), t.arc(0, 0, e, 0, r.m) } } }, function(t, n, e) { "use strict";
    n.a = { draw: function(t, n) { var e = Math.sqrt(n / 5) / 2;
            t.moveTo(-3 * e, -e), t.lineTo(-e, -e), t.lineTo(-e, -3 * e), t.lineTo(e, -3 * e), t.lineTo(e, -e), t.lineTo(3 * e, -e), t.lineTo(3 * e, e), t.lineTo(e, e), t.lineTo(e, 3 * e), t.lineTo(-e, 3 * e), t.lineTo(-e, e), t.lineTo(-3 * e, e), t.closePath() } } }, function(t, n, e) { "use strict"; var r = Math.sqrt(1 / 3),
        i = 2 * r;
    n.a = { draw: function(t, n) { var e = Math.sqrt(n / i),
                a = e * r;
            t.moveTo(0, -e), t.lineTo(a, 0), t.lineTo(0, e), t.lineTo(-a, 0), t.closePath() } } }, function(t, n, e) { "use strict"; var r = e(42),
        i = Math.sin(r.j / 10) / Math.sin(7 * r.j / 10),
        a = Math.sin(r.m / 10) * i,
        o = -Math.cos(r.m / 10) * i;
    n.a = { draw: function(t, n) { var e = Math.sqrt(.8908130915292852 * n),
                i = a * e,
                u = o * e;
            t.moveTo(0, -e), t.lineTo(i, u); for (var c = 1; c < 5; ++c) { var f = r.m * c / 5,
                    s = Math.cos(f),
                    l = Math.sin(f);
                t.lineTo(l * e, -s * e), t.lineTo(s * i - l * u, l * i + s * u) }
            t.closePath() } } }, function(t, n, e) { "use strict";
    n.a = { draw: function(t, n) { var e = Math.sqrt(n),
                r = -e / 2;
            t.rect(r, r, e, e) } } }, function(t, n, e) { "use strict"; var r = Math.sqrt(3);
    n.a = { draw: function(t, n) { var e = -Math.sqrt(n / (3 * r));
            t.moveTo(0, 2 * e), t.lineTo(-r * e, -e), t.lineTo(r * e, -e), t.closePath() } } }, function(t, n, e) { "use strict"; var r = -.5,
        i = Math.sqrt(3) / 2,
        a = 1 / Math.sqrt(12),
        o = 3 * (a / 2 + 1);
    n.a = { draw: function(t, n) { var e = Math.sqrt(n / o),
                u = e / 2,
                c = e * a,
                f = u,
                s = e * a + e,
                l = -f,
                d = s;
            t.moveTo(u, c), t.lineTo(f, s), t.lineTo(l, d), t.lineTo(r * u - i * c, i * u + r * c), t.lineTo(r * f - i * s, i * f + r * s), t.lineTo(r * l - i * d, i * l + r * d), t.lineTo(r * u + i * c, r * c - i * u), t.lineTo(r * f + i * s, r * s - i * f), t.lineTo(r * l + i * d, r * d - i * l), t.closePath() } } }, function(t, n, e) { "use strict";

    function r(t, n) { this._context = t, this._k = (1 - n) / 6 }
    n.a = r; var i = e(65),
        a = e(67);
    r.prototype = { areaStart: i.a, areaEnd: i.a, lineStart: function() { this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0 }, lineEnd: function() { switch (this._point) {
                case 1:
                    this._context.moveTo(this._x3, this._y3), this._context.closePath(); break;
                case 2:
                    this._context.lineTo(this._x3, this._y3), this._context.closePath(); break;
                case 3:
                    this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5) } }, point: function(t, n) { switch (t = +t, n = +n, this._point) {
                case 0:
                    this._point = 1, this._x3 = t, this._y3 = n; break;
                case 1:
                    this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = n); break;
                case 2:
                    this._point = 3, this._x5 = t, this._y5 = n; break;
                default:
                    Object(a.c)(this, t, n) }
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }, n.b = function t(n) {
        function e(t) { return new r(t, n) } return e.tension = function(n) { return t(+n) }, e }(0) }, function(t, n, e) { "use strict";

    function r(t, n) { this._context = t, this._k = (1 - n) / 6 }
    n.a = r; var i = e(67);
    r.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0 }, lineEnd: function() {
            (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function(t, n) { switch (t = +t, n = +n, this._point) {
                case 0:
                    this._point = 1; break;
                case 1:
                    this._point = 2; break;
                case 2:
                    this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
                case 3:
                    this._point = 4;
                default:
                    Object(i.c)(this, t, n) }
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }, n.b = function t(n) {
        function e(t) { return new r(t, n) } return e.tension = function(n) { return t(+n) }, e }(0) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return o }), e.d(n, "a", function() { return u }); var r = e(36),
        i = e(181),
        a = Object(i.a)(r.a),
        o = a.right,
        u = a.left;
    n.c = o }, function(t, n, e) { "use strict";

    function r(t) { return function(n, e) { return Object(i.a)(t(n), e) } } var i = e(36);
    n.a = function(t) { return 1 === t.length && (t = r(t)), { left: function(n, e, r, i) { for (null == r && (r = 0), null == i && (i = n.length); r < i;) { var a = r + i >>> 1;
                    t(n[a], e) < 0 ? r = a + 1 : i = a } return r }, right: function(n, e, r, i) { for (null == r && (r = 0), null == i && (i = n.length); r < i;) { var a = r + i >>> 1;
                    t(n[a], e) > 0 ? i = a : r = a + 1 } return r } } } }, function(t, n, e) { "use strict";

    function r(t, n) { return [t, n] }
    n.b = r, n.a = function(t, n) { null == n && (n = r); for (var e = 0, i = t.length - 1, a = t[0], o = new Array(i < 0 ? 0 : i); e < i;) o[e] = n(a, a = t[++e]); return o } }, function(t, n, e) { "use strict"; var r = e(184);
    n.a = function(t, n) { var e = Object(r.a)(t, n); return e ? Math.sqrt(e) : e } }, function(t, n, e) { "use strict"; var r = e(45);
    n.a = function(t, n) { var e, i, a = t.length,
            o = 0,
            u = -1,
            c = 0,
            f = 0; if (null == n)
            for (; ++u < a;) isNaN(e = Object(r.a)(t[u])) || (i = e - c, c += i / ++o, f += i * (e - c));
        else
            for (; ++u < a;) isNaN(e = Object(r.a)(n(t[u], u, t))) || (i = e - c, c += i / ++o, f += i * (e - c)); if (o > 1) return f / (o - 1) } }, function(t, n, e) { "use strict";
    n.a = function(t, n) { var e, r, i, a = t.length,
            o = -1; if (null == n) { for (; ++o < a;)
                if (null != (e = t[o]) && e >= e)
                    for (r = i = e; ++o < a;) null != (e = t[o]) && (r > e && (r = e), i < e && (i = e)) } else
            for (; ++o < a;)
                if (null != (e = n(t[o], o, t)) && e >= e)
                    for (r = i = e; ++o < a;) null != (e = n(t[o], o, t)) && (r > e && (r = e), i < e && (i = e)); return [r, i] } }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return i }), e.d(n, "a", function() { return a }); var r = Array.prototype,
        i = r.slice,
        a = r.map }, function(t, n, e) { "use strict";
    n.a = function(t, n, e) { t = +t, n = +n, e = (i = arguments.length) < 2 ? (n = t, t = 0, 1) : i < 3 ? 1 : +e; for (var r = -1, i = 0 | Math.max(0, Math.ceil((n - t) / e)), a = new Array(i); ++r < i;) a[r] = t + r * e; return a } }, function(t, n, e) { "use strict";

    function r(t, n, e) { var r = (n - t) / Math.max(0, e),
            i = Math.floor(Math.log(r) / Math.LN10),
            c = r / Math.pow(10, i); return i >= 0 ? (c >= a ? 10 : c >= o ? 5 : c >= u ? 2 : 1) * Math.pow(10, i) : -Math.pow(10, -i) / (c >= a ? 10 : c >= o ? 5 : c >= u ? 2 : 1) }

    function i(t, n, e) { var r = Math.abs(n - t) / Math.max(0, e),
            i = Math.pow(10, Math.floor(Math.log(r) / Math.LN10)),
            c = r / i; return c >= a ? i *= 10 : c >= o ? i *= 5 : c >= u && (i *= 2), n < t ? -i : i }
    n.b = r, n.c = i; var a = Math.sqrt(50),
        o = Math.sqrt(10),
        u = Math.sqrt(2);
    n.a = function(t, n, e) { var i, a, o, u, c = -1; if (n = +n, t = +t, e = +e, t === n && e > 0) return [t]; if ((i = n < t) && (a = t, t = n, n = a), 0 === (u = r(t, n, e)) || !isFinite(u)) return []; if (u > 0)
            for (t = Math.ceil(t / u), n = Math.floor(n / u), o = new Array(a = Math.ceil(n - t + 1)); ++c < a;) o[c] = (t + c) * u;
        else
            for (t = Math.floor(t * u), n = Math.ceil(n * u), o = new Array(a = Math.ceil(t - n + 1)); ++c < a;) o[c] = (t - c) / u; return i && o.reverse(), o } }, function(t, n, e) { "use strict";
    n.a = function(t) { return Math.ceil(Math.log(t.length) / Math.LN2) + 1 } }, function(t, n, e) { "use strict";
    n.a = function(t, n) { var e, r, i = t.length,
            a = -1; if (null == n) { for (; ++a < i;)
                if (null != (e = t[a]) && e >= e)
                    for (r = e; ++a < i;) null != (e = t[a]) && r > e && (r = e) } else
            for (; ++a < i;)
                if (null != (e = n(t[a], a, t)) && e >= e)
                    for (r = e; ++a < i;) null != (e = n(t[a], a, t)) && r > e && (r = e); return r } }, function(t, n, e) { "use strict";

    function r(t) { return t.length } var i = e(190);
    n.a = function(t) { if (!(o = t.length)) return []; for (var n = -1, e = Object(i.a)(t, r), a = new Array(e); ++n < e;)
            for (var o, u = -1, c = a[n] = new Array(o); ++u < o;) c[u] = t[u][n]; return a } }, function(t, n, e) { "use strict";

    function r(t, n, e, r) { t.dispatch.on("mouseover", function(t) { n.tip.html(r.tooltipContent(t)).transition().style("opacity", .9).style("left", i.event.pageX + "px").style("top", i.event.pageY - 28 + "px") }), t.dispatch.on("mouseout", function(t) { n.tip.transition().duration(500).style("opacity", 0) }) }
    Object.defineProperty(n, "__esModule", { value: !0 }), n.registerTooltip = r; var i = e(3);
    e(407), e(454) }, function(t, n, e) { "use strict"; var r = e(9);
    n.a = function(t, n) { var e, i, a, o = t.__transition,
            u = !0; if (o) { n = null == n ? null : n + ""; for (a in o)(e = o[a]).name === n ? (i = e.state > r.d && e.state < r.b, e.state = r.a, e.timer.stop(), i && e.on.call("interrupt", t, t.__data__, e.index, e.group), delete o[a]) : u = !1;
            u && delete t.__transition } } }, function(t, n, e) { "use strict";
    Object.defineProperty(n, "__esModule", { value: !0 }); var r = e(410);
    e.d(n, "dispatch", function() { return r.a }) }, function(t, n, e) { "use strict"; var r = e(104);
    e.d(n, "a", function() { return r.b }), e.d(n, "c", function() { return r.c }); var i = e(411);
    e.d(n, "b", function() { return i.a });
    e(412) }, function(t, n, e) { "use strict";
    e.d(n, "a", function() { return r }), e.d(n, "b", function() { return i }); var r = Math.PI / 180,
        i = 180 / Math.PI }, function(t, n, e) { "use strict";

    function r(t) { return function(n) { var e, r, a = n.length,
                o = new Array(a),
                u = new Array(a),
                c = new Array(a); for (e = 0; e < a; ++e) r = Object(i.f)(n[e]), o[e] = r.r || 0, u[e] = r.g || 0, c[e] = r.b || 0; return o = t(o), u = t(u), c = t(c), r.opacity = 1,
                function(t) { return r.r = o(t), r.g = u(t), r.b = c(t), r + "" } } }
    e.d(n, "b", function() { return c }); var i = e(13),
        a = e(108),
        o = e(198),
        u = e(46);
    n.a = function t(n) {
        function e(t, n) { var e = r((t = Object(i.f)(t)).r, (n = Object(i.f)(n)).r),
                a = r(t.g, n.g),
                o = r(t.b, n.b),
                c = Object(u.a)(t.opacity, n.opacity); return function(n) { return t.r = e(n), t.g = a(n), t.b = o(n), t.opacity = c(n), t + "" } } var r = Object(u.b)(n); return e.gamma = t, e }(1); var c = r(a.b);
    r(o.a) }, function(t, n, e) { "use strict"; var r = e(108);
    n.a = function(t) { var n = t.length; return function(e) { var i = Math.floor(((e %= 1) < 0 ? ++e : e) * n),
                a = t[(i + n - 1) % n],
                o = t[i % n],
                u = t[(i + 1) % n],
                c = t[(i + 2) % n]; return Object(r.a)((e - i / n) * n, a, o, u, c) } } }, function(t, n, e) { "use strict";
    n.a = function(t) { return function() { return t } } }, function(t, n, e) { "use strict"; var r = e(105);
    n.a = function(t, n) { var e, i = n ? n.length : 0,
            a = t ? Math.min(i, t.length) : 0,
            o = new Array(i),
            u = new Array(i); for (e = 0; e < a; ++e) o[e] = Object(r.a)(t[e], n[e]); for (; e < i; ++e) u[e] = n[e]; return function(t) { for (e = 0; e < a; ++e) u[e] = o[e](t); return u } } }, function(t, n, e) { "use strict";
    n.a = function(t, n) { var e = new Date; return t = +t, n -= t,
            function(r) { return e.setTime(t + n * r), e } } }, function(t, n, e) { "use strict"; var r = e(105);
    n.a = function(t, n) { var e, i = {},
            a = {};
        null !== t && "object" == typeof t || (t = {}), null !== n && "object" == typeof n || (n = {}); for (e in n) e in t ? i[e] = Object(r.a)(t[e], n[e]) : a[e] = n[e]; return function(t) { for (e in i) a[e] = i[e](t); return a } } }, function(t, n, e) { "use strict";

    function r(t) { return function() { return t } }

    function i(t) { return function(n) { return t(n) + "" } } var a = e(68),
        o = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        u = new RegExp(o.source, "g");
    n.a = function(t, n) { var e, c, f, s = o.lastIndex = u.lastIndex = 0,
            l = -1,
            d = [],
            h = []; for (t += "", n += "";
            (e = o.exec(t)) && (c = u.exec(n));)(f = c.index) > s && (f = n.slice(s, f), d[l] ? d[l] += f : d[++l] = f), (e = e[0]) === (c = c[0]) ? d[l] ? d[l] += c : d[++l] = c : (d[++l] = null, h.push({ i: l, x: Object(a.a)(e, c) })), s = u.lastIndex; return s < n.length && (f = n.slice(s), d[l] ? d[l] += f : d[++l] = f), d.length < 2 ? h[0] ? i(h[0].x) : r(n) : (n = h.length, function(t) { for (var e, r = 0; r < n; ++r) d[(e = h[r]).i] = e.x(t); return d.join("") }) } }, function(t, n, e) { "use strict"; var r = e(13),
        i = e(12);
    n.a = function(t, n) { var e; return ("number" == typeof n ? i.c : n instanceof r.a ? i.d : (e = Object(r.a)(n)) ? (n = e, i.d) : i.g)(t, n) } }, function(t, n, e) { "use strict";

    function r(t) { return t && t.__esModule ? t : { default: t } }

    function i(t, n, e) { var r = t.defaultTrackWidth || 30,
            i = (0, s.default)((0, p.default)("conf.outerRadius"), (0, c.default)("conf.outerRadius"), _.default, v.default)((0, d.default)(e, n)); return { in: i.conf.outerRadius, out: i.conf.outerRadius + r } }

    function a(t, n) { return t.cmin = null === t.min ? n.min : t.min, t.cmax = null === t.max ? n.max : t.max, t }

    function o(t, n, e) { var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
            i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Math.E; return r && t * n <= 0 && console.warn("As log(0) = -, a log scale domain must be\n      strictly-positive or strictly-negative. logscale ignored"), (r && t * n > 0 ? (0, g.scaleLog)().base(i) : (0, g.scaleLinear)()).domain([t, n]).range([0, e]).clamp(!0) }
    Object.defineProperty(n, "__esModule", { value: !0 }), n.smartBorders = i, n.computeMinMax = a, n.buildScale = o; var u = e(459),
        c = r(u),
        f = e(488),
        s = r(f),
        l = e(491),
        d = r(l),
        h = e(493),
        p = r(h),
        b = e(496),
        v = r(b),
        y = e(500),
        _ = r(y),
        g = e(220) }, function(t, n, e) { var r = e(28),
        i = e(207),
        a = i ? function(t, n) { return i.set(t, n), t } : r;
    t.exports = a }, function(t, n, e) { var r = e(150),
        i = r && new r;
    t.exports = i }, function(t, n, e) {
    function r(t, n, e, g, m, x, w, j, O, M) {
        function k() { for (var h = arguments.length, p = Array(h), b = h; b--;) p[b] = arguments[b]; if (P) var v = f(k),
                y = o(p, v); if (g && (p = i(p, g, m, P)), x && (p = a(p, x, w, P)), h -= y, P && h < M) { var _ = l(p, v); return c(t, n, r, k.placeholder, e, p, _, j, O, M - h) } var E = T ? e : this,
                N = R ? E[t] : t; return h = p.length, j ? p = s(p, j) : S && h > 1 && p.reverse(), A && O < h && (p.length = O), this && this !== d && this instanceof k && (N = C || u(N)), N.apply(E, p) } var A = n & y,
            T = n & h,
            R = n & p,
            P = n & (b | v),
            S = n & _,
            C = R ? void 0 : u(t); return k } var i = e(209),
        a = e(210),
        o = e(466),
        u = e(70),
        c = e(211),
        f = e(217),
        s = e(478),
        l = e(114),
        d = e(5),
        h = 1,
        p = 2,
        b = 8,
        v = 16,
        y = 128,
        _ = 512;
    t.exports = r }, function(t, n) {
    function e(t, n, e, i) { for (var a = -1, o = t.length, u = e.length, c = -1, f = n.length, s = r(o - u, 0), l = Array(f + s), d = !i; ++c < f;) l[c] = n[c]; for (; ++a < u;)(d || a < o) && (l[e[a]] = t[a]); for (; s--;) l[c++] = t[a++]; return l } var r = Math.max;
    t.exports = e }, function(t, n) {
    function e(t, n, e, i) { for (var a = -1, o = t.length, u = -1, c = e.length, f = -1, s = n.length, l = r(o - c, 0), d = Array(l + s), h = !i; ++a < l;) d[a] = t[a]; for (var p = a; ++f < s;) d[p + f] = n[f]; for (; ++u < c;)(h || a < o) && (d[p + e[u]] = t[a++]); return d } var r = Math.max;
    t.exports = e }, function(t, n, e) {
    function r(t, n, e, r, h, p, b, v, y, _) { var g = n & s,
            m = g ? b : void 0,
            x = g ? void 0 : b,
            w = g ? p : void 0,
            j = g ? void 0 : p;
        n |= g ? l : d, (n &= ~(g ? d : l)) & f || (n &= ~(u | c)); var O = [t, n, h, w, m, j, x, v, y, _],
            M = e.apply(void 0, O); return i(t) && a(M, O), M.placeholder = r, o(M, t, n) } var i = e(212),
        a = e(214),
        o = e(215),
        u = 1,
        c = 2,
        f = 4,
        s = 8,
        l = 32,
        d = 64;
    t.exports = r }, function(t, n, e) {
    function r(t) { var n = o(t),
            e = u[n]; if ("function" != typeof e || !(n in i.prototype)) return !1; if (t === e) return !0; var r = a(e); return !!r && t === r[0] } var i = e(110),
        a = e(112),
        o = e(213),
        u = e(469);
    t.exports = r }, function(t, n, e) {
    function r(t) { for (var n = t.name + "", e = i[n], r = o.call(i, n) ? e.length : 0; r--;) { var a = e[r],
                u = a.func; if (null == u || u == t) return a.name } return n } var i = e(468),
        a = Object.prototype,
        o = a.hasOwnProperty;
    t.exports = r }, function(t, n, e) { var r = e(206),
        i = e(127),
        a = i(r);
    t.exports = a }, function(t, n, e) {
    function r(t, n, e) { var r = n + ""; return o(t, a(r, u(i(r), e))) } var i = e(471),
        a = e(472),
        o = e(74),
        u = e(473);
    t.exports = r }, function(t, n, e) {
    function r(t, n, e) { return n === n ? o(t, n, e) : i(t, a, e) } var i = e(475),
        a = e(476),
        o = e(477);
    t.exports = r }, function(t, n) {
    function e(t) { return t.placeholder }
    t.exports = e }, function(t, n, e) {
    function r(t) { if (!t) return 0 === t ? t : 0; if ((t = i(t)) === a || t === -a) { return (t < 0 ? -1 : 1) * o } return t === t ? t : 0 } var i = e(481),
        a = 1 / 0,
        o = 1.7976931348623157e308;
    t.exports = r }, function(t, n, e) {
    function r(t) { return o(a(t, void 0, i), t + "") } var i = e(486),
        a = e(122),
        o = e(74);
    t.exports = r }, function(t, n, e) { "use strict";
    Object.defineProperty(n, "__esModule", { value: !0 }); var r = e(502);
    e.d(n, "scaleBand", function() { return r.a }), e.d(n, "scalePoint", function() { return r.b }); var i = e(508);
    e.d(n, "scaleIdentity", function() { return i.a }); var a = e(47);
    e.d(n, "scaleLinear", function() { return a.a }); var o = e(519);
    e.d(n, "scaleLog", function() { return o.a }); var u = e(221);
    e.d(n, "scaleOrdinal", function() { return u.a }), e.d(n, "scaleImplicit", function() { return u.b }); var c = e(520);
    e.d(n, "scalePow", function() { return c.a }), e.d(n, "scaleSqrt", function() { return c.b }); var f = e(521);
    e.d(n, "scaleQuantile", function() { return f.a }); var s = e(522);
    e.d(n, "scaleQuantize", function() { return s.a }); var l = e(523);
    e.d(n, "scaleThreshold", function() { return l.a }); var d = e(230);
    e.d(n, "scaleTime", function() { return d.b }); var h = e(539);
    e.d(n, "scaleUtc", function() { return h.a }); var p = e(540);
    e.d(n, "schemeCategory10", function() { return p.a }); var b = e(541);
    e.d(n, "schemeCategory20b", function() { return b.a }); var v = e(542);
    e.d(n, "schemeCategory20c", function() { return v.a }); var y = e(543);
    e.d(n, "schemeCategory20", function() { return y.a }); var _ = e(544);
    e.d(n, "interpolateCubehelixDefault", function() { return _.a }); var g = e(545);
    e.d(n, "interpolateRainbow", function() { return g.b }), e.d(n, "interpolateWarm", function() { return g.c }), e.d(n, "interpolateCool", function() { return g.a }); var m = e(546);
    e.d(n, "interpolateViridis", function() { return m.a }), e.d(n, "interpolateMagma", function() { return m.c }), e.d(n, "interpolateInferno", function() { return m.b }), e.d(n, "interpolatePlasma", function() { return m.d }); var x = e(547);
    e.d(n, "scaleSequential", function() { return x.a }) }, function(t, n, e) { "use strict";

    function r(t) {
        function n(n) { var r = n + "",
                i = e.get(r); if (!i) { if (c !== o) return c;
                e.set(r, i = u.push(n)) } return t[(i - 1) % t.length] } var e = Object(i.map)(),
            u = [],
            c = o; return t = null == t ? [] : a.b.call(t), n.domain = function(t) { if (!arguments.length) return u.slice();
            u = [], e = Object(i.map)(); for (var r, a, o = -1, c = t.length; ++o < c;) e.has(a = (r = t[o]) + "") || e.set(a, u.push(r)); return n }, n.range = function(e) { return arguments.length ? (t = a.b.call(e), n) : t.slice() }, n.unknown = function(t) { return arguments.length ? (c = t, n) : c }, n.copy = function() { return r().domain(u).range(t).unknown(c) }, n }
    e.d(n, "b", function() { return o }), n.a = r; var i = e(222),
        a = e(27),
        o = { name: "implicit" } }, function(t, n, e) { "use strict";
    Object.defineProperty(n, "__esModule", { value: !0 }); var r = e(503);
    e.d(n, "nest", function() { return r.a }); var i = e(504);
    e.d(n, "set", function() { return i.a }); var a = e(116);
    e.d(n, "map", function() { return a.a }); var o = e(505);
    e.d(n, "keys", function() { return o.a }); var u = e(506);
    e.d(n, "values", function() { return u.a }); var c = e(507);
    e.d(n, "entries", function() { return c.a }) }, function(t, n, e) { "use strict";
    n.a = function(t) { return +t } }, function(t, n, e) { "use strict"; var r = e(510);
    e.d(n, "a", function() { return r.a }), e.d(n, "b", function() { return r.b }); var i = (e(225), e(226));
    e.d(n, "c", function() { return i.a }); var a = e(516);
    e.d(n, "d", function() { return a.a }); var o = e(517);
    e.d(n, "e", function() { return o.a }); var u = e(518);
    e.d(n, "f", function() { return u.a }) }, function(t, n, e) { "use strict"; var r = e(72),
        i = e(511),
        a = e(512),
        o = e(226),
        u = e(227),
        c = e(228),
        f = e(515),
        s = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
    n.a = function(t) {
        function n(t) {
            function n(t) { var n, a, o, u = m,
                    d = x; if ("c" === g) d = w(t) + d, t = "";
                else { t = +t; var b = t < 0; if (t = w(Math.abs(t), _), b && 0 == +t && (b = !1), u = (b ? "(" === i ? i : "-" : "-" === i || "(" === i ? "" : i) + u, d = d + ("s" === g ? s[8 + c.b / 3] : "") + (b && "(" === i ? ")" : ""), j)
                        for (n = -1, a = t.length; ++n < a;)
                            if (48 > (o = t.charCodeAt(n)) || o > 57) { d = (46 === o ? h + t.slice(n + 1) : t.slice(n)) + d, t = t.slice(0, n); break } }
                y && !f && (t = l(t, 1 / 0)); var O = u.length + t.length + d.length,
                    M = O < v ? new Array(v - O + 1).join(e) : ""; switch (y && f && (t = l(M + t, M.length ? v - d.length : 1 / 0), M = ""), r) {
                    case "<":
                        t = u + t + d + M; break;
                    case "=":
                        t = u + M + t + d; break;
                    case "^":
                        t = M.slice(0, O = M.length >> 1) + u + t + d + M.slice(O); break;
                    default:
                        t = M + u + t + d } return p(t) }
            t = Object(o.a)(t); var e = t.fill,
                r = t.align,
                i = t.sign,
                a = t.symbol,
                f = t.zero,
                v = t.width,
                y = t.comma,
                _ = t.precision,
                g = t.type,
                m = "$" === a ? d[0] : "#" === a && /[boxX]/.test(g) ? "0" + g.toLowerCase() : "",
                x = "$" === a ? d[1] : /[%p]/.test(g) ? b : "",
                w = u.a[g],
                j = !g || /[defgprs%]/.test(g); return _ = null == _ ? g ? 6 : 12 : /[gprs]/.test(g) ? Math.max(1, Math.min(21, _)) : Math.max(0, Math.min(20, _)), n.toString = function() { return t + "" }, n }

        function e(t, e) { var i = n((t = Object(o.a)(t), t.type = "f", t)),
                a = 3 * Math.max(-8, Math.min(8, Math.floor(Object(r.a)(e) / 3))),
                u = Math.pow(10, -a),
                c = s[8 + a / 3]; return function(t) { return i(u * t) + c } } var l = t.grouping && t.thousands ? Object(i.a)(t.grouping, t.thousands) : f.a,
            d = t.currency,
            h = t.decimal,
            p = t.numerals ? Object(a.a)(t.numerals) : f.a,
            b = t.percent || "%"; return { format: n, formatPrefix: e } } }, function(t, n, e) { "use strict";

    function r(t) { return new i(t) }

    function i(t) { if (!(n = o.exec(t))) throw new Error("invalid format: " + t); var n, e = n[1] || " ",
            r = n[2] || ">",
            i = n[3] || "-",
            u = n[4] || "",
            c = !!n[5],
            f = n[6] && +n[6],
            s = !!n[7],
            l = n[8] && +n[8].slice(1),
            d = n[9] || ""; "n" === d ? (s = !0, d = "g") : a.a[d] || (d = ""), (c || "0" === e && "=" === r) && (c = !0, e = "0", r = "="), this.fill = e, this.align = r, this.sign = i, this.symbol = u, this.zero = c, this.width = f, this.comma = s, this.precision = l, this.type = d }
    n.a = r; var a = e(227),
        o = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;
    r.prototype = i.prototype, i.prototype.toString = function() { return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (null == this.width ? "" : Math.max(1, 0 | this.width)) + (this.comma ? "," : "") + (null == this.precision ? "" : "." + Math.max(0, 0 | this.precision)) + this.type } }, function(t, n, e) { "use strict"; var r = e(513),
        i = e(228),
        a = e(514);
    n.a = { "": r.a, "%": function(t, n) { return (100 * t).toFixed(n) }, b: function(t) { return Math.round(t).toString(2) }, c: function(t) { return t + "" }, d: function(t) { return Math.round(t).toString(10) }, e: function(t, n) { return t.toExponential(n) }, f: function(t, n) { return t.toFixed(n) }, g: function(t, n) { return t.toPrecision(n) }, o: function(t) { return Math.round(t).toString(8) }, p: function(t, n) { return Object(a.a)(100 * t, n) }, r: a.a, s: i.a, X: function(t) { return Math.round(t).toString(16).toUpperCase() }, x: function(t) { return Math.round(t).toString(16) } } }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return r }); var r, i = e(118);
    n.a = function(t, n) { var e = Object(i.a)(t, n); if (!e) return t + ""; var a = e[0],
            o = e[1],
            u = o - (r = 3 * Math.max(-8, Math.min(8, Math.floor(o / 3)))) + 1,
            c = a.length; return u === c ? a : u > c ? a + new Array(u - c + 1).join("0") : u > 0 ? a.slice(0, u) + "." + a.slice(u) : "0." + new Array(1 - u).join("0") + Object(i.a)(t, Math.max(0, n + u - 1))[0] } }, function(t, n, e) { "use strict";
    n.a = function(t, n) { t = t.slice(); var e, r = 0,
            i = t.length - 1,
            a = t[r],
            o = t[i]; return o < a && (e = r, r = i, i = e, e = a, a = o, o = e), t[r] = n.floor(a), t[i] = n.ceil(o), t } }, function(t, n, e) { "use strict";

    function r(t) { return new Date(t) }

    function i(t) { return t instanceof Date ? +t : +new Date(+t) }

    function a(t, n, e, c, f, m, x, w, j) {
        function O(r) { return (x(r) < r ? R : m(r) < r ? P : f(r) < r ? S : c(r) < r ? C : n(r) < r ? e(r) < r ? E : N : t(r) < r ? I : D)(r) }

        function M(n, e, r, i) { if (null == n && (n = 10), "number" == typeof n) { var a = Math.abs(r - e) / n,
                    u = Object(o.bisector)(function(t) { return t[2] }).right(B, a);
                u === B.length ? (i = Object(o.tickStep)(e / g, r / g, n), n = t) : u ? (u = B[a / B[u - 1][2] < B[u][2] / a ? u - 1 : u], i = u[1], n = u[0]) : (i = Object(o.tickStep)(e, r, n), n = w) } return null == i ? n : n.every(i) } var k = Object(l.b)(l.c, u.c),
            A = k.invert,
            T = k.domain,
            R = j(".%L"),
            P = j(":%S"),
            S = j("%I:%M"),
            C = j("%I %p"),
            E = j("%a %d"),
            N = j("%b %d"),
            I = j("%B"),
            D = j("%Y"),
            B = [
                [x, 1, h],
                [x, 5, 5 * h],
                [x, 15, 15 * h],
                [x, 30, 30 * h],
                [m, 1, p],
                [m, 5, 5 * p],
                [m, 15, 15 * p],
                [m, 30, 30 * p],
                [f, 1, b],
                [f, 3, 3 * b],
                [f, 6, 6 * b],
                [f, 12, 12 * b],
                [c, 1, v],
                [c, 2, 2 * v],
                [e, 1, y],
                [n, 1, _],
                [n, 3, 3 * _],
                [t, 1, g]
            ]; return k.invert = function(t) { return new Date(A(t)) }, k.domain = function(t) { return arguments.length ? T(s.a.call(t, i)) : T().map(r) }, k.ticks = function(t, n) { var e, r = T(),
                i = r[0],
                a = r[r.length - 1],
                o = a < i; return o && (e = i, i = a, a = e), e = M(t, i, a, n), e = e ? e.range(i, a + 1) : [], o ? e.reverse() : e }, k.tickFormat = function(t, n) { return null == n ? O : j(n) }, k.nice = function(t, n) { var e = T(); return (t = M(t, e[0], e[e.length - 1], n)) ? T(Object(d.a)(e, t)) : k }, k.copy = function() { return Object(l.a)(k, a(t, n, e, c, f, m, x, w, j)) }, k }
    n.a = a; var o = e(7),
        u = e(12),
        c = e(119),
        f = e(231),
        s = e(27),
        l = e(71),
        d = e(229),
        h = 1e3,
        p = 60 * h,
        b = 60 * p,
        v = 24 * b,
        y = 7 * v,
        _ = 30 * v,
        g = 365 * v;
    n.b = function() { return a(c.j, c.f, c.i, c.a, c.b, c.d, c.g, c.c, f.a).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]) } }, function(t, n, e) { "use strict"; var r = e(120);
    e.d(n, "a", function() { return r.a }), e.d(n, "b", function() { return r.b });
    e(232), e(233), e(538) }, function(t, n, e) { "use strict";

    function r(t) { if (0 <= t.y && t.y < 100) { var n = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L); return n.setFullYear(t.y), n } return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L) }

    function i(t) { if (0 <= t.y && t.y < 100) { var n = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L)); return n.setUTCFullYear(t.y), n } return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L)) }

    function a(t) { return { y: t, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0 } }

    function o(t) {
        function n(t, n) { return function(e) { var r, i, a, o = [],
                    u = -1,
                    c = 0,
                    f = t.length; for (e instanceof Date || (e = new Date(+e)); ++u < f;) 37 === t.charCodeAt(u) && (o.push(t.slice(c, u)), null != (i = nt[r = t.charAt(++u)]) ? r = t.charAt(++u) : i = "e" === r ? " " : "0", (a = n[r]) && (r = a(e, i)), o.push(r), c = u + 1); return o.push(t.slice(c, u)), o.join("") } }

        function e(t, n) { return function(e) { var r = a(1900); if (o(r, t, e += "", 0) != e.length) return null; if ("p" in r && (r.H = r.H % 12 + 12 * r.p), "W" in r || "U" in r) { "w" in r || (r.w = "W" in r ? 1 : 0); var u = "Z" in r ? i(a(r.y)).getUTCDay() : n(a(r.y)).getDay();
                    r.m = 0, r.d = "W" in r ? (r.w + 6) % 7 + 7 * r.W - (u + 5) % 7 : r.w + 7 * r.U - (u + 6) % 7 } return "Z" in r ? (r.H += r.Z / 100 | 0, r.M += r.Z % 100, i(r)) : n(r) } }

        function o(t, n, e, r) { for (var i, a, o = 0, u = n.length, c = e.length; o < u;) { if (r >= c) return -1; if (37 === (i = n.charCodeAt(o++))) { if (i = n.charAt(o++), !(a = Bt[i in nt ? n.charAt(o++) : i]) || (r = a(t, e, r)) < 0) return -1 } else if (i != e.charCodeAt(r++)) return -1 } return r }

        function u(t, n, e) { var r = Mt.exec(n.slice(e)); return r ? (t.p = kt[r[0].toLowerCase()], e + r[0].length) : -1 }

        function c(t, n, e) { var r = Rt.exec(n.slice(e)); return r ? (t.w = Pt[r[0].toLowerCase()], e + r[0].length) : -1 }

        function tt(t, n, e) { var r = At.exec(n.slice(e)); return r ? (t.w = Tt[r[0].toLowerCase()], e + r[0].length) : -1 }

        function et(t, n, e) { var r = Et.exec(n.slice(e)); return r ? (t.m = Nt[r[0].toLowerCase()], e + r[0].length) : -1 }

        function rt(t, n, e) { var r = St.exec(n.slice(e)); return r ? (t.m = Ct[r[0].toLowerCase()], e + r[0].length) : -1 }

        function it(t, n, e) { return o(t, yt, n, e) }

        function at(t, n, e) { return o(t, _t, n, e) }

        function ot(t, n, e) { return o(t, gt, n, e) }

        function ut(t) { return wt[t.getDay()] }

        function ct(t) { return xt[t.getDay()] }

        function ft(t) { return Ot[t.getMonth()] }

        function st(t) { return jt[t.getMonth()] }

        function lt(t) { return mt[+(t.getHours() >= 12)] }

        function dt(t) { return wt[t.getUTCDay()] }

        function ht(t) { return xt[t.getUTCDay()] }

        function pt(t) { return Ot[t.getUTCMonth()] }

        function bt(t) { return jt[t.getUTCMonth()] }

        function vt(t) { return mt[+(t.getUTCHours() >= 12)] } var yt = t.dateTime,
            _t = t.date,
            gt = t.time,
            mt = t.periods,
            xt = t.days,
            wt = t.shortDays,
            jt = t.months,
            Ot = t.shortMonths,
            Mt = f(mt),
            kt = s(mt),
            At = f(xt),
            Tt = s(xt),
            Rt = f(wt),
            Pt = s(wt),
            St = f(jt),
            Ct = s(jt),
            Et = f(Ot),
            Nt = s(Ot),
            It = { a: ut, A: ct, b: ft, B: st, c: null, d: M, e: M, H: k, I: A, j: T, L: R, m: P, M: S, p: lt, S: C, U: E, w: N, W: I, x: null, X: null, y: D, Y: B, Z: z, "%": Q },
            Dt = { a: dt, A: ht, b: pt, B: bt, c: null, d: L, e: L, H: F, I: U, j: W, L: Y, m: q, M: G, p: vt, S: V, U: H, w: X, W: $, x: null, X: null, y: K, Y: Z, Z: J, "%": Q },
            Bt = { a: c, A: tt, b: et, B: rt, c: it, d: _, e: _, H: m, I: m, j: g, L: j, m: y, M: x, p: u, S: w, U: d, w: l, W: h, x: at, X: ot, y: b, Y: p, Z: v, "%": O }; return It.x = n(_t, It), It.X = n(gt, It), It.c = n(yt, It), Dt.x = n(_t, Dt), Dt.X = n(gt, Dt), Dt.c = n(yt, Dt), { format: function(t) { var e = n(t += "", It); return e.toString = function() { return t }, e }, parse: function(t) { var n = e(t += "", r); return n.toString = function() { return t }, n }, utcFormat: function(t) { var e = n(t += "", Dt); return e.toString = function() { return t }, e }, utcParse: function(t) { var n = e(t, i); return n.toString = function() { return t }, n } } }

    function u(t, n, e) { var r = t < 0 ? "-" : "",
            i = (r ? -t : t) + "",
            a = i.length; return r + (a < e ? new Array(e - a + 1).join(n) + i : i) }

    function c(t) { return t.replace(it, "\\$&") }

    function f(t) { return new RegExp("^(?:" + t.map(c).join("|") + ")", "i") }

    function s(t) { for (var n = {}, e = -1, r = t.length; ++e < r;) n[t[e].toLowerCase()] = e; return n }

    function l(t, n, e) { var r = et.exec(n.slice(e, e + 1)); return r ? (t.w = +r[0], e + r[0].length) : -1 }

    function d(t, n, e) { var r = et.exec(n.slice(e)); return r ? (t.U = +r[0], e + r[0].length) : -1 }

    function h(t, n, e) { var r = et.exec(n.slice(e)); return r ? (t.W = +r[0], e + r[0].length) : -1 }

    function p(t, n, e) { var r = et.exec(n.slice(e, e + 4)); return r ? (t.y = +r[0], e + r[0].length) : -1 }

    function b(t, n, e) { var r = et.exec(n.slice(e, e + 2)); return r ? (t.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), e + r[0].length) : -1 }

    function v(t, n, e) { var r = /^(Z)|([+-]\d\d)(?:\:?(\d\d))?/.exec(n.slice(e, e + 6)); return r ? (t.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), e + r[0].length) : -1 }

    function y(t, n, e) { var r = et.exec(n.slice(e, e + 2)); return r ? (t.m = r[0] - 1, e + r[0].length) : -1 }

    function _(t, n, e) { var r = et.exec(n.slice(e, e + 2)); return r ? (t.d = +r[0], e + r[0].length) : -1 }

    function g(t, n, e) { var r = et.exec(n.slice(e, e + 3)); return r ? (t.m = 0, t.d = +r[0], e + r[0].length) : -1 }

    function m(t, n, e) { var r = et.exec(n.slice(e, e + 2)); return r ? (t.H = +r[0], e + r[0].length) : -1 }

    function x(t, n, e) { var r = et.exec(n.slice(e, e + 2)); return r ? (t.M = +r[0], e + r[0].length) : -1 }

    function w(t, n, e) { var r = et.exec(n.slice(e, e + 2)); return r ? (t.S = +r[0], e + r[0].length) : -1 }

    function j(t, n, e) { var r = et.exec(n.slice(e, e + 3)); return r ? (t.L = +r[0], e + r[0].length) : -1 }

    function O(t, n, e) { var r = rt.exec(n.slice(e, e + 1)); return r ? e + r[0].length : -1 }

    function M(t, n) { return u(t.getDate(), n, 2) }

    function k(t, n) { return u(t.getHours(), n, 2) }

    function A(t, n) { return u(t.getHours() % 12 || 12, n, 2) }

    function T(t, n) { return u(1 + tt.a.count(Object(tt.j)(t), t), n, 3) }

    function R(t, n) { return u(t.getMilliseconds(), n, 3) }

    function P(t, n) { return u(t.getMonth() + 1, n, 2) }

    function S(t, n) { return u(t.getMinutes(), n, 2) }

    function C(t, n) { return u(t.getSeconds(), n, 2) }

    function E(t, n) { return u(tt.h.count(Object(tt.j)(t), t), n, 2) }

    function N(t) { return t.getDay() }

    function I(t, n) { return u(tt.e.count(Object(tt.j)(t), t), n, 2) }

    function D(t, n) { return u(t.getFullYear() % 100, n, 2) }

    function B(t, n) { return u(t.getFullYear() % 1e4, n, 4) }

    function z(t) { var n = t.getTimezoneOffset(); return (n > 0 ? "-" : (n *= -1, "+")) + u(n / 60 | 0, "0", 2) + u(n % 60, "0", 2) }

    function L(t, n) { return u(t.getUTCDate(), n, 2) }

    function F(t, n) { return u(t.getUTCHours(), n, 2) }

    function U(t, n) { return u(t.getUTCHours() % 12 || 12, n, 2) }

    function W(t, n) { return u(1 + tt.k.count(Object(tt.t)(t), t), n, 3) }

    function Y(t, n) { return u(t.getUTCMilliseconds(), n, 3) }

    function q(t, n) { return u(t.getUTCMonth() + 1, n, 2) }

    function G(t, n) { return u(t.getUTCMinutes(), n, 2) }

    function V(t, n) { return u(t.getUTCSeconds(), n, 2) }

    function H(t, n) { return u(tt.r.count(Object(tt.t)(t), t), n, 2) }

    function X(t) { return t.getUTCDay() }

    function $(t, n) { return u(tt.o.count(Object(tt.t)(t), t), n, 2) }

    function K(t, n) { return u(t.getUTCFullYear() % 100, n, 2) }

    function Z(t, n) { return u(t.getUTCFullYear() % 1e4, n, 4) }

    function J() { return "+0000" }

    function Q() { return "%" }
    n.a = o; var tt = e(119),
        nt = { "-": "", _: " ", 0: "0" },
        et = /^\s*\d+/,
        rt = /^%/,
        it = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g }, function(t, n, e) { "use strict";

    function r(t) { return t.toISOString() }
    e.d(n, "a", function() { return a }); var i = e(120),
        a = "%Y-%m-%dT%H:%M:%S.%LZ";
    Date.prototype.toISOString || Object(i.b)(a) }, function(t, n, e) { "use strict";
    e.d(n, "a", function() { return r }), e.d(n, "d", function() { return i }), e.d(n, "b", function() { return o }), e.d(n, "e", function() { return u }), e.d(n, "c", function() { return c }); var r = Math.cos,
        i = Math.sin,
        a = Math.PI,
        o = a / 2,
        u = 2 * a,
        c = Math.max }, function(t, n, e) { "use strict";

    function r(t) { return t && t.__esModule ? t : { default: t } }

    function i(t, n) { if (!(t instanceof n)) throw new TypeError("Cannot call a class as a function") } var a = function() {
            function t(t, n) { for (var e = 0; e < n.length; e++) { var r = n[e];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } return function(n, e, r) { return e && t(n.prototype, e), r && t(n, r), n } }(),
        o = e(121),
        u = r(o),
        c = e(32),
        f = r(c),
        s = e(2),
        l = r(s),
        d = e(140),
        h = r(d),
        p = e(3),
        b = e(342),
        v = r(b),
        y = e(358),
        _ = r(y),
        g = e(406),
        m = r(g),
        x = e(597),
        w = r(x),
        j = e(598),
        O = r(j),
        M = e(599),
        k = r(M),
        A = e(605),
        T = r(A),
        R = e(606),
        P = r(R),
        S = e(607),
        C = r(S),
        E = e(608),
        N = r(E),
        I = e(609),
        D = { width: 700, height: 700, container: "circos", defaultTrackWidth: 10 },
        B = function() {
            function t(n) { i(this, t), this.tracks = {}, this._layout = null, this.conf = (0, u.default)(n, D); var e = (0, p.select)(this.conf.container).append("div").style("position", "relative");
                this.svg = e.append("svg"), (0, p.select)("body").select(".circos-tooltip").empty() ? this.tip = (0, p.select)("body").append("div").attr("class", "circos-tooltip").style("opacity", 0) : this.tip = (0, p.select)("body").select(".circos-tooltip"), this.clipboard = (0, I.initClipboard)(this.conf.container) } return a(t, [{ key: "removeTracks", value: function(t) { var n = this; return void 0 === t ? ((0, h.default)(this.tracks, function(t, e) { n.svg.select("." + e).remove() }), this.tracks = {}) : "string" == typeof t ? (this.svg.select("." + t).remove(), delete this.tracks[t]) : (0, l.default)(t) ? (0, f.default)(t, function(t) { this.svg.select("." + t).remove(), delete this.tracks[t] }) : console.warn("removeTracks received an unhandled attribute type"), this } }, { key: "layout", value: function(t, n) { return this._layout = new v.default(n, t), this } }, { key: "chords", value: function(t, n, e) { return this.tracks[t] = new k.default(this, e, n), this } }, { key: "heatmap", value: function(t, n, e) { return this.tracks[t] = new T.default(this, e, n), this } }, { key: "highlight", value: function(t, n, e) { return this.tracks[t] = new w.default(this, e, n), this } }, { key: "histogram", value: function(t, n, e) { return this.tracks[t] = new O.default(this, e, n), this } }, { key: "line", value: function(t, n, e) { return this.tracks[t] = new P.default(this, e, n), this } }, { key: "scatter", value: function(t, n, e) { return this.tracks[t] = new C.default(this, e, n), this } }, { key: "stack", value: function(t, n, e) { return this.tracks[t] = new N.default(this, e, n), this } }, { key: "text", value: function(t, n, e) { return this.tracks[t] = new m.default(this, e, n), this } }, { key: "render", value: function(t, n) {
                    (0, _.default)(t, n, this) } }]), t }(),
        z = function(t) { return new B(t) };
    t.exports = z }, function(t, n, e) { var r = e(237),
        i = e(123),
        a = e(28),
        o = i ? function(t, n) { return i(t, "toString", { configurable: !0, enumerable: !1, value: r(n), writable: !0 }) } : a;
    t.exports = o }, function(t, n) {
    function e(t) { return function() { return t } }
    t.exports = e }, function(t, n, e) {
    function r(t) { return !(!o(t) || a(t)) && (i(t) ? p : f).test(u(t)) } var i = e(23),
        a = e(241),
        o = e(6),
        u = e(126),
        c = /[\\^$.*+?()[\]{}|]/g,
        f = /^\[object .+?Constructor\]$/,
        s = Function.prototype,
        l = Object.prototype,
        d = s.toString,
        h = l.hasOwnProperty,
        p = RegExp("^" + d.call(h).replace(c, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    t.exports = r }, function(t, n, e) {
    function r(t) { var n = o.call(t, c),
            e = t[c]; try { t[c] = void 0; var r = !0 } catch (t) {} var i = u.call(t); return r && (n ? t[c] = e : delete t[c]), i } var i = e(29),
        a = Object.prototype,
        o = a.hasOwnProperty,
        u = a.toString,
        c = i ? i.toStringTag : void 0;
    t.exports = r }, function(t, n) {
    function e(t) { return i.call(t) } var r = Object.prototype,
        i = r.toString;
    t.exports = e }, function(t, n, e) {
    function r(t) { return !!a && a in t } var i = e(242),
        a = function() { var t = /[^.]+$/.exec(i && i.keys && i.keys.IE_PROTO || ""); return t ? "Symbol(src)_1." + t : "" }();
    t.exports = r }, function(t, n, e) { var r = e(5),
        i = r["__core-js_shared__"];
    t.exports = i }, function(t, n) {
    function e(t, n) { return null == t ? void 0 : t[n] }
    t.exports = e }, function(t, n, e) {
    function r(t, n, e, o, u, c) { return a(t) && a(n) && (c.set(n, t), i(t, n, void 0, r, c), c.delete(n)), t } var i = e(128),
        a = e(6);
    t.exports = r }, function(t, n) {
    function e() { this.__data__ = [], this.size = 0 }
    t.exports = e }, function(t, n, e) {
    function r(t) { var n = this.__data__,
            e = i(n, t); return !(e < 0) && (e == n.length - 1 ? n.pop() : o.call(n, e, 1), --this.size, !0) } var i = e(52),
        a = Array.prototype,
        o = a.splice;
    t.exports = r }, function(t, n, e) {
    function r(t) { var n = this.__data__,
            e = i(n, t); return e < 0 ? void 0 : n[e][1] } var i = e(52);
    t.exports = r }, function(t, n, e) {
    function r(t) { return i(this.__data__, t) > -1 } var i = e(52);
    t.exports = r }, function(t, n, e) {
    function r(t, n) { var e = this.__data__,
            r = i(e, t); return r < 0 ? (++this.size, e.push([t, n])) : e[r][1] = n, this } var i = e(52);
    t.exports = r }, function(t, n, e) {
    function r() { this.__data__ = new i, this.size = 0 } var i = e(51);
    t.exports = r }, function(t, n) {
    function e(t) { var n = this.__data__,
            e = n.delete(t); return this.size = n.size, e }
    t.exports = e }, function(t, n) {
    function e(t) { return this.__data__.get(t) }
    t.exports = e }, function(t, n) {
    function e(t) { return this.__data__.has(t) }
    t.exports = e }, function(t, n, e) {
    function r(t, n) { var e = this.__data__; if (e instanceof i) { var r = e.__data__; if (!a || r.length < u - 1) return r.push([t, n]), this.size = ++e.size, this;
            e = this.__data__ = new o(r) } return e.set(t, n), this.size = e.size, this } var i = e(51),
        a = e(75),
        o = e(76),
        u = 200;
    t.exports = r }, function(t, n, e) {
    function r() { this.size = 0, this.__data__ = { hash: new i, map: new(o || a), string: new i } } var i = e(256),
        a = e(51),
        o = e(75);
    t.exports = r }, function(t, n, e) {
    function r(t) { var n = -1,
            e = null == t ? 0 : t.length; for (this.clear(); ++n < e;) { var r = t[n];
            this.set(r[0], r[1]) } } var i = e(257),
        a = e(258),
        o = e(259),
        u = e(260),
        c = e(261);
    r.prototype.clear = i, r.prototype.delete = a, r.prototype.get = o, r.prototype.has = u, r.prototype.set = c, t.exports = r }, function(t, n, e) {
    function r() { this.__data__ = i ? i(null) : {}, this.size = 0 } var i = e(53);
    t.exports = r }, function(t, n) {
    function e(t) { var n = this.has(t) && delete this.__data__[t]; return this.size -= n ? 1 : 0, n }
    t.exports = e }, function(t, n, e) {
    function r(t) { var n = this.__data__; if (i) { var e = n[t]; return e === a ? void 0 : e } return u.call(n, t) ? n[t] : void 0 } var i = e(53),
        a = "__lodash_hash_undefined__",
        o = Object.prototype,
        u = o.hasOwnProperty;
    t.exports = r }, function(t, n, e) {
    function r(t) { var n = this.__data__; return i ? void 0 !== n[t] : o.call(n, t) } var i = e(53),
        a = Object.prototype,
        o = a.hasOwnProperty;
    t.exports = r }, function(t, n, e) {
    function r(t, n) { var e = this.__data__; return this.size += this.has(t) ? 0 : 1, e[t] = i && void 0 === n ? a : n, this } var i = e(53),
        a = "__lodash_hash_undefined__";
    t.exports = r }, function(t, n, e) {
    function r(t) { var n = i(this, t).delete(t); return this.size -= n ? 1 : 0, n } var i = e(54);
    t.exports = r }, function(t, n) {
    function e(t) { var n = typeof t; return "string" == n || "number" == n || "symbol" == n || "boolean" == n ? "__proto__" !== t : null === t }
    t.exports = e }, function(t, n, e) {
    function r(t) { return i(this, t).get(t) } var i = e(54);
    t.exports = r }, function(t, n, e) {
    function r(t) { return i(this, t).has(t) } var i = e(54);
    t.exports = r }, function(t, n, e) {
    function r(t, n) { var e = i(this, t),
            r = e.size; return e.set(t, n), this.size += e.size == r ? 0 : 1, this } var i = e(54);
    t.exports = r }, function(t, n) {
    function e(t) { return function(n, e, r) { for (var i = -1, a = Object(n), o = r(n), u = o.length; u--;) { var c = o[t ? u : ++i]; if (!1 === e(a[c], c, a)) break } return n } }
    t.exports = e }, function(t, n, e) {
    function r(t, n, e, r, _, g, m) { var x = t[e],
            w = n[e],
            j = m.get(w); if (j) return void i(t, e, j); var O = g ? g(x, w, e + "", t, n, m) : void 0,
            M = void 0 === O; if (M) { var k = s(w),
                A = !k && d(w),
                T = !k && !A && v(w);
            O = w, k || A || T ? s(x) ? O = x : l(x) ? O = u(x) : A ? (M = !1, O = a(w, !0)) : T ? (M = !1, O = o(w, !0)) : O = [] : b(w) || f(w) ? (O = x, f(x) ? O = y(x) : (!p(x) || r && h(x)) && (O = c(w))) : M = !1 }
        M && (m.set(w, O), _(O, w, r, g, m), m.delete(w)), i(t, e, O) } var i = e(129),
        a = e(131),
        o = e(132),
        u = e(30),
        c = e(134),
        f = e(57),
        s = e(2),
        l = e(270),
        d = e(58),
        h = e(23),
        p = e(6),
        b = e(272),
        v = e(82),
        y = e(275);
    t.exports = r }, function(t, n, e) {
    function r(t) { return a(t) && i(t) == o } var i = e(24),
        a = e(10),
        o = "[object Arguments]";
    t.exports = r }, function(t, n, e) {
    function r(t) { return a(t) && i(t) } var i = e(16),
        a = e(10);
    t.exports = r }, function(t, n) {
    function e() { return !1 }
    t.exports = e }, function(t, n, e) {
    function r(t) { if (!o(t) || i(t) != u) return !1; var n = a(t); if (null === n) return !0; var e = l.call(n, "constructor") && n.constructor; return "function" == typeof e && e instanceof e && s.call(e) == d } var i = e(24),
        a = e(80),
        o = e(10),
        u = "[object Object]",
        c = Function.prototype,
        f = Object.prototype,
        s = c.toString,
        l = f.hasOwnProperty,
        d = s.call(Object);
    t.exports = r }, function(t, n, e) {
    function r(t) { return o(t) && a(t.length) && !!u[i(t)] } var i = e(24),
        a = e(81),
        o = e(10),
        u = {};
    u["[object Float32Array]"] = u["[object Float64Array]"] = u["[object Int8Array]"] = u["[object Int16Array]"] = u["[object Int32Array]"] = u["[object Uint8Array]"] = u["[object Uint8ClampedArray]"] = u["[object Uint16Array]"] = u["[object Uint32Array]"] = !0, u["[object Arguments]"] = u["[object Array]"] = u["[object ArrayBuffer]"] = u["[object Boolean]"] = u["[object DataView]"] = u["[object Date]"] = u["[object Error]"] = u["[object Function]"] = u["[object Map]"] = u["[object Number]"] = u["[object Object]"] = u["[object RegExp]"] = u["[object Set]"] = u["[object String]"] = u["[object WeakMap]"] = !1, t.exports = r }, function(t, n, e) {
    (function(t) { var r = e(124),
            i = "object" == typeof n && n && !n.nodeType && n,
            a = i && "object" == typeof t && t && !t.nodeType && t,
            o = a && a.exports === i,
            u = o && r.process,
            c = function() { try { return u && u.binding && u.binding("util") } catch (t) {} }();
        t.exports = c }).call(n, e(78)(t)) }, function(t, n, e) {
    function r(t) { return i(t, a(t)) } var i = e(31),
        a = e(59);
    t.exports = r }, function(t, n) {
    function e(t, n) { for (var e = -1, r = Array(t); ++e < t;) r[e] = n(e); return r }
    t.exports = e }, function(t, n, e) {
    function r(t) { if (!i(t)) return o(t); var n = a(t),
            e = []; for (var r in t)("constructor" != r || !n && c.call(t, r)) && e.push(r); return e } var i = e(6),
        a = e(56),
        o = e(278),
        u = Object.prototype,
        c = u.hasOwnProperty;
    t.exports = r }, function(t, n) {
    function e(t) { var n = []; if (null != t)
            for (var e in Object(t)) n.push(e); return n }
    t.exports = e }, function(t, n, e) { var r = e(128),
        i = e(138),
        a = i(function(t, n, e, i) { r(t, n, e, i) });
    t.exports = a }, function(t, n, e) {
    function r(t, n) { return t && i(t, n, a) } var i = e(130),
        a = e(17);
    t.exports = r }, function(t, n, e) { var r = e(135),
        i = r(Object.keys, Object);
    t.exports = i }, function(t, n, e) {
    function r(t, n) { return function(e, r) { if (null == e) return e; if (!i(e)) return t(e, r); for (var a = e.length, o = n ? a : -1, u = Object(e);
                (n ? o-- : ++o < a) && !1 !== r(u[o], o, u);); return e } } var i = e(16);
    t.exports = r }, function(t, n, e) {
    function r(t) { return "function" == typeof t ? t : i } var i = e(28);
    t.exports = r }, function(t, n, e) {
    function r(t) { var n = a(t); return 1 == n.length && n[0][2] ? o(n[0][0], n[0][1]) : function(e) { return e === t || i(e, t, n) } } var i = e(285),
        a = e(297),
        o = e(152);
    t.exports = r }, function(t, n, e) {
    function r(t, n, e, r) { var c = e.length,
            f = c,
            s = !r; if (null == t) return !f; for (t = Object(t); c--;) { var l = e[c]; if (s && l[2] ? l[1] !== t[l[0]] : !(l[0] in t)) return !1 } for (; ++c < f;) { l = e[c]; var d = l[0],
                h = t[d],
                p = l[1]; if (s && l[2]) { if (void 0 === h && !(d in t)) return !1 } else { var b = new i; if (r) var v = r(h, p, d, t, n, b); if (!(void 0 === v ? a(p, h, o | u, r, b) : v)) return !1 } } return !0 } var i = e(50),
        a = e(141),
        o = 1,
        u = 2;
    t.exports = r }, function(t, n, e) {
    function r(t, n, e, r, v, _) { var g = f(t),
            m = f(n),
            x = g ? p : c(t),
            w = m ? p : c(n);
        x = x == h ? b : x, w = w == h ? b : w; var j = x == b,
            O = w == b,
            M = x == w; if (M && s(t)) { if (!s(n)) return !1;
            g = !0, j = !1 } if (M && !j) return _ || (_ = new i), g || l(t) ? a(t, n, e, r, v, _) : o(t, n, x, e, r, v, _); if (!(e & d)) { var k = j && y.call(t, "__wrapped__"),
                A = O && y.call(n, "__wrapped__"); if (k || A) { var T = k ? t.value() : t,
                    R = A ? n.value() : n; return _ || (_ = new i), v(T, R, e, r, _) } } return !!M && (_ || (_ = new i), u(t, n, e, r, v, _)) } var i = e(50),
        a = e(142),
        o = e(292),
        u = e(293),
        c = e(149),
        f = e(2),
        s = e(58),
        l = e(82),
        d = 1,
        h = "[object Arguments]",
        p = "[object Array]",
        b = "[object Object]",
        v = Object.prototype,
        y = v.hasOwnProperty;
    t.exports = r }, function(t, n, e) {
    function r(t) { var n = -1,
            e = null == t ? 0 : t.length; for (this.__data__ = new i; ++n < e;) this.add(t[n]) } var i = e(76),
        a = e(288),
        o = e(289);
    r.prototype.add = r.prototype.push = a, r.prototype.has = o, t.exports = r }, function(t, n) {
    function e(t) { return this.__data__.set(t, r), this } var r = "__lodash_hash_undefined__";
    t.exports = e }, function(t, n) {
    function e(t) { return this.__data__.has(t) }
    t.exports = e }, function(t, n) {
    function e(t, n) { for (var e = -1, r = null == t ? 0 : t.length; ++e < r;)
            if (n(t[e], e, t)) return !0;
        return !1 }
    t.exports = e }, function(t, n) {
    function e(t, n) { return t.has(n) }
    t.exports = e }, function(t, n, e) {
    function r(t, n, e, r, i, j, M) { switch (e) {
            case w:
                if (t.byteLength != n.byteLength || t.byteOffset != n.byteOffset) return !1;
                t = t.buffer, n = n.buffer;
            case x:
                return !(t.byteLength != n.byteLength || !j(new a(t), new a(n)));
            case d:
            case h:
            case v:
                return o(+t, +n);
            case p:
                return t.name == n.name && t.message == n.message;
            case y:
            case g:
                return t == n + "";
            case b:
                var k = c;
            case _:
                var A = r & s; if (k || (k = f), t.size != n.size && !A) return !1; var T = M.get(t); if (T) return T == n;
                r |= l, M.set(t, n); var R = u(k(t), k(n), r, i, j, M); return M.delete(t), R;
            case m:
                if (O) return O.call(t) == O.call(n) } return !1 } var i = e(29),
        a = e(133),
        o = e(38),
        u = e(142),
        c = e(143),
        f = e(144),
        s = 1,
        l = 2,
        d = "[object Boolean]",
        h = "[object Date]",
        p = "[object Error]",
        b = "[object Map]",
        v = "[object Number]",
        y = "[object RegExp]",
        _ = "[object Set]",
        g = "[object String]",
        m = "[object Symbol]",
        x = "[object ArrayBuffer]",
        w = "[object DataView]",
        j = i ? i.prototype : void 0,
        O = j ? j.valueOf : void 0;
    t.exports = r }, function(t, n, e) {
    function r(t, n, e, r, o, c) { var f = e & a,
            s = i(t),
            l = s.length; if (l != i(n).length && !f) return !1; for (var d = l; d--;) { var h = s[d]; if (!(f ? h in n : u.call(n, h))) return !1 } var p = c.get(t); if (p && c.get(n)) return p == n; var b = !0;
        c.set(t, n), c.set(n, t); for (var v = f; ++d < l;) { h = s[d]; var y = t[h],
                _ = n[h]; if (r) var g = f ? r(_, y, h, n, t, c) : r(y, _, h, t, n, c); if (!(void 0 === g ? y === _ || o(y, _, e, r, c) : g)) { b = !1; break }
            v || (v = "constructor" == h) } if (b && !v) { var m = t.constructor,
                x = n.constructor;
            m != x && "constructor" in t && "constructor" in n && !("function" == typeof m && m instanceof m && "function" == typeof x && x instanceof x) && (b = !1) } return c.delete(t), c.delete(n), b } var i = e(145),
        a = 1,
        o = Object.prototype,
        u = o.hasOwnProperty;
    t.exports = r }, function(t, n, e) { var r = e(22),
        i = e(5),
        a = r(i, "DataView");
    t.exports = a }, function(t, n, e) { var r = e(22),
        i = e(5),
        a = r(i, "Promise");
    t.exports = a }, function(t, n, e) { var r = e(22),
        i = e(5),
        a = r(i, "Set");
    t.exports = a }, function(t, n, e) {
    function r(t) { for (var n = a(t), e = n.length; e--;) { var r = n[e],
                o = t[r];
            n[e] = [r, o, i(o)] } return n } var i = e(151),
        a = e(17);
    t.exports = r }, function(t, n, e) {
    function r(t, n) { return u(t) && c(n) ? f(s(t), n) : function(e) { var r = a(e, t); return void 0 === r && r === n ? o(e, t) : i(n, r, l | d) } } var i = e(141),
        a = e(299),
        o = e(303),
        u = e(85),
        c = e(151),
        f = e(152),
        s = e(41),
        l = 1,
        d = 2;
    t.exports = r }, function(t, n, e) {
    function r(t, n, e) { var r = null == t ? void 0 : i(t, n); return void 0 === r ? e : r } var i = e(153);
    t.exports = r }, function(t, n, e) {
    function r(t) { var n = i(t, function(t) { return e.size === a && e.clear(), t }),
            e = n.cache; return n } var i = e(301),
        a = 500;
    t.exports = r }, function(t, n, e) {
    function r(t, n) { if ("function" != typeof t || null != n && "function" != typeof n) throw new TypeError(a); var e = function() { var r = arguments,
                i = n ? n.apply(this, r) : r[0],
                a = e.cache; if (a.has(i)) return a.get(i); var o = t.apply(this, r); return e.cache = a.set(i, o) || a, o }; return e.cache = new(r.Cache || i), e } var i = e(76),
        a = "Expected a function";
    r.Cache = i, t.exports = r }, function(t, n, e) {
    function r(t) { if ("string" == typeof t) return t; if (o(t)) return a(t, r) + ""; if (u(t)) return s ? s.call(t) : ""; var n = t + ""; return "0" == n && 1 / t == -c ? "-0" : n } var i = e(29),
        a = e(40),
        o = e(2),
        u = e(34),
        c = 1 / 0,
        f = i ? i.prototype : void 0,
        s = f ? f.toString : void 0;
    t.exports = r }, function(t, n, e) {
    function r(t, n) { return null != t && a(t, n, i) } var i = e(304),
        a = e(305);
    t.exports = r }, function(t, n) {
    function e(t, n) { return null != t && n in Object(t) }
    t.exports = e }, function(t, n, e) {
    function r(t, n, e) { n = i(n, t); for (var r = -1, s = n.length, l = !1; ++r < s;) { var d = f(n[r]); if (!(l = null != t && e(t, d))) break;
            t = t[d] } return l || ++r != s ? l : !!(s = null == t ? 0 : t.length) && c(s) && u(d, s) && (o(t) || a(t)) } var i = e(154),
        a = e(57),
        o = e(2),
        u = e(60),
        c = e(81),
        f = e(41);
    t.exports = r }, function(t, n, e) {
    function r(t) { return o(t) ? i(u(t)) : a(t) } var i = e(307),
        a = e(308),
        o = e(85),
        u = e(41);
    t.exports = r }, function(t, n) {
    function e(t) { return function(n) { return null == n ? void 0 : n[t] } }
    t.exports = e }, function(t, n, e) {
    function r(t) { return function(n) { return i(n, t) } } var i = e(153);
    t.exports = r }, function(t, n, e) { "use strict";

    function r() { return new i }

    function i() { this._ = "@" + (++a).toString(36) }
    n.a = r; var a = 0;
    i.prototype = r.prototype = { constructor: i, get: function(t) { for (var n = this._; !(n in t);)
                if (!(t = t.parentNode)) return;
            return t[n] }, set: function(t, n) { return t[this._] = n }, remove: function(t) { return this._ in t && delete t[this._] }, toString: function() { return this._ } } }, function(t, n, e) { "use strict"; var r = e(89),
        i = e(91);
    n.a = function(t) { var n = Object(r.a)(); return n.changedTouches && (n = n.changedTouches[0]), Object(i.a)(t, n) } }, function(t, n, e) { "use strict"; var r = e(8);
    n.a = function(t) { return "string" == typeof t ? new r.a([
            [document.querySelector(t)]
        ], [document.documentElement]) : new r.a([
            [t]
        ], r.c) } }, function(t, n, e) { "use strict"; var r = e(8),
        i = e(92);
    n.a = function(t) { "function" != typeof t && (t = Object(i.a)(t)); for (var n = this._groups, e = n.length, a = new Array(e), o = 0; o < e; ++o)
            for (var u, c, f = n[o], s = f.length, l = a[o] = new Array(s), d = 0; d < s; ++d)(u = f[d]) && (c = t.call(u, u.__data__, d, f)) && ("__data__" in u && (c.__data__ = u.__data__), l[d] = c); return new r.a(a, this._parents) } }, function(t, n, e) { "use strict"; var r = e(8),
        i = e(159);
    n.a = function(t) { "function" != typeof t && (t = Object(i.a)(t)); for (var n = this._groups, e = n.length, a = [], o = [], u = 0; u < e; ++u)
            for (var c, f = n[u], s = f.length, l = 0; l < s; ++l)(c = f[l]) && (a.push(t.call(c, c.__data__, l, f)), o.push(c)); return new r.a(a, o) } }, function(t, n, e) { "use strict"; var r = e(8),
        i = e(158);
    n.a = function(t) { "function" != typeof t && (t = Object(i.a)(t)); for (var n = this._groups, e = n.length, a = new Array(e), o = 0; o < e; ++o)
            for (var u, c = n[o], f = c.length, s = a[o] = [], l = 0; l < f; ++l)(u = c[l]) && t.call(u, u.__data__, l, c) && s.push(u); return new r.a(a, this._parents) } }, function(t, n, e) { "use strict";

    function r(t, n, e, r, i, a) { for (var u, c = 0, f = n.length, s = a.length; c < s; ++c)(u = n[c]) ? (u.__data__ = a[c], r[c] = u) : e[c] = new o.a(t, a[c]); for (; c < f; ++c)(u = n[c]) && (i[c] = u) }

    function i(t, n, e, r, i, a, u) { var f, s, l, d = {},
            h = n.length,
            p = a.length,
            b = new Array(h); for (f = 0; f < h; ++f)(s = n[f]) && (b[f] = l = c + u.call(s, s.__data__, f, n), l in d ? i[f] = s : d[l] = s); for (f = 0; f < p; ++f) l = c + u.call(t, a[f], f, a), (s = d[l]) ? (r[f] = s, s.__data__ = a[f], d[l] = null) : e[f] = new o.a(t, a[f]); for (f = 0; f < h; ++f)(s = n[f]) && d[b[f]] === s && (i[f] = s) } var a = e(8),
        o = e(160),
        u = e(316),
        c = "$";
    n.a = function(t, n) { if (!t) return y = new Array(this.size()), h = -1, this.each(function(t) { y[++h] = t }), y; var e = n ? i : r,
            o = this._parents,
            c = this._groups; "function" != typeof t && (t = Object(u.a)(t)); for (var f = c.length, s = new Array(f), l = new Array(f), d = new Array(f), h = 0; h < f; ++h) { var p = o[h],
                b = c[h],
                v = b.length,
                y = t.call(p, p && p.__data__, h, o),
                _ = y.length,
                g = l[h] = new Array(_),
                m = s[h] = new Array(_);
            e(p, b, g, m, d[h] = new Array(v), y, n); for (var x, w, j = 0, O = 0; j < _; ++j)
                if (x = g[j]) { for (j >= O && (O = j + 1); !(w = m[O]) && ++O < _;);
                    x._next = w || null } } return s = new a.a(s, o), s._enter = l, s._exit = d, s } }, function(t, n, e) { "use strict";
    n.a = function(t) { return function() { return t } } }, function(t, n, e) { "use strict"; var r = e(161),
        i = e(8);
    n.a = function() { return new i.a(this._exit || this._groups.map(r.a), this._parents) } }, function(t, n, e) { "use strict"; var r = e(8);
    n.a = function(t) { for (var n = this._groups, e = t._groups, i = n.length, a = e.length, o = Math.min(i, a), u = new Array(i), c = 0; c < o; ++c)
            for (var f, s = n[c], l = e[c], d = s.length, h = u[c] = new Array(d), p = 0; p < d; ++p)(f = s[p] || l[p]) && (h[p] = f); for (; c < i; ++c) u[c] = n[c]; return new r.a(u, this._parents) } }, function(t, n, e) { "use strict";
    n.a = function() { for (var t = this._groups, n = -1, e = t.length; ++n < e;)
            for (var r, i = t[n], a = i.length - 1, o = i[a]; --a >= 0;)(r = i[a]) && (o && o !== r.nextSibling && o.parentNode.insertBefore(r, o), o = r); return this } }, function(t, n, e) { "use strict";

    function r(t, n) { return t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN } var i = e(8);
    n.a = function(t) {
        function n(n, e) { return n && e ? t(n.__data__, e.__data__) : !n - !e }
        t || (t = r); for (var e = this._groups, a = e.length, o = new Array(a), u = 0; u < a; ++u) { for (var c, f = e[u], s = f.length, l = o[u] = new Array(s), d = 0; d < s; ++d)(c = f[d]) && (l[d] = c);
            l.sort(n) } return new i.a(o, this._parents).order() } }, function(t, n, e) { "use strict";
    n.a = function() { var t = arguments[0]; return arguments[0] = this, t.apply(null, arguments), this } }, function(t, n, e) { "use strict";
    n.a = function() { var t = new Array(this.size()),
            n = -1; return this.each(function() { t[++n] = this }), t } }, function(t, n, e) { "use strict";
    n.a = function() { for (var t = this._groups, n = 0, e = t.length; n < e; ++n)
            for (var r = t[n], i = 0, a = r.length; i < a; ++i) { var o = r[i]; if (o) return o }
        return null } }, function(t, n, e) { "use strict";
    n.a = function() { var t = 0; return this.each(function() {++t }), t } }, function(t, n, e) { "use strict";
    n.a = function() { return !this.node() } }, function(t, n, e) { "use strict";
    n.a = function(t) { for (var n = this._groups, e = 0, r = n.length; e < r; ++e)
            for (var i, a = n[e], o = 0, u = a.length; o < u; ++o)(i = a[o]) && t.call(i, i.__data__, o, a); return this } }, function(t, n, e) { "use strict";

    function r(t) { return function() { this.removeAttribute(t) } }

    function i(t) { return function() { this.removeAttributeNS(t.space, t.local) } }

    function a(t, n) { return function() { this.setAttribute(t, n) } }

    function o(t, n) { return function() { this.setAttributeNS(t.space, t.local, n) } }

    function u(t, n) { return function() { var e = n.apply(this, arguments);
            null == e ? this.removeAttribute(t) : this.setAttribute(t, e) } }

    function c(t, n) { return function() { var e = n.apply(this, arguments);
            null == e ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, e) } } var f = e(87);
    n.a = function(t, n) { var e = Object(f.a)(t); if (arguments.length < 2) { var s = this.node(); return e.local ? s.getAttributeNS(e.space, e.local) : s.getAttribute(e) } return this.each((null == n ? e.local ? i : r : "function" == typeof n ? e.local ? c : u : e.local ? o : a)(e, n)) } }, function(t, n, e) { "use strict";

    function r(t) { return function() { delete this[t] } }

    function i(t, n) { return function() { this[t] = n } }

    function a(t, n) { return function() { var e = n.apply(this, arguments);
            null == e ? delete this[t] : this[t] = e } }
    n.a = function(t, n) { return arguments.length > 1 ? this.each((null == n ? r : "function" == typeof n ? a : i)(t, n)) : this.node()[t] } }, function(t, n, e) { "use strict";

    function r(t) { return t.trim().split(/^|\s+/) }

    function i(t) { return t.classList || new a(t) }

    function a(t) { this._node = t, this._names = r(t.getAttribute("class") || "") }

    function o(t, n) { for (var e = i(t), r = -1, a = n.length; ++r < a;) e.add(n[r]) }

    function u(t, n) { for (var e = i(t), r = -1, a = n.length; ++r < a;) e.remove(n[r]) }

    function c(t) { return function() { o(this, t) } }

    function f(t) { return function() { u(this, t) } }

    function s(t, n) { return function() {
            (n.apply(this, arguments) ? o : u)(this, t) } }
    a.prototype = { add: function(t) { this._names.indexOf(t) < 0 && (this._names.push(t), this._node.setAttribute("class", this._names.join(" "))) }, remove: function(t) { var n = this._names.indexOf(t);
            n >= 0 && (this._names.splice(n, 1), this._node.setAttribute("class", this._names.join(" "))) }, contains: function(t) { return this._names.indexOf(t) >= 0 } }, n.a = function(t, n) { var e = r(t + ""); if (arguments.length < 2) { for (var a = i(this.node()), o = -1, u = e.length; ++o < u;)
                if (!a.contains(e[o])) return !1;
            return !0 } return this.each(("function" == typeof n ? s : n ? c : f)(e, n)) } }, function(t, n, e) { "use strict";

    function r() { this.textContent = "" }

    function i(t) { return function() { this.textContent = t } }

    function a(t) { return function() { var n = t.apply(this, arguments);
            this.textContent = null == n ? "" : n } }
    n.a = function(t) { return arguments.length ? this.each(null == t ? r : ("function" == typeof t ? a : i)(t)) : this.node().textContent } }, function(t, n, e) { "use strict";

    function r() { this.innerHTML = "" }

    function i(t) { return function() { this.innerHTML = t } }

    function a(t) { return function() { var n = t.apply(this, arguments);
            this.innerHTML = null == n ? "" : n } }
    n.a = function(t) { return arguments.length ? this.each(null == t ? r : ("function" == typeof t ? a : i)(t)) : this.node().innerHTML } }, function(t, n, e) { "use strict";

    function r() { this.nextSibling && this.parentNode.appendChild(this) }
    n.a = function() { return this.each(r) } }, function(t, n, e) { "use strict";

    function r() { this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild) }
    n.a = function() { return this.each(r) } }, function(t, n, e) { "use strict"; var r = e(86);
    n.a = function(t) { var n = "function" == typeof t ? t : Object(r.a)(t); return this.select(function() { return this.appendChild(n.apply(this, arguments)) }) } }, function(t, n, e) { "use strict";

    function r() { return null } var i = e(86),
        a = e(92);
    n.a = function(t, n) { var e = "function" == typeof t ? t : Object(i.a)(t),
            o = null == n ? r : "function" == typeof n ? n : Object(a.a)(n); return this.select(function() { return this.insertBefore(e.apply(this, arguments), o.apply(this, arguments) || null) }) } }, function(t, n, e) { "use strict";

    function r() { var t = this.parentNode;
        t && t.removeChild(this) }
    n.a = function() { return this.each(r) } }, function(t, n, e) { "use strict";
    n.a = function(t) { return arguments.length ? this.property("__data__", t) : this.node().__data__ } }, function(t, n, e) { "use strict";

    function r(t, n, e) { var r = Object(o.a)(t),
            i = r.CustomEvent; "function" == typeof i ? i = new i(n, e) : (i = r.document.createEvent("Event"), e ? (i.initEvent(n, e.bubbles, e.cancelable), i.detail = e.detail) : i.initEvent(n, !1, !1)), t.dispatchEvent(i) }

    function i(t, n) { return function() { return r(this, t, n) } }

    function a(t, n) { return function() { return r(this, t, n.apply(this, arguments)) } } var o = e(93);
    n.a = function(t, n) { return this.each(("function" == typeof n ? a : i)(t, n)) } }, function(t, n, e) { "use strict"; var r = e(8);
    n.a = function(t) { return "string" == typeof t ? new r.a([document.querySelectorAll(t)], [document.documentElement]) : new r.a([null == t ? [] : t], r.c) } }, function(t, n, e) { "use strict"; var r = e(89),
        i = e(91);
    n.a = function(t, n, e) { arguments.length < 3 && (e = n, n = Object(r.a)().changedTouches); for (var a, o = 0, u = n ? n.length : 0; o < u; ++o)
            if ((a = n[o]).identifier === e) return Object(i.a)(t, a);
        return null } }, function(t, n, e) { "use strict"; var r = e(89),
        i = e(91);
    n.a = function(t, n) { null == n && (n = Object(r.a)().touches); for (var e = 0, a = n ? n.length : 0, o = new Array(a); e < a; ++e) o[e] = Object(i.a)(t, n[e]); return o } }, function(t, n, e) { "use strict";

    function r(t) { return t && t.__esModule ? t : { default: t } }

    function i(t, n) { if (!(t instanceof n)) throw new TypeError("Cannot call a class as a function") }
    Object.defineProperty(n, "__esModule", { value: !0 }); var a = function() {
            function t(t, n) { for (var e = 0; e < n.length; e++) { var r = n[e];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } return function(n, e, r) { return e && t(n.prototype, e), r && t(n, r), n } }(),
        o = e(163),
        u = r(o),
        c = e(121),
        f = r(c),
        s = e(96),
        l = r(s),
        d = e(32),
        h = r(d),
        p = e(357),
        b = r(p),
        v = console,
        y = function() {
            function t(n, e) { var r = this;
                i(this, t), e || v.log(2, "no layout data", ""), this.conf = (0, f.default)(n, (0, u.default)(b.default)), this.data = e; var a = (0, l.default)(e, function(t, n) { return n.offset = t.offset, t.blocks[n.id] = { label: n.label, len: n.len, color: n.color, offset: t.offset }, t.offset += n.len, t }, { blocks: {}, offset: 0 });
                this.blocks = a.blocks, this.size = a.offset, (0, h.default)(this.data, function(t, n) { r.blocks[t.id].start = t.offset / r.size * (2 * Math.PI - r.data.length * r.conf.gap) + n * r.conf.gap, r.blocks[t.id].end = (t.offset + t.len) / r.size * (2 * Math.PI - r.data.length * r.conf.gap) + n * r.conf.gap, t.start = t.offset / r.size * (2 * Math.PI - r.data.length * r.conf.gap) + n * r.conf.gap, t.end = (t.offset + t.len) / r.size * (2 * Math.PI - r.data.length * r.conf.gap) + n * r.conf.gap }) } return a(t, [{ key: "getAngle", value: function(t, n) { var e = this.blocks[t].start / this.size; return "deg" === n ? 360 * angle : "rad" === n ? 2 * e * Math.PI : null } }, { key: "summary", value: function() { return (0, l.default)(this.data, function(t, n) { return t[n.id] = n.len, t }, {}) } }]), t }();
    n.default = y }, function(t, n, e) {
    function r(t, n) { return t && i(n, a(n), t) } var i = e(31),
        a = e(59);
    t.exports = r }, function(t, n, e) {
    function r(t, n) { return i(t, a(t), n) } var i = e(31),
        a = e(84);
    t.exports = r }, function(t, n, e) {
    function r(t, n) { return i(t, a(t), n) } var i = e(31),
        a = e(165);
    t.exports = r }, function(t, n, e) {
    function r(t) { return i(t, o, a) } var i = e(146),
        a = e(165),
        o = e(59);
    t.exports = r }, function(t, n) {
    function e(t) { var n = t.length,
            e = t.constructor(n); return n && "string" == typeof t[0] && i.call(t, "index") && (e.index = t.index, e.input = t.input), e } var r = Object.prototype,
        i = r.hasOwnProperty;
    t.exports = e }, function(t, n, e) {
    function r(t, n, e, r) { var P = t.constructor; switch (n) {
            case g:
                return i(t);
            case l:
            case d:
                return new P(+t);
            case m:
                return a(t, r);
            case x:
            case w:
            case j:
            case O:
            case M:
            case k:
            case A:
            case T:
            case R:
                return s(t, r);
            case h:
                return o(t, r, e);
            case p:
            case y:
                return new P(t);
            case b:
                return u(t);
            case v:
                return c(t, r, e);
            case _:
                return f(t) } } var i = e(79),
        a = e(349),
        o = e(350),
        u = e(352),
        c = e(353),
        f = e(355),
        s = e(132),
        l = "[object Boolean]",
        d = "[object Date]",
        h = "[object Map]",
        p = "[object Number]",
        b = "[object RegExp]",
        v = "[object Set]",
        y = "[object String]",
        _ = "[object Symbol]",
        g = "[object ArrayBuffer]",
        m = "[object DataView]",
        x = "[object Float32Array]",
        w = "[object Float64Array]",
        j = "[object Int8Array]",
        O = "[object Int16Array]",
        M = "[object Int32Array]",
        k = "[object Uint8Array]",
        A = "[object Uint8ClampedArray]",
        T = "[object Uint16Array]",
        R = "[object Uint32Array]";
    t.exports = r }, function(t, n, e) {
    function r(t, n) { var e = n ? i(t.buffer) : t.buffer; return new t.constructor(e, t.byteOffset, t.byteLength) } var i = e(79);
    t.exports = r }, function(t, n, e) {
    function r(t, n, e) { var r = n ? e(o(t), u) : o(t); return a(r, i, new t.constructor) } var i = e(351),
        a = e(95),
        o = e(143),
        u = 1;
    t.exports = r }, function(t, n) {
    function e(t, n) { return t.set(n[0], n[1]), t }
    t.exports = e }, function(t, n) {
    function e(t) { var n = new t.constructor(t.source, r.exec(t)); return n.lastIndex = t.lastIndex, n } var r = /\w*$/;
    t.exports = e }, function(t, n, e) {
    function r(t, n, e) { var r = n ? e(o(t), u) : o(t); return a(r, i, new t.constructor) } var i = e(354),
        a = e(95),
        o = e(144),
        u = 1;
    t.exports = r }, function(t, n) {
    function e(t, n) { return t.add(n), t }
    t.exports = e }, function(t, n, e) {
    function r(t) { return o ? Object(o.call(t)) : {} } var i = e(29),
        a = i ? i.prototype : void 0,
        o = a ? a.valueOf : void 0;
    t.exports = r }, function(t, n) {
    function e(t, n, e, r, i) { return i(t, function(t, i, a) { e = r ? (r = !1, t) : n(e, t, i, a) }), e }
    t.exports = e }, function(t, n, e) { "use strict";
    Object.defineProperty(n, "__esModule", { value: !0 }), n.default = { innerRadius: 250, outerRadius: 300, cornerRadius: 0, gap: .04, opacity: 1, labels: { position: "center", display: !0, size: 14, color: "#000", radialOffset: 20 }, ticks: { display: !0, color: "grey", spacing: 1e7, labels: !0, labelSpacing: 10, labelSuffix: "", labelDenominator: 1, labelDisplay0: !0, labelSize: 10, labelColor: "#000", labelFont: "default", majorSpacing: 5, size: { minor: 2, major: 5 } }, onClick: null, onMouseOver: null, events: {}, zIndex: 100 } }, function(t, n, e) { "use strict";

    function r(t) { return t && t.__esModule ? t : { default: t } }

    function i() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
            n = arguments[1],
            e = arguments[2],
            r = 0 === t.length,
            i = e.svg.attr("width", e.conf.width).attr("height", e.conf.height);
        n && (0, o.default)(e.tracks, function(t, n) { i.select("." + n).remove() }); var a = i.select(".all");
        a.empty() && (a = i.append("g").attr("class", "all").attr("transform", "translate(\n          " + parseInt(e.conf.width / 2) + ",\n          " + parseInt(e.conf.height / 2) + "\n        )")), (0, o.default)(e.tracks, function(n, i) {
            (r || i in t) && n.render(e, a, i) }), (r || "layout" in t) && (0, s.default)(a, e); var u = i.selectAll(".all > g").remove(),
            f = (0, c.default)(u._groups[0], function(t) { return t.getAttribute("z-index") }); return i.select(".all").selectAll("g").data(f).enter().append(function(t) { return t }), e }
    Object.defineProperty(n, "__esModule", { value: !0 }), n.default = i; var a = e(32),
        o = r(a),
        u = e(97),
        c = r(u),
        f = e(364),
        s = r(f) }, function(t, n, e) {
    function r(t) { return o(t) || a(t) || !!(u && t && t[u]) } var i = e(29),
        a = e(57),
        o = e(2),
        u = i ? i.isConcatSpreadable : void 0;
    t.exports = r }, function(t, n, e) {
    function r(t, n, e) { var r = -1;
        n = i(n.length ? n : [s], c(a)); var l = o(t, function(t, e, a) { return { criteria: i(n, function(n) { return n(t) }), index: ++r, value: t } }); return u(l, function(t, n) { return f(t, n, e) }) } var i = e(40),
        a = e(33),
        o = e(157),
        u = e(361),
        c = e(136),
        f = e(362),
        s = e(28);
    t.exports = r }, function(t, n) {
    function e(t, n) { var e = t.length; for (t.sort(n); e--;) t[e] = t[e].value; return t }
    t.exports = e }, function(t, n, e) {
    function r(t, n, e) { for (var r = -1, a = t.criteria, o = n.criteria, u = a.length, c = e.length; ++r < u;) { var f = i(a[r], o[r]); if (f) { if (r >= c) return f; return f * ("desc" == e[r] ? -1 : 1) } } return t.index - n.index } var i = e(363);
    t.exports = r }, function(t, n, e) {
    function r(t, n) { if (t !== n) { var e = void 0 !== t,
                r = null === t,
                a = t === t,
                o = i(t),
                u = void 0 !== n,
                c = null === n,
                f = n === n,
                s = i(n); if (!c && !s && !o && t > n || o && u && f && !c && !s || r && u && f || !e && f || !a) return 1; if (!r && !o && !s && t < n || s && e && a && !r && !o || c && e && a || !u && a || !f) return -1 } return 0 } var i = e(34);
    t.exports = r }, function(t, n, e) { "use strict";

    function r(t, n) { var e = t.innerRadius + t.labels.radialOffset,
            r = (0, o.arc)().innerRadius(e).outerRadius(e).startAngle(function(t, n) { return t.start }).endAngle(function(t, n) { return t.end });
        n.append("path").attr("fill", "none").attr("stroke", "none").attr("d", r).attr("id", function(t) { return "arc-label" + t.id }), n.append("text").style("font-size", t.labels.size + "px").attr("text-anchor", "middle").append("textPath").attr("startOffset", "25%").attr("xlink:href", function(t) { return "#arc-label" + t.id }).style("fill", t.labels.color).text(function(t) { return t.label }) }

    function i(t, n, e) {
        function r(n) { var e = (n.end - n.start) / n.len; return (0, u.range)(0, n.len, t.ticks.spacing).map(function(t, r) { return { angle: t * e + n.start, label: i(t, r) } }) }

        function i(n, e) { return !1 === t.ticks.labels ? null : !1 === t.ticks.labelDisplay0 && 0 === e ? null : e % t.ticks.labelSpacing ? null : n / t.ticks.labelDenominator + t.ticks.labelSuffix } var a = n.append("g").selectAll("g").data(e._layout.data).enter().append("g").selectAll("g").data(r).enter().append("g").attr("transform", function(n) { return "rotate(" + (180 * n.angle / Math.PI - 90) + ")translate(" + t.outerRadius + ",0)" });
        a.append("line").attr("x1", 0).attr("y1", 1).attr("x2", function(n, e) { return e % t.ticks.majorSpacing ? t.ticks.size.minor : t.ticks.size.major }).attr("y2", 1).style("stroke", t.ticks.color), a.append("text").attr("x", 8).attr("dy", ".35em").attr("transform", function(t) { return t.angle > Math.PI ? "rotate(180)translate(-16)" : null }).style("text-anchor", function(t) { return t.angle > Math.PI ? "end" : null }).style("font-size", t.ticks.labelSize + "px").style("fill", t.ticks.labelColor).text(function(t) { return t.label }) }

    function a(t, n) { var e = n._layout.conf;
        t.select(".cs-layout").remove(); var a = t.append("g").attr("class", "cs-layout").attr("z-index", e.zIndex).on("click", e.onClick),
            u = a.selectAll("g").data(n._layout.data).enter().append("g").attr("class", function(t) { return t.id }).attr("opacity", e.opacity);
        Object.keys(e.events).forEach(function(t) { u.on(t, function(n, r, i) { e.events[t](n, r, i, c.event) }) }); var f = (0, o.arc)().innerRadius(e.innerRadius).outerRadius(e.outerRadius).cornerRadius(e.cornerRadius).startAngle(function(t) { return t.start }).endAngle(function(t) { return t.end });
        u.append("path").attr("d", f).attr("fill", function(t) { return t.color }).attr("id", function(t) { return t.id }), e.labels.display && r(e, u), e.ticks.display && i(e, a, n) }
    Object.defineProperty(n, "__esModule", { value: !0 }), n.default = a; var o = e(11),
        u = e(7),
        c = e(3) }, function(t, n, e) { "use strict";

    function r(t) { return t.innerRadius }

    function i(t) { return t.outerRadius }

    function a(t) { return t.startAngle }

    function o(t) { return t.endAngle }

    function u(t) { return t && t.padAngle }

    function c(t, n, e, r, i, a, o, u) { var c = e - t,
            f = r - n,
            s = o - i,
            l = u - a,
            d = (s * (n - a) - l * (t - i)) / (l * c - s * f); return [t + d * c, n + d * f] }

    function f(t, n, e, r, i, a, o) { var u = t - e,
            c = n - r,
            f = (o ? a : -a) / Object(d.l)(u * u + c * c),
            s = f * c,
            l = -f * u,
            h = t + s,
            p = n + l,
            b = e + s,
            v = r + l,
            y = (h + b) / 2,
            _ = (p + v) / 2,
            g = b - h,
            m = v - p,
            x = g * g + m * m,
            w = i - a,
            j = h * v - b * p,
            O = (m < 0 ? -1 : 1) * Object(d.l)(Object(d.h)(0, w * w * x - j * j)),
            M = (j * m - g * O) / x,
            k = (-j * g - m * O) / x,
            A = (j * m + g * O) / x,
            T = (-j * g + m * O) / x,
            R = M - y,
            P = k - _,
            S = A - y,
            C = T - _; return R * R + P * P > S * S + C * C && (M = A, k = T), { cx: M, cy: k, x01: -s, y01: -l, x11: M * (i / w - 1), y11: k * (i / w - 1) } } var s = e(35),
        l = e(25),
        d = e(42);
    n.a = function() {
        function t() { var t, r, i = +n.apply(this, arguments),
                a = +e.apply(this, arguments),
                o = b.apply(this, arguments) - d.g,
                u = v.apply(this, arguments) - d.g,
                l = Object(d.a)(u - o),
                g = u > o; if (_ || (_ = t = Object(s.a)()), a < i && (r = a, a = i, i = r), a > d.f)
                if (l > d.m - d.f) _.moveTo(a * Object(d.e)(o), a * Object(d.k)(o)), _.arc(0, 0, a, o, u, !g), i > d.f && (_.moveTo(i * Object(d.e)(u), i * Object(d.k)(u)), _.arc(0, 0, i, u, o, g));
                else { var m, x, w = o,
                        j = u,
                        O = o,
                        M = u,
                        k = l,
                        A = l,
                        T = y.apply(this, arguments) / 2,
                        R = T > d.f && (p ? +p.apply(this, arguments) : Object(d.l)(i * i + a * a)),
                        P = Object(d.i)(Object(d.a)(a - i) / 2, +h.apply(this, arguments)),
                        S = P,
                        C = P; if (R > d.f) { var E = Object(d.c)(R / i * Object(d.k)(T)),
                            N = Object(d.c)(R / a * Object(d.k)(T));
                        (k -= 2 * E) > d.f ? (E *= g ? 1 : -1, O += E, M -= E) : (k = 0, O = M = (o + u) / 2), (A -= 2 * N) > d.f ? (N *= g ? 1 : -1, w += N, j -= N) : (A = 0, w = j = (o + u) / 2) } var I = a * Object(d.e)(w),
                        D = a * Object(d.k)(w),
                        B = i * Object(d.e)(M),
                        z = i * Object(d.k)(M); if (P > d.f) { var L = a * Object(d.e)(j),
                            F = a * Object(d.k)(j),
                            U = i * Object(d.e)(O),
                            W = i * Object(d.k)(O); if (l < d.j) { var Y = k > d.f ? c(I, D, U, W, L, F, B, z) : [B, z],
                                q = I - Y[0],
                                G = D - Y[1],
                                V = L - Y[0],
                                H = F - Y[1],
                                X = 1 / Object(d.k)(Object(d.b)((q * V + G * H) / (Object(d.l)(q * q + G * G) * Object(d.l)(V * V + H * H))) / 2),
                                $ = Object(d.l)(Y[0] * Y[0] + Y[1] * Y[1]);
                            S = Object(d.i)(P, (i - $) / (X - 1)), C = Object(d.i)(P, (a - $) / (X + 1)) } }
                    A > d.f ? C > d.f ? (m = f(U, W, I, D, a, C, g), x = f(L, F, B, z, a, C, g), _.moveTo(m.cx + m.x01, m.cy + m.y01), C < P ? _.arc(m.cx, m.cy, C, Object(d.d)(m.y01, m.x01), Object(d.d)(x.y01, x.x01), !g) : (_.arc(m.cx, m.cy, C, Object(d.d)(m.y01, m.x01), Object(d.d)(m.y11, m.x11), !g), _.arc(0, 0, a, Object(d.d)(m.cy + m.y11, m.cx + m.x11), Object(d.d)(x.cy + x.y11, x.cx + x.x11), !g), _.arc(x.cx, x.cy, C, Object(d.d)(x.y11, x.x11), Object(d.d)(x.y01, x.x01), !g))) : (_.moveTo(I, D), _.arc(0, 0, a, w, j, !g)) : _.moveTo(I, D), i > d.f && k > d.f ? S > d.f ? (m = f(B, z, L, F, i, -S, g), x = f(I, D, U, W, i, -S, g), _.lineTo(m.cx + m.x01, m.cy + m.y01), S < P ? _.arc(m.cx, m.cy, S, Object(d.d)(m.y01, m.x01), Object(d.d)(x.y01, x.x01), !g) : (_.arc(m.cx, m.cy, S, Object(d.d)(m.y01, m.x01), Object(d.d)(m.y11, m.x11), !g), _.arc(0, 0, i, Object(d.d)(m.cy + m.y11, m.cx + m.x11), Object(d.d)(x.cy + x.y11, x.cx + x.x11), g), _.arc(x.cx, x.cy, S, Object(d.d)(x.y11, x.x11), Object(d.d)(x.y01, x.x01), !g))) : _.arc(0, 0, i, M, O, g) : _.lineTo(B, z) }
            else _.moveTo(0, 0); if (_.closePath(), t) return _ = null, t + "" || null } var n = r,
            e = i,
            h = Object(l.a)(0),
            p = null,
            b = a,
            v = o,
            y = u,
            _ = null; return t.centroid = function() { var t = (+n.apply(this, arguments) + +e.apply(this, arguments)) / 2,
                r = (+b.apply(this, arguments) + +v.apply(this, arguments)) / 2 - d.j / 2; return [Object(d.e)(r) * t, Object(d.k)(r) * t] }, t.innerRadius = function(e) { return arguments.length ? (n = "function" == typeof e ? e : Object(l.a)(+e), t) : n }, t.outerRadius = function(n) { return arguments.length ? (e = "function" == typeof n ? n : Object(l.a)(+n), t) : e }, t.cornerRadius = function(n) { return arguments.length ? (h = "function" == typeof n ? n : Object(l.a)(+n), t) : h }, t.padRadius = function(n) { return arguments.length ? (p = null == n ? null : "function" == typeof n ? n : Object(l.a)(+n), t) : p }, t.startAngle = function(n) { return arguments.length ? (b = "function" == typeof n ? n : Object(l.a)(+n), t) : b }, t.endAngle = function(n) { return arguments.length ? (v = "function" == typeof n ? n : Object(l.a)(+n), t) : v }, t.padAngle = function(n) { return arguments.length ? (y = "function" == typeof n ? n : Object(l.a)(+n), t) : y }, t.context = function(n) { return arguments.length ? (_ = null == n ? null : n, t) : _ }, t } }, function(t, n, e) { "use strict";

    function r() { this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "" }

    function i() { return new r } var a = Math.PI,
        o = 2 * a,
        u = o - 1e-6;
    r.prototype = i.prototype = { constructor: r, moveTo: function(t, n) { this._ += "M" + (this._x0 = this._x1 = +t) + "," + (this._y0 = this._y1 = +n) }, closePath: function() { null !== this._x1 && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z") }, lineTo: function(t, n) { this._ += "L" + (this._x1 = +t) + "," + (this._y1 = +n) }, quadraticCurveTo: function(t, n, e, r) { this._ += "Q" + +t + "," + +n + "," + (this._x1 = +e) + "," + (this._y1 = +r) }, bezierCurveTo: function(t, n, e, r, i, a) { this._ += "C" + +t + "," + +n + "," + +e + "," + +r + "," + (this._x1 = +i) + "," + (this._y1 = +a) }, arcTo: function(t, n, e, r, i) { t = +t, n = +n, e = +e, r = +r, i = +i; var o = this._x1,
                u = this._y1,
                c = e - t,
                f = r - n,
                s = o - t,
                l = u - n,
                d = s * s + l * l; if (i < 0) throw new Error("negative radius: " + i); if (null === this._x1) this._ += "M" + (this._x1 = t) + "," + (this._y1 = n);
            else if (d > 1e-6)
                if (Math.abs(l * c - f * s) > 1e-6 && i) { var h = e - o,
                        p = r - u,
                        b = c * c + f * f,
                        v = h * h + p * p,
                        y = Math.sqrt(b),
                        _ = Math.sqrt(d),
                        g = i * Math.tan((a - Math.acos((b + d - v) / (2 * y * _))) / 2),
                        m = g / _,
                        x = g / y;
                    Math.abs(m - 1) > 1e-6 && (this._ += "L" + (t + m * s) + "," + (n + m * l)), this._ += "A" + i + "," + i + ",0,0," + +(l * h > s * p) + "," + (this._x1 = t + x * c) + "," + (this._y1 = n + x * f) } else this._ += "L" + (this._x1 = t) + "," + (this._y1 = n);
            else; }, arc: function(t, n, e, r, i, c) { t = +t, n = +n, e = +e; var f = e * Math.cos(r),
                s = e * Math.sin(r),
                l = t + f,
                d = n + s,
                h = 1 ^ c,
                p = c ? r - i : i - r; if (e < 0) throw new Error("negative radius: " + e);
            null === this._x1 ? this._ += "M" + l + "," + d : (Math.abs(this._x1 - l) > 1e-6 || Math.abs(this._y1 - d) > 1e-6) && (this._ += "L" + l + "," + d), e && (p < 0 && (p = p % o + o), p > u ? this._ += "A" + e + "," + e + ",0,1," + h + "," + (t - f) + "," + (n - s) + "A" + e + "," + e + ",0,1," + h + "," + (this._x1 = l) + "," + (this._y1 = d) : p > 1e-6 && (this._ += "A" + e + "," + e + ",0," + +(p >= a) + "," + h + "," + (this._x1 = t + e * Math.cos(i)) + "," + (this._y1 = n + e * Math.sin(i)))) }, rect: function(t, n, e, r) { this._ += "M" + (this._x0 = this._x1 = +t) + "," + (this._y0 = this._y1 = +n) + "h" + +e + "v" + +r + "h" + -e + "Z" }, toString: function() { return this._ } }, n.a = i }, function(t, n, e) { "use strict"; var r = e(25),
        i = e(368),
        a = e(369),
        o = e(42);
    n.a = function() {
        function t(t) { var r, i, a, l, d, h = t.length,
                p = 0,
                b = new Array(h),
                v = new Array(h),
                y = +c.apply(this, arguments),
                _ = Math.min(o.m, Math.max(-o.m, f.apply(this, arguments) - y)),
                g = Math.min(Math.abs(_) / h, s.apply(this, arguments)),
                m = g * (_ < 0 ? -1 : 1); for (r = 0; r < h; ++r)(d = v[b[r] = r] = +n(t[r], r, t)) > 0 && (p += d); for (null != e ? b.sort(function(t, n) { return e(v[t], v[n]) }) : null != u && b.sort(function(n, e) { return u(t[n], t[e]) }), r = 0, a = p ? (_ - h * m) / p : 0; r < h; ++r, y = l) i = b[r], d = v[i], l = y + (d > 0 ? d * a : 0) + m, v[i] = { data: t[i], index: r, value: d, startAngle: y, endAngle: l, padAngle: g }; return v } var n = a.a,
            e = i.a,
            u = null,
            c = Object(r.a)(0),
            f = Object(r.a)(o.m),
            s = Object(r.a)(0); return t.value = function(e) { return arguments.length ? (n = "function" == typeof e ? e : Object(r.a)(+e), t) : n }, t.sortValues = function(n) { return arguments.length ? (e = n, u = null, t) : e }, t.sort = function(n) { return arguments.length ? (u = n, e = null, t) : u }, t.startAngle = function(n) { return arguments.length ? (c = "function" == typeof n ? n : Object(r.a)(+n), t) : c }, t.endAngle = function(n) { return arguments.length ? (f = "function" == typeof n ? n : Object(r.a)(+n), t) : f }, t.padAngle = function(n) { return arguments.length ? (s = "function" == typeof n ? n : Object(r.a)(+n), t) : s }, t } }, function(t, n, e) { "use strict";
    n.a = function(t, n) { return n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN } }, function(t, n, e) { "use strict";
    n.a = function(t) { return t } }, function(t, n, e) { "use strict"; var r = e(167),
        i = e(166),
        a = e(168);
    n.a = function() { var t = Object(i.a)().curve(r.a),
            n = t.curve,
            e = t.lineX0,
            o = t.lineX1,
            u = t.lineY0,
            c = t.lineY1; return t.angle = t.x, delete t.x, t.startAngle = t.x0, delete t.x0, t.endAngle = t.x1, delete t.x1, t.radius = t.y, delete t.y, t.innerRadius = t.y0, delete t.y0, t.outerRadius = t.y1, delete t.y1, t.lineStartAngle = function() { return Object(a.b)(e()) }, delete t.lineX0, t.lineEndAngle = function() { return Object(a.b)(o()) }, delete t.lineX1, t.lineInnerRadius = function() { return Object(a.b)(u()) }, delete t.lineY0, t.lineOuterRadius = function() { return Object(a.b)(c()) }, delete t.lineY1, t.curve = function(t) { return arguments.length ? n(Object(r.b)(t)) : n()._curve }, t } }, function(t, n, e) { "use strict";

    function r(t) { return t.source }

    function i(t) { return t.target }

    function a(t) {
        function n() { var n, r = h.a.call(arguments),
                i = e.apply(this, r),
                f = a.apply(this, r); if (c || (c = n = Object(d.a)()), t(c, +o.apply(this, (r[0] = i, r)), +u.apply(this, r), +o.apply(this, (r[0] = f, r)), +u.apply(this, r)), n) return c = null, n + "" || null } var e = r,
            a = i,
            o = b.a,
            u = b.b,
            c = null; return n.source = function(t) { return arguments.length ? (e = t, n) : e }, n.target = function(t) { return arguments.length ? (a = t, n) : a }, n.x = function(t) { return arguments.length ? (o = "function" == typeof t ? t : Object(p.a)(+t), n) : o }, n.y = function(t) { return arguments.length ? (u = "function" == typeof t ? t : Object(p.a)(+t), n) : u }, n.context = function(t) { return arguments.length ? (c = null == t ? null : t, n) : c }, n }

    function o(t, n, e, r, i) { t.moveTo(n, e), t.bezierCurveTo(n = (n + r) / 2, e, n, i, r, i) }

    function u(t, n, e, r, i) { t.moveTo(n, e), t.bezierCurveTo(n, e = (e + i) / 2, r, e, r, i) }

    function c(t, n, e, r, i) { var a = Object(v.a)(n, e),
            o = Object(v.a)(n, e = (e + i) / 2),
            u = Object(v.a)(r, e),
            c = Object(v.a)(r, i);
        t.moveTo(a[0], a[1]), t.bezierCurveTo(o[0], o[1], u[0], u[1], c[0], c[1]) }

    function f() { return a(o) }

    function s() { return a(u) }

    function l() { var t = a(c); return t.angle = t.x, delete t.x, t.radius = t.y, delete t.y, t }
    n.a = f, n.c = s, n.b = l; var d = e(35),
        h = e(170),
        p = e(25),
        b = e(100),
        v = e(169) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return d }); var r = e(35),
        i = e(171),
        a = e(172),
        o = e(173),
        u = e(174),
        c = e(175),
        f = e(176),
        s = e(177),
        l = e(25),
        d = [i.a, a.a, o.a, c.a, u.a, f.a, s.a];
    n.a = function() {
        function t() { var t; if (a || (a = t = Object(r.a)()), n.apply(this, arguments).draw(a, +e.apply(this, arguments)), t) return a = null, t + "" || null } var n = Object(l.a)(i.a),
            e = Object(l.a)(64),
            a = null; return t.type = function(e) { return arguments.length ? (n = "function" == typeof e ? e : Object(l.a)(e), t) : n }, t.size = function(n) { return arguments.length ? (e = "function" == typeof n ? n : Object(l.a)(+n), t) : e }, t.context = function(n) { return arguments.length ? (a = null == n ? null : n, t) : a }, t } }, function(t, n, e) { "use strict";

    function r(t) { this._context = t } var i = e(65),
        a = e(66);
    r.prototype = { areaStart: i.a, areaEnd: i.a, lineStart: function() { this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0 }, lineEnd: function() { switch (this._point) {
                case 1:
                    this._context.moveTo(this._x2, this._y2), this._context.closePath(); break;
                case 2:
                    this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath(); break;
                case 3:
                    this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4) } }, point: function(t, n) { switch (t = +t, n = +n, this._point) {
                case 0:
                    this._point = 1, this._x2 = t, this._y2 = n; break;
                case 1:
                    this._point = 2, this._x3 = t, this._y3 = n; break;
                case 2:
                    this._point = 3, this._x4 = t, this._y4 = n, this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + n) / 6); break;
                default:
                    Object(a.c)(this, t, n) }
            this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n } }, n.a = function(t) { return new r(t) } }, function(t, n, e) { "use strict";

    function r(t) { this._context = t } var i = e(66);
    r.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0 }, lineEnd: function() {
            (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function(t, n) { switch (t = +t, n = +n, this._point) {
                case 0:
                    this._point = 1; break;
                case 1:
                    this._point = 2; break;
                case 2:
                    this._point = 3; var e = (this._x0 + 4 * this._x1 + t) / 6,
                        r = (this._y0 + 4 * this._y1 + n) / 6;
                    this._line ? this._context.lineTo(e, r) : this._context.moveTo(e, r); break;
                case 3:
                    this._point = 4;
                default:
                    Object(i.c)(this, t, n) }
            this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n } }, n.a = function(t) { return new r(t) } }, function(t, n, e) { "use strict";

    function r(t, n) { this._basis = new i.a(t), this._beta = n } var i = e(66);
    r.prototype = { lineStart: function() { this._x = [], this._y = [], this._basis.lineStart() }, lineEnd: function() { var t = this._x,
                n = this._y,
                e = t.length - 1; if (e > 0)
                for (var r, i = t[0], a = n[0], o = t[e] - i, u = n[e] - a, c = -1; ++c <= e;) r = c / e, this._basis.point(this._beta * t[c] + (1 - this._beta) * (i + r * o), this._beta * n[c] + (1 - this._beta) * (a + r * u));
            this._x = this._y = null, this._basis.lineEnd() }, point: function(t, n) { this._x.push(+t), this._y.push(+n) } }, n.a = function t(n) {
        function e(t) { return 1 === n ? new i.a(t) : new r(t, n) } return e.beta = function(n) { return t(+n) }, e }(.85) }, function(t, n, e) { "use strict";

    function r(t, n) { this._context = t, this._alpha = n } var i = e(178),
        a = e(65),
        o = e(101);
    r.prototype = { areaStart: a.a, areaEnd: a.a, lineStart: function() { this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0 }, lineEnd: function() { switch (this._point) {
                case 1:
                    this._context.moveTo(this._x3, this._y3), this._context.closePath(); break;
                case 2:
                    this._context.lineTo(this._x3, this._y3), this._context.closePath(); break;
                case 3:
                    this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5) } }, point: function(t, n) { if (t = +t, n = +n, this._point) { var e = this._x2 - t,
                    r = this._y2 - n;
                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + r * r, this._alpha)) } switch (this._point) {
                case 0:
                    this._point = 1, this._x3 = t, this._y3 = n; break;
                case 1:
                    this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = n); break;
                case 2:
                    this._point = 3, this._x5 = t, this._y5 = n; break;
                default:
                    Object(o.b)(this, t, n) }
            this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }, n.a = function t(n) {
        function e(t) { return n ? new r(t, n) : new i.a(t, 0) } return e.alpha = function(n) { return t(+n) }, e }(.5) }, function(t, n, e) { "use strict";

    function r(t, n) { this._context = t, this._alpha = n } var i = e(179),
        a = e(101);
    r.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0 }, lineEnd: function() {
            (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function(t, n) { if (t = +t, n = +n, this._point) { var e = this._x2 - t,
                    r = this._y2 - n;
                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + r * r, this._alpha)) } switch (this._point) {
                case 0:
                    this._point = 1; break;
                case 1:
                    this._point = 2; break;
                case 2:
                    this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
                case 3:
                    this._point = 4;
                default:
                    Object(a.b)(this, t, n) }
            this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }, n.a = function t(n) {
        function e(t) { return n ? new r(t, n) : new i.a(t, 0) } return e.alpha = function(n) { return t(+n) }, e }(.5) }, function(t, n, e) { "use strict";

    function r(t) { this._context = t } var i = e(65);
    r.prototype = { areaStart: i.a, areaEnd: i.a, lineStart: function() { this._point = 0 }, lineEnd: function() { this._point && this._context.closePath() }, point: function(t, n) { t = +t, n = +n, this._point ? this._context.lineTo(t, n) : (this._point = 1, this._context.moveTo(t, n)) } }, n.a = function(t) { return new r(t) } }, function(t, n, e) { "use strict";

    function r(t) { return t < 0 ? -1 : 1 }

    function i(t, n, e) { var i = t._x1 - t._x0,
            a = n - t._x1,
            o = (t._y1 - t._y0) / (i || a < 0 && -0),
            u = (e - t._y1) / (a || i < 0 && -0),
            c = (o * a + u * i) / (i + a); return (r(o) + r(u)) * Math.min(Math.abs(o), Math.abs(u), .5 * Math.abs(c)) || 0 }

    function a(t, n) { var e = t._x1 - t._x0; return e ? (3 * (t._y1 - t._y0) / e - n) / 2 : n }

    function o(t, n, e) { var r = t._x0,
            i = t._y0,
            a = t._x1,
            o = t._y1,
            u = (a - r) / 3;
        t._context.bezierCurveTo(r + u, i + u * n, a - u, o - u * e, a, o) }

    function u(t) { this._context = t }

    function c(t) { this._context = new f(t) }

    function f(t) { this._context = t }

    function s(t) { return new u(t) }

    function l(t) { return new c(t) }
    n.a = s, n.b = l, u.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0 }, lineEnd: function() { switch (this._point) {
                case 2:
                    this._context.lineTo(this._x1, this._y1); break;
                case 3:
                    o(this, this._t0, a(this, this._t0)) }(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function(t, n) { var e = NaN; if (t = +t, n = +n, t !== this._x1 || n !== this._y1) { switch (this._point) {
                    case 0:
                        this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break;
                    case 1:
                        this._point = 2; break;
                    case 2:
                        this._point = 3, o(this, a(this, e = i(this, t, n)), e); break;
                    default:
                        o(this, this._t0, e = i(this, t, n)) }
                this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n, this._t0 = e } } }, (c.prototype = Object.create(u.prototype)).point = function(t, n) { u.prototype.point.call(this, n, t) }, f.prototype = { moveTo: function(t, n) { this._context.moveTo(n, t) }, closePath: function() { this._context.closePath() }, lineTo: function(t, n) { this._context.lineTo(n, t) }, bezierCurveTo: function(t, n, e, r, i, a) { this._context.bezierCurveTo(n, t, r, e, a, i) } } }, function(t, n, e) { "use strict";

    function r(t) { this._context = t }

    function i(t) { var n, e, r = t.length - 1,
            i = new Array(r),
            a = new Array(r),
            o = new Array(r); for (i[0] = 0, a[0] = 2, o[0] = t[0] + 2 * t[1], n = 1; n < r - 1; ++n) i[n] = 1, a[n] = 4, o[n] = 4 * t[n] + 2 * t[n + 1]; for (i[r - 1] = 2, a[r - 1] = 7, o[r - 1] = 8 * t[r - 1] + t[r], n = 1; n < r; ++n) e = i[n] / a[n - 1], a[n] -= e, o[n] -= e * o[n - 1]; for (i[r - 1] = o[r - 1] / a[r - 1], n = r - 2; n >= 0; --n) i[n] = (o[n] - i[n + 1]) / a[n]; for (a[r - 1] = (t[r] + i[r - 1]) / 2, n = 0; n < r - 1; ++n) a[n] = 2 * t[n + 1] - i[n + 1]; return [i, a] }
    r.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x = [], this._y = [] }, lineEnd: function() { var t = this._x,
                n = this._y,
                e = t.length; if (e)
                if (this._line ? this._context.lineTo(t[0], n[0]) : this._context.moveTo(t[0], n[0]), 2 === e) this._context.lineTo(t[1], n[1]);
                else
                    for (var r = i(t), a = i(n), o = 0, u = 1; u < e; ++o, ++u) this._context.bezierCurveTo(r[0][o], a[0][o], r[1][o], a[1][o], t[u], n[u]);
                (this._line || 0 !== this._line && 1 === e) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null }, point: function(t, n) { this._x.push(+t), this._y.push(+n) } }, n.a = function(t) { return new r(t) } }, function(t, n, e) { "use strict";

    function r(t, n) { this._context = t, this._t = n }

    function i(t) { return new r(t, 0) }

    function a(t) { return new r(t, 1) }
    n.c = i, n.b = a, r.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x = this._y = NaN, this._point = 0 }, lineEnd: function() { 0 < this._t && this._t < 1 && 2 === this._point && this._context.lineTo(this._x, this._y), (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line) }, point: function(t, n) { switch (t = +t, n = +n, this._point) {
                case 0:
                    this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break;
                case 1:
                    this._point = 2;
                default:
                    if (this._t <= 0) this._context.lineTo(this._x, n), this._context.lineTo(t, n);
                    else { var e = this._x * (1 - this._t) + t * this._t;
                        this._context.lineTo(e, this._y), this._context.lineTo(e, n) } }
            this._x = t, this._y = n } }, n.a = function(t) { return new r(t, .5) } }, function(t, n, e) { "use strict";

    function r(t, n) { return t[n] } var i = e(170),
        a = e(25),
        o = e(43),
        u = e(44);
    n.a = function() {
        function t(t) { var r, i, a = n.apply(this, arguments),
                o = t.length,
                u = a.length,
                s = new Array(u); for (r = 0; r < u; ++r) { for (var l, d = a[r], h = s[r] = new Array(o), p = 0; p < o; ++p) h[p] = l = [0, +f(t[p], d, p, t)], l.data = t[p];
                h.key = d } for (r = 0, i = e(s); r < u; ++r) s[i[r]].index = r; return c(s, i), s } var n = Object(a.a)([]),
            e = u.a,
            c = o.a,
            f = r; return t.keys = function(e) { return arguments.length ? (n = "function" == typeof e ? e : Object(a.a)(i.a.call(e)), t) : n }, t.value = function(n) { return arguments.length ? (f = "function" == typeof n ? n : Object(a.a)(+n), t) : f }, t.order = function(n) { return arguments.length ? (e = null == n ? u.a : "function" == typeof n ? n : Object(a.a)(i.a.call(n)), t) : e }, t.offset = function(n) { return arguments.length ? (c = null == n ? o.a : n, t) : c }, t } }, function(t, n, e) { "use strict"; var r = e(43);
    n.a = function(t, n) { if ((i = t.length) > 0) { for (var e, i, a, o = 0, u = t[0].length; o < u; ++o) { for (a = e = 0; e < i; ++e) a += t[e][o][1] || 0; if (a)
                    for (e = 0; e < i; ++e) t[e][o][1] /= a }
            Object(r.a)(t, n) } } }, function(t, n, e) { "use strict";
    n.a = function(t, n) { if ((u = t.length) > 1)
            for (var e, r, i, a, o, u, c = 0, f = t[n[0]].length; c < f; ++c)
                for (a = o = 0, e = 0; e < u; ++e)(i = (r = t[n[e]][c])[1] - r[0]) >= 0 ? (r[0] = a, r[1] = a += i) : i < 0 ? (r[1] = o, r[0] = o += i) : r[0] = a } }, function(t, n, e) { "use strict"; var r = e(43);
    n.a = function(t, n) { if ((e = t.length) > 0) { for (var e, i = 0, a = t[n[0]], o = a.length; i < o; ++i) { for (var u = 0, c = 0; u < e; ++u) c += t[u][i][1] || 0;
                a[i][1] += a[i][0] = -c / 2 }
            Object(r.a)(t, n) } } }, function(t, n, e) { "use strict"; var r = e(43);
    n.a = function(t, n) { if ((a = t.length) > 0 && (i = (e = t[n[0]]).length) > 0) { for (var e, i, a, o = 0, u = 1; u < i; ++u) { for (var c = 0, f = 0, s = 0; c < a; ++c) { for (var l = t[n[c]], d = l[u][1] || 0, h = l[u - 1][1] || 0, p = (d - h) / 2, b = 0; b < c; ++b) { var v = t[n[b]];
                        p += (v[u][1] || 0) - (v[u - 1][1] || 0) }
                    f += d, s += p * d }
                e[u - 1][1] += e[u - 1][0] = o, f && (o -= s / f) }
            e[u - 1][1] += e[u - 1][0] = o, Object(r.a)(t, n) } } }, function(t, n, e) { "use strict"; var r = e(102);
    n.a = function(t) { return Object(r.a)(t).reverse() } }, function(t, n, e) { "use strict"; var r = e(44),
        i = e(102);
    n.a = function(t) { var n, e, a = t.length,
            o = t.map(i.b),
            u = Object(r.a)(t).sort(function(t, n) { return o[n] - o[t] }),
            c = 0,
            f = 0,
            s = [],
            l = []; for (n = 0; n < a; ++n) e = u[n], c < f ? (c += o[e], s.push(e)) : (f += o[e], l.push(e)); return l.reverse().concat(s) } }, function(t, n, e) { "use strict"; var r = e(44);
    n.a = function(t) { return Object(r.a)(t).reverse() } }, function(t, n, e) { "use strict"; var r = e(182);
    n.a = function(t, n, e) { var i, a, o, u, c = t.length,
            f = n.length,
            s = new Array(c * f); for (null == e && (e = r.b), i = o = 0; i < c; ++i)
            for (u = t[i], a = 0; a < f; ++a, ++o) s[o] = e(u, n[a]); return s } }, function(t, n, e) { "use strict";
    n.a = function(t, n) { return n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN } }, function(t, n, e) { "use strict"; var r = e(186),
        i = e(180),
        a = e(393),
        o = e(185),
        u = e(394),
        c = e(187),
        f = e(188),
        s = e(189);
    n.a = function() {
        function t(t) { var r, a, o = t.length,
                u = new Array(o); for (r = 0; r < o; ++r) u[r] = n(t[r], r, t); var s = e(u),
                d = s[0],
                h = s[1],
                p = l(u, d, h);
            Array.isArray(p) || (p = Object(f.c)(d, h, p), p = Object(c.a)(Math.ceil(d / p) * p, Math.floor(h / p) * p, p)); for (var b = p.length; p[0] <= d;) p.shift(), --b; for (; p[b - 1] > h;) p.pop(), --b; var v, y = new Array(b + 1); for (r = 0; r <= b; ++r) v = y[r] = [], v.x0 = r > 0 ? p[r - 1] : d, v.x1 = r < b ? p[r] : h; for (r = 0; r < o; ++r) a = u[r], d <= a && a <= h && y[Object(i.c)(p, a, 0, b)].push(t[r]); return y } var n = u.a,
            e = o.a,
            l = s.a; return t.value = function(e) { return arguments.length ? (n = "function" == typeof e ? e : Object(a.a)(e), t) : n }, t.domain = function(n) { return arguments.length ? (e = "function" == typeof n ? n : Object(a.a)([n[0], n[1]]), t) : e }, t.thresholds = function(n) { return arguments.length ? (l = "function" == typeof n ? n : Array.isArray(n) ? Object(a.a)(r.b.call(n)) : Object(a.a)(n), t) : l }, t } }, function(t, n, e) { "use strict";
    n.a = function(t) { return function() { return t } } }, function(t, n, e) { "use strict";
    n.a = function(t) { return t } }, function(t, n, e) { "use strict"; var r = e(186),
        i = e(36),
        a = e(45),
        o = e(103);
    n.a = function(t, n, e) { return t = r.a.call(t, a.a).sort(i.a), Math.ceil((e - n) / (2 * (Object(o.a)(t, .75) - Object(o.a)(t, .25)) * Math.pow(t.length, -1 / 3))) } }, function(t, n, e) { "use strict"; var r = e(183);
    n.a = function(t, n, e) { return Math.ceil((e - n) / (3.5 * Object(r.a)(t) * Math.pow(t.length, -1 / 3))) } }, function(t, n, e) { "use strict";
    n.a = function(t, n) { var e, r, i = t.length,
            a = -1; if (null == n) { for (; ++a < i;)
                if (null != (e = t[a]) && e >= e)
                    for (r = e; ++a < i;) null != (e = t[a]) && e > r && (r = e) } else
            for (; ++a < i;)
                if (null != (e = n(t[a], a, t)) && e >= e)
                    for (r = e; ++a < i;) null != (e = n(t[a], a, t)) && e > r && (r = e); return r } }, function(t, n, e) { "use strict"; var r = e(45);
    n.a = function(t, n) { var e, i = t.length,
            a = i,
            o = -1,
            u = 0; if (null == n)
            for (; ++o < i;) isNaN(e = Object(r.a)(t[o])) ? --a : u += e;
        else
            for (; ++o < i;) isNaN(e = Object(r.a)(n(t[o], o, t))) ? --a : u += e; if (a) return u / a } }, function(t, n, e) { "use strict"; var r = e(36),
        i = e(45),
        a = e(103);
    n.a = function(t, n) { var e, o = t.length,
            u = -1,
            c = []; if (null == n)
            for (; ++u < o;) isNaN(e = Object(i.a)(t[u])) || c.push(e);
        else
            for (; ++u < o;) isNaN(e = Object(i.a)(n(t[u], u, t))) || c.push(e); return Object(a.a)(c.sort(r.a), .5) } }, function(t, n, e) { "use strict";
    n.a = function(t) { for (var n, e, r, i = t.length, a = -1, o = 0; ++a < i;) o += t[a].length; for (e = new Array(o); --i >= 0;)
            for (r = t[i], n = r.length; --n >= 0;) e[--o] = r[n]; return e } }, function(t, n, e) { "use strict";
    n.a = function(t, n) { for (var e = n.length, r = new Array(e); e--;) r[e] = t[n[e]]; return r } }, function(t, n, e) { "use strict"; var r = e(36);
    n.a = function(t, n) { if (e = t.length) { var e, i, a = 0,
                o = 0,
                u = t[o]; for (null == n && (n = r.a); ++a < e;)(n(i = t[a], u) < 0 || 0 !== n(u, u)) && (u = i, o = a); return 0 === n(u, u) ? o : void 0 } } }, function(t, n, e) { "use strict";
    n.a = function(t, n, e) { for (var r, i, a = (null == e ? t.length : e) - (n = null == n ? 0 : +n); a;) i = Math.random() * a-- | 0, r = t[a + n], t[a + n] = t[i + n], t[i + n] = r; return t } }, function(t, n, e) { "use strict";
    n.a = function(t, n) { var e, r = t.length,
            i = -1,
            a = 0; if (null == n)
            for (; ++i < r;)(e = +t[i]) && (a += e);
        else
            for (; ++i < r;)(e = +n(t[i], i, t)) && (a += e); return a } }, function(t, n, e) { "use strict"; var r = e(191);
    n.a = function() { return Object(r.a)(arguments) } }, function(t, n, e) { "use strict";

    function r(t) { return t && t.__esModule ? t : { default: t } }

    function i(t, n) { if (!(t instanceof n)) throw new TypeError("Cannot call a class as a function") }

    function a(t, n) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !n || "object" != typeof n && "function" != typeof n ? t : n }

    function o(t, n) { if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function, not " + typeof n);
        t.prototype = Object.create(n && n.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : t.__proto__ = n) }
    Object.defineProperty(n, "__esModule", { value: !0 }); var u = function() {
            function t(t, n) { for (var e = 0; e < n.length; e++) { var r = n[e];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } return function(n, e, r) { return e && t(n.prototype, e), r && t(n, r), n } }(),
        c = e(18),
        f = r(c),
        s = e(20),
        l = e(32),
        d = r(l),
        h = e(14),
        p = r(h),
        b = e(21),
        v = (0, p.default)({ style: { value: {}, iteratee: !0 }, color: { value: "black", iteratee: !0 }, backgrounds: { value: [], iteratee: !1 } }, b.common, b.radial),
        y = function(t) {
            function n(t, e, r) { return i(this, n), a(this, (n.__proto__ || Object.getPrototypeOf(n)).call(this, t, e, v, r, s.parsePositionTextData)) } return o(n, t), u(n, [{ key: "renderDatum", value: function(t, n, e) { var r = this,
                        i = t.selectAll("g").data(function(t) { return t.values.map(function(t) { return t._angle = 360 * r.theta(t.position, e.blocks[t.block_id]) / (2 * Math.PI) - 90, t._anchor = t._angle > 90 ? "end" : "start", t._rotate = t._angle > 90 ? 180 : 0, t }) }).enter().append("g").append("text").text(function(t) { return t.value }).attr("transform", function(t) { return "\n          rotate(" + t._angle + ")\n          translate(" + n.innerRadius + ", 0)\n          rotate(" + t._rotate + ")\n        " }).attr("text-anchor", function(t) { return t._anchor }); return (0, d.default)(n.style, function(t, n) { i.style(n, t) }), i } }]), n }(f.default);
    n.default = y }, function(t, n, e) { "use strict";
    Object.defineProperty(n, "__esModule", { value: !0 }); var r = (e(408), e(19));
    e.d(n, "transition", function() { return r.b }); var i = e(453);
    e.d(n, "active", function() { return i.a }); var a = e(193);
    e.d(n, "interrupt", function() { return a.a }) }, function(t, n, e) { "use strict"; var r = e(3),
        i = e(409),
        a = e(413);
    r.selection.prototype.interrupt = i.a, r.selection.prototype.transition = a.a }, function(t, n, e) { "use strict"; var r = e(193);
    n.a = function(t) { return this.each(function() { Object(r.a)(this, t) }) } }, function(t, n, e) { "use strict";

    function r() { for (var t, n = 0, e = arguments.length, r = {}; n < e; ++n) { if (!(t = arguments[n] + "") || t in r) throw new Error("illegal type: " + t);
            r[t] = [] } return new i(r) }

    function i(t) { this._ = t }

    function a(t, n) { return t.trim().split(/^|\s+/).map(function(t) { var e = "",
                r = t.indexOf("."); if (r >= 0 && (e = t.slice(r + 1), t = t.slice(0, r)), t && !n.hasOwnProperty(t)) throw new Error("unknown type: " + t); return { type: t, name: e } }) }

    function o(t, n) { for (var e, r = 0, i = t.length; r < i; ++r)
            if ((e = t[r]).name === n) return e.value }

    function u(t, n, e) { for (var r = 0, i = t.length; r < i; ++r)
            if (t[r].name === n) { t[r] = c, t = t.slice(0, r).concat(t.slice(r + 1)); break }
        return null != e && t.push({ name: n, value: e }), t } var c = { value: function() {} };
    i.prototype = r.prototype = { constructor: i, on: function(t, n) { var e, r = this._,
                i = a(t + "", r),
                c = -1,
                f = i.length; { if (!(arguments.length < 2)) { if (null != n && "function" != typeof n) throw new Error("invalid callback: " + n); for (; ++c < f;)
                        if (e = (t = i[c]).type) r[e] = u(r[e], t.name, n);
                        else if (null == n)
                        for (e in r) r[e] = u(r[e], t.name, null); return this } for (; ++c < f;)
                    if ((e = (t = i[c]).type) && (e = o(r[e], t.name))) return e } }, copy: function() { var t = {},
                n = this._; for (var e in n) t[e] = n[e].slice(); return new i(t) }, call: function(t, n) { if ((e = arguments.length - 2) > 0)
                for (var e, r, i = new Array(e), a = 0; a < e; ++a) i[a] = arguments[a + 2]; if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t); for (r = this._[t], a = 0, e = r.length; a < e; ++a) r[a].value.apply(n, i) }, apply: function(t, n, e) { if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t); for (var r = this._[t], i = 0, a = r.length; i < a; ++i) r[i].value.apply(n, e) } }, n.a = r }, function(t, n, e) { "use strict"; var r = e(104);
    n.a = function(t, n, e) { var i = new r.a; return n = null == n ? 0 : +n, i.restart(function(e) { i.stop(), t(e + n) }, n, e), i } }, function(t, n, e) { "use strict";
    e(104) }, function(t, n, e) { "use strict";

    function r(t, n) { for (var e; !(e = t.__transition) || !(e = e[n]);)
            if (!(t = t.parentNode)) return c.time = Object(u.a)(), c;
        return e } var i = e(19),
        a = e(9),
        o = e(442),
        u = e(195),
        c = { time: null, delay: 0, duration: 250, ease: o.a };
    n.a = function(t) { var n, e;
        t instanceof i.a ? (n = t._id, t = t._name) : (n = Object(i.c)(), (e = c).time = Object(u.a)(), t = null == t ? null : t + ""); for (var o = this._groups, f = o.length, s = 0; s < f; ++s)
            for (var l, d = o[s], h = d.length, p = 0; p < h; ++p)(l = d[p]) && Object(a.e)(l, t, n, p, d, e || r(l, n)); return new i.a(o, this._parents, t, n) } }, function(t, n, e) { "use strict";

    function r(t) { return function() { this.removeAttribute(t) } }

    function i(t) { return function() { this.removeAttributeNS(t.space, t.local) } }

    function a(t, n, e) { var r, i; return function() { var a = this.getAttribute(t); return a === e ? null : a === r ? i : i = n(r = a, e) } }

    function o(t, n, e) { var r, i; return function() { var a = this.getAttributeNS(t.space, t.local); return a === e ? null : a === r ? i : i = n(r = a, e) } }

    function u(t, n, e) { var r, i, a; return function() { var o, u = e(this); return null == u ? void this.removeAttribute(t) : (o = this.getAttribute(t), o === u ? null : o === r && u === i ? a : a = n(r = o, i = u)) } }

    function c(t, n, e) { var r, i, a; return function() { var o, u = e(this); return null == u ? void this.removeAttributeNS(t.space, t.local) : (o = this.getAttributeNS(t.space, t.local), o === u ? null : o === r && u === i ? a : a = n(r = o, i = u)) } } var f = e(12),
        s = e(3),
        l = e(69),
        d = e(204);
    n.a = function(t, n) { var e = Object(s.namespace)(t),
            h = "transform" === e ? f.i : d.a; return this.attrTween(t, "function" == typeof n ? (e.local ? c : u)(e, h, Object(l.b)(this, "attr." + t, n)) : null == n ? (e.local ? i : r)(e) : (e.local ? o : a)(e, h, n + "")) } }, function(t, n, e) { "use strict";

    function r(t) { if (t instanceof a) return new a(t.l, t.a, t.b, t.opacity); if (t instanceof d) { var n = t.h * b.a; return new a(t.l, Math.cos(n) * t.c, Math.sin(n) * t.c, t.opacity) }
        t instanceof p.b || (t = Object(p.h)(t)); var e = f(t.r),
            r = f(t.g),
            i = f(t.b),
            u = o((.4124564 * e + .3575761 * r + .1804375 * i) / v),
            c = o((.2126729 * e + .7151522 * r + .072175 * i) / y); return new a(116 * c - 16, 500 * (u - c), 200 * (c - o((.0193339 * e + .119192 * r + .9503041 * i) / _)), t.opacity) }

    function i(t, n, e, i) { return 1 === arguments.length ? r(t) : new a(t, n, e, null == i ? 1 : i) }

    function a(t, n, e, r) { this.l = +t, this.a = +n, this.b = +e, this.opacity = +r }

    function o(t) { return t > w ? Math.pow(t, 1 / 3) : t / x + g }

    function u(t) { return t > m ? t * t * t : x * (t - g) }

    function c(t) { return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055) }

    function f(t) { return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4) }

    function s(t) { if (t instanceof d) return new d(t.h, t.c, t.l, t.opacity);
        t instanceof a || (t = r(t)); var n = Math.atan2(t.b, t.a) * b.b; return new d(n < 0 ? n + 360 : n, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity) }

    function l(t, n, e, r) { return 1 === arguments.length ? s(t) : new d(t, n, e, null == r ? 1 : r) }

    function d(t, n, e, r) { this.h = +t, this.c = +n, this.l = +e, this.opacity = +r }
    n.a = i, n.b = l; var h = e(107),
        p = e(106),
        b = e(196),
        v = .95047,
        y = 1,
        _ = 1.08883,
        g = 4 / 29,
        m = 6 / 29,
        x = 3 * m * m,
        w = m * m * m;
    Object(h.a)(a, i, Object(h.b)(p.a, { brighter: function(t) { return new a(this.l + 18 * (null == t ? 1 : t), this.a, this.b, this.opacity) }, darker: function(t) { return new a(this.l - 18 * (null == t ? 1 : t), this.a, this.b, this.opacity) }, rgb: function() { var t = (this.l + 16) / 116,
                n = isNaN(this.a) ? t : t + this.a / 500,
                e = isNaN(this.b) ? t : t - this.b / 200; return t = y * u(t), n = v * u(n), e = _ * u(e), new p.b(c(3.2404542 * n - 1.5371385 * t - .4985314 * e), c(-.969266 * n + 1.8760108 * t + .041556 * e), c(.0556434 * n - .2040259 * t + 1.0572252 * e), this.opacity) } })), Object(h.a)(d, l, Object(h.b)(p.a, { brighter: function(t) { return new d(this.h, this.c, this.l + 18 * (null == t ? 1 : t), this.opacity) }, darker: function(t) { return new d(this.h, this.c, this.l - 18 * (null == t ? 1 : t), this.opacity) }, rgb: function() { return r(this).rgb() } })) }, function(t, n, e) { "use strict";

    function r(t) { if (t instanceof a) return new a(t.h, t.s, t.l, t.opacity);
        t instanceof u.b || (t = Object(u.h)(t)); var n = t.r / 255,
            e = t.g / 255,
            r = t.b / 255,
            i = (v * r + p * n - b * e) / (v + p - b),
            o = r - i,
            f = (h * (e - i) - l * o) / d,
            s = Math.sqrt(f * f + o * o) / (h * i * (1 - i)),
            y = s ? Math.atan2(f, o) * c.b - 120 : NaN; return new a(y < 0 ? y + 360 : y, s, i, t.opacity) }

    function i(t, n, e, i) { return 1 === arguments.length ? r(t) : new a(t, n, e, null == i ? 1 : i) }

    function a(t, n, e, r) { this.h = +t, this.s = +n, this.l = +e, this.opacity = +r }
    n.a = i; var o = e(107),
        u = e(106),
        c = e(196),
        f = -.14861,
        s = 1.78277,
        l = -.29227,
        d = -.90649,
        h = 1.97294,
        p = h * d,
        b = h * s,
        v = s * l - d * f;
    Object(o.a)(a, i, Object(o.b)(u.a, { brighter: function(t) { return t = null == t ? u.c : Math.pow(u.c, t), new a(this.h, this.s, this.l * t, this.opacity) }, darker: function(t) { return t = null == t ? u.d : Math.pow(u.d, t), new a(this.h, this.s, this.l * t, this.opacity) }, rgb: function() { var t = isNaN(this.h) ? 0 : (this.h + 120) * c.a,
                n = +this.l,
                e = isNaN(this.s) ? 0 : this.s * n * (1 - n),
                r = Math.cos(t),
                i = Math.sin(t); return new u.b(255 * (n + e * (f * r + s * i)), 255 * (n + e * (l * r + d * i)), 255 * (n + e * (h * r)), this.opacity) } })) }, function(t, n, e) { "use strict";
    n.a = function(t, n) { return t = +t, n -= t,
            function(e) { return Math.round(t + n * e) } } }, function(t, n, e) { "use strict";

    function r(t, n, e, r) {
        function a(t) { return t.length ? t.pop() + " " : "" }

        function o(t, r, a, o, u, c) { if (t !== a || r !== o) { var f = u.push("translate(", null, n, null, e);
                c.push({ i: f - 4, x: Object(i.a)(t, a) }, { i: f - 2, x: Object(i.a)(r, o) }) } else(a || o) && u.push("translate(" + a + n + o + e) }

        function u(t, n, e, o) { t !== n ? (t - n > 180 ? n += 360 : n - t > 180 && (t += 360), o.push({ i: e.push(a(e) + "rotate(", null, r) - 2, x: Object(i.a)(t, n) })) : n && e.push(a(e) + "rotate(" + n + r) }

        function c(t, n, e, o) { t !== n ? o.push({ i: e.push(a(e) + "skewX(", null, r) - 2, x: Object(i.a)(t, n) }) : n && e.push(a(e) + "skewX(" + n + r) }

        function f(t, n, e, r, o, u) { if (t !== e || n !== r) { var c = o.push(a(o) + "scale(", null, ",", null, ")");
                u.push({ i: c - 4, x: Object(i.a)(t, e) }, { i: c - 2, x: Object(i.a)(n, r) }) } else 1 === e && 1 === r || o.push(a(o) + "scale(" + e + "," + r + ")") } return function(n, e) { var r = [],
                i = []; return n = t(n), e = t(e), o(n.translateX, n.translateY, e.translateX, e.translateY, r, i), u(n.rotate, e.rotate, r, i), c(n.skewX, e.skewX, r, i), f(n.scaleX, n.scaleY, e.scaleX, e.scaleY, r, i), n = e = null,
                function(t) { for (var n, e = -1, a = i.length; ++e < a;) r[(n = i[e]).i] = n.x(t); return r.join("") } } }
    e.d(n, "a", function() { return o }), e.d(n, "b", function() { return u }); var i = e(68),
        a = e(419),
        o = r(a.a, "px, ", "px)", "deg)"),
        u = r(a.b, ", ", ")", ")") }, function(t, n, e) { "use strict";

    function r(t) { return "none" === t ? f.b : (a || (a = document.createElement("DIV"), o = document.documentElement, u = document.defaultView), a.style.transform = t, t = u.getComputedStyle(o.appendChild(a), null).getPropertyValue("transform"), o.removeChild(a), t = t.slice(7, -1).split(","), Object(f.a)(+t[0], +t[1], +t[2], +t[3], +t[4], +t[5])) }

    function i(t) { return null == t ? f.b : (c || (c = document.createElementNS("http://www.w3.org/2000/svg", "g")), c.setAttribute("transform", t), (t = c.transform.baseVal.consolidate()) ? (t = t.matrix, Object(f.a)(t.a, t.b, t.c, t.d, t.e, t.f)) : f.b) }
    n.a = r, n.b = i; var a, o, u, c, f = e(420) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return i }); var r = 180 / Math.PI,
        i = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 };
    n.a = function(t, n, e, i, a, o) { var u, c, f; return (u = Math.sqrt(t * t + n * n)) && (t /= u, n /= u), (f = t * e + n * i) && (e -= t * f, i -= n * f), (c = Math.sqrt(e * e + i * i)) && (e /= c, i /= c, f /= c), t * i < n * e && (t = -t, n = -n, f = -f, u = -u), { translateX: a, translateY: o, rotate: Math.atan2(n, t) * r, skewX: Math.atan(f) * r, scaleX: u, scaleY: c } } }, function(t, n, e) { "use strict";
    Math.SQRT2 }, function(t, n, e) { "use strict";

    function r(t) { return function(n, e) { var r = t((n = Object(i.d)(n)).h, (e = Object(i.d)(e)).h),
                o = Object(a.a)(n.s, e.s),
                u = Object(a.a)(n.l, e.l),
                c = Object(a.a)(n.opacity, e.opacity); return function(t) { return n.h = r(t), n.s = o(t), n.l = u(t), n.opacity = c(t), n + "" } } } var i = e(13),
        a = e(46);
    r(a.c), r(a.a) }, function(t, n, e) { "use strict";
    e(13), e(46) }, function(t, n, e) { "use strict";

    function r(t) { return function(n, e) { var r = t((n = Object(i.c)(n)).h, (e = Object(i.c)(e)).h),
                o = Object(a.a)(n.c, e.c),
                u = Object(a.a)(n.l, e.l),
                c = Object(a.a)(n.opacity, e.opacity); return function(t) { return n.h = r(t), n.c = o(t), n.l = u(t), n.opacity = c(t), n + "" } } } var i = e(13),
        a = e(46);
    r(a.c), r(a.a) }, function(t, n, e) { "use strict";

    function r(t) { return function n(e) {
            function r(n, r) { var o = t((n = Object(i.b)(n)).h, (r = Object(i.b)(r)).h),
                    u = Object(a.a)(n.s, r.s),
                    c = Object(a.a)(n.l, r.l),
                    f = Object(a.a)(n.opacity, r.opacity); return function(t) { return n.h = o(t), n.s = u(t), n.l = c(Math.pow(t, e)), n.opacity = f(t), n + "" } } return e = +e, r.gamma = n, r }(1) }
    e.d(n, "a", function() { return o }); var i = e(13),
        a = e(46),
        o = (r(a.c), r(a.a)) }, function(t, n, e) { "use strict" }, function(t, n, e) { "use strict";

    function r(t, n) {
        function e() { var e = this,
                r = n.apply(e, arguments); return r && function(n) { e.setAttributeNS(t.space, t.local, r(n)) } } return e._value = n, e }

    function i(t, n) {
        function e() { var e = this,
                r = n.apply(e, arguments); return r && function(n) { e.setAttribute(t, r(n)) } } return e._value = n, e } var a = e(3);
    n.a = function(t, n) { var e = "attr." + t; if (arguments.length < 2) return (e = this.tween(e)) && e._value; if (null == n) return this.tween(e, null); if ("function" != typeof n) throw new Error; var o = Object(a.namespace)(t); return this.tween(e, (o.local ? r : i)(o, n)) } }, function(t, n, e) { "use strict";

    function r(t, n) { return function() { Object(a.g)(this, t).delay = +n.apply(this, arguments) } }

    function i(t, n) { return n = +n,
            function() { Object(a.g)(this, t).delay = n } } var a = e(9);
    n.a = function(t) { var n = this._id; return arguments.length ? this.each(("function" == typeof t ? r : i)(n, t)) : Object(a.f)(this.node(), n).delay } }, function(t, n, e) { "use strict";

    function r(t, n) { return function() { Object(a.h)(this, t).duration = +n.apply(this, arguments) } }

    function i(t, n) { return n = +n,
            function() { Object(a.h)(this, t).duration = n } } var a = e(9);
    n.a = function(t) { var n = this._id; return arguments.length ? this.each(("function" == typeof t ? r : i)(n, t)) : Object(a.f)(this.node(), n).duration } }, function(t, n, e) { "use strict";

    function r(t, n) { if ("function" != typeof n) throw new Error; return function() { Object(i.h)(this, t).ease = n } } var i = e(9);
    n.a = function(t) { var n = this._id; return arguments.length ? this.each(r(n, t)) : Object(i.f)(this.node(), n).ease } }, function(t, n, e) { "use strict"; var r = e(3),
        i = e(19);
    n.a = function(t) { "function" != typeof t && (t = Object(r.matcher)(t)); for (var n = this._groups, e = n.length, a = new Array(e), o = 0; o < e; ++o)
            for (var u, c = n[o], f = c.length, s = a[o] = [], l = 0; l < f; ++l)(u = c[l]) && t.call(u, u.__data__, l, c) && s.push(u); return new i.a(a, this._parents, this._name, this._id) } }, function(t, n, e) { "use strict"; var r = e(19);
    n.a = function(t) { if (t._id !== this._id) throw new Error; for (var n = this._groups, e = t._groups, i = n.length, a = e.length, o = Math.min(i, a), u = new Array(i), c = 0; c < o; ++c)
            for (var f, s = n[c], l = e[c], d = s.length, h = u[c] = new Array(d), p = 0; p < d; ++p)(f = s[p] || l[p]) && (h[p] = f); for (; c < i; ++c) u[c] = n[c]; return new r.a(u, this._parents, this._name, this._id) } }, function(t, n, e) { "use strict";

    function r(t) { return (t + "").trim().split(/^|\s+/).every(function(t) { var n = t.indexOf("."); return n >= 0 && (t = t.slice(0, n)), !t || "start" === t }) }

    function i(t, n, e) { var i, o, u = r(n) ? a.g : a.h; return function() { var r = u(this, t),
                a = r.on;
            a !== i && (o = (i = a).copy()).on(n, e), r.on = o } } var a = e(9);
    n.a = function(t, n) { var e = this._id; return arguments.length < 2 ? Object(a.f)(this.node(), e).on.on(t) : this.each(i(e, t, n)) } }, function(t, n, e) { "use strict";

    function r(t) { return function() { var n = this.parentNode; for (var e in this.__transition)
                if (+e !== t) return;
            n && n.removeChild(this) } }
    n.a = function() { return this.on("end.remove", r(this._id)) } }, function(t, n, e) { "use strict"; var r = e(3),
        i = e(19),
        a = e(9);
    n.a = function(t) { var n = this._name,
            e = this._id; "function" != typeof t && (t = Object(r.selector)(t)); for (var o = this._groups, u = o.length, c = new Array(u), f = 0; f < u; ++f)
            for (var s, l, d = o[f], h = d.length, p = c[f] = new Array(h), b = 0; b < h; ++b)(s = d[b]) && (l = t.call(s, s.__data__, b, d)) && ("__data__" in s && (l.__data__ = s.__data__), p[b] = l, Object(a.e)(p[b], n, e, b, p, Object(a.f)(s, e))); return new i.a(c, this._parents, n, e) } }, function(t, n, e) { "use strict"; var r = e(3),
        i = e(19),
        a = e(9);
    n.a = function(t) { var n = this._name,
            e = this._id; "function" != typeof t && (t = Object(r.selectorAll)(t)); for (var o = this._groups, u = o.length, c = [], f = [], s = 0; s < u; ++s)
            for (var l, d = o[s], h = d.length, p = 0; p < h; ++p)
                if (l = d[p]) { for (var b, v = t.call(l, l.__data__, p, d), y = Object(a.f)(l, e), _ = 0, g = v.length; _ < g; ++_)(b = v[_]) && Object(a.e)(b, n, e, _, v, y);
                    c.push(v), f.push(l) }
        return new i.a(c, f, n, e) } }, function(t, n, e) { "use strict"; var r = e(3),
        i = r.selection.prototype.constructor;
    n.a = function() { return new i(this._groups, this._parents) } }, function(t, n, e) { "use strict";

    function r(t, n) { var e, r, i; return function() { var a = Object(c.style)(this, t),
                o = (this.style.removeProperty(t), Object(c.style)(this, t)); return a === o ? null : a === e && o === r ? i : i = n(e = a, r = o) } }

    function i(t) { return function() { this.style.removeProperty(t) } }

    function a(t, n, e) { var r, i; return function() { var a = Object(c.style)(this, t); return a === e ? null : a === r ? i : i = n(r = a, e) } }

    function o(t, n, e) { var r, i, a; return function() { var o = Object(c.style)(this, t),
                u = e(this); return null == u && (this.style.removeProperty(t), u = Object(c.style)(this, t)), o === u ? null : o === r && u === i ? a : a = n(r = o, i = u) } } var u = e(12),
        c = e(3),
        f = e(69),
        s = e(204);
    n.a = function(t, n, e) { var c = "transform" == (t += "") ? u.h : s.a; return null == n ? this.styleTween(t, r(t, c)).on("end.style." + t, i(t)) : this.styleTween(t, "function" == typeof n ? o(t, c, Object(f.b)(this, "style." + t, n)) : a(t, c, n + ""), e) } }, function(t, n, e) { "use strict";

    function r(t, n, e) {
        function r() { var r = this,
                i = n.apply(r, arguments); return i && function(n) { r.style.setProperty(t, i(n), e) } } return r._value = n, r }
    n.a = function(t, n, e) { var i = "style." + (t += ""); if (arguments.length < 2) return (i = this.tween(i)) && i._value; if (null == n) return this.tween(i, null); if ("function" != typeof n) throw new Error; return this.tween(i, r(t, n, null == e ? "" : e)) } }, function(t, n, e) { "use strict";

    function r(t) { return function() { this.textContent = t } }

    function i(t) { return function() { var n = t(this);
            this.textContent = null == n ? "" : n } } var a = e(69);
    n.a = function(t) { return this.tween("text", "function" == typeof t ? i(Object(a.b)(this, "text", t)) : r(null == t ? "" : t + "")) } }, function(t, n, e) { "use strict"; var r = e(19),
        i = e(9);
    n.a = function() { for (var t = this._name, n = this._id, e = Object(r.c)(), a = this._groups, o = a.length, u = 0; u < o; ++u)
            for (var c, f = a[u], s = f.length, l = 0; l < s; ++l)
                if (c = f[l]) { var d = Object(i.f)(c, n);
                    Object(i.e)(c, t, e, l, f, { time: d.time + d.delay + d.duration, delay: 0, duration: d.duration, ease: d.ease }) }
        return new r.a(a, this._parents, t, e) } }, function(t, n, e) { "use strict"; var r = (e(443), e(444), e(445));
    e.d(n, "a", function() { return r.a });
    e(446), e(447), e(448), e(449), e(450), e(451), e(452) }, function(t, n, e) { "use strict" }, function(t, n, e) { "use strict" }, function(t, n, e) { "use strict";

    function r(t) { return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2 }
    n.a = r }, function(t, n, e) { "use strict";
    (function t(n) {
        function e(t) { return Math.pow(t, n) } return n = +n, e.exponent = t, e })(3),
    function t(n) {
        function e(t) { return 1 - Math.pow(1 - t, n) } return n = +n, e.exponent = t, e }(3),
    function t(n) {
        function e(t) { return ((t *= 2) <= 1 ? Math.pow(t, n) : 2 - Math.pow(2 - t, n)) / 2 } return n = +n, e.exponent = t, e }(3) }, function(t, n, e) { "use strict";
    Math.PI }, function(t, n, e) { "use strict" }, function(t, n, e) { "use strict" }, function(t, n, e) { "use strict" }, function(t, n, e) { "use strict";
    (function t(n) {
        function e(t) { return t * t * ((n + 1) * t - n) } return n = +n, e.overshoot = t, e })(1.70158),
    function t(n) {
        function e(t) { return --t * t * ((n + 1) * t + n) + 1 } return n = +n, e.overshoot = t, e }(1.70158),
    function t(n) {
        function e(t) { return ((t *= 2) < 1 ? t * t * ((n + 1) * t - n) : (t -= 2) * t * ((n + 1) * t + n) + 2) / 2 } return n = +n, e.overshoot = t, e }(1.70158) }, function(t, n, e) { "use strict"; var r = 2 * Math.PI;
    (function t(n, e) {
        function i(t) { return n * Math.pow(2, 10 * --t) * Math.sin((a - t) / e) } var a = Math.asin(1 / (n = Math.max(1, n))) * (e /= r); return i.amplitude = function(n) { return t(n, e * r) }, i.period = function(e) { return t(n, e) }, i })(1, .3),
    function t(n, e) {
        function i(t) { return 1 - n * Math.pow(2, -10 * (t = +t)) * Math.sin((t + a) / e) } var a = Math.asin(1 / (n = Math.max(1, n))) * (e /= r); return i.amplitude = function(n) { return t(n, e * r) }, i.period = function(e) { return t(n, e) }, i }(1, .3),
    function t(n, e) {
        function i(t) { return ((t = 2 * t - 1) < 0 ? n * Math.pow(2, 10 * t) * Math.sin((a - t) / e) : 2 - n * Math.pow(2, -10 * t) * Math.sin((a + t) / e)) / 2 } var a = Math.asin(1 / (n = Math.max(1, n))) * (e /= r); return i.amplitude = function(n) { return t(n, e * r) }, i.period = function(e) { return t(n, e) }, i }(1, .3) }, function(t, n, e) { "use strict"; var r = e(19),
        i = e(9),
        a = [null];
    n.a = function(t, n) { var e, o, u = t.__transition; if (u) { n = null == n ? null : n + ""; for (o in u)
                if ((e = u[o]).state > i.c && e.name === n) return new r.a([
                    [t]
                ], a, n, +o) } return null } }, function(t, n, e) { var r = e(455); "string" == typeof r && (r = [
        [t.i, r, ""]
    ]);
    e(457)(r, {});
    r.locals && (t.exports = r.locals) }, function(t, n, e) { n = t.exports = e(456)(), n.push([t.i, "div.circos-tooltip{position:absolute;text-align:center;padding:5px 10px;background:#111;color:#fff;border:0;pointer-events:none;z-index:1000}", ""]) }, function(t, n) { t.exports = function() { var t = []; return t.toString = function() { for (var t = [], n = 0; n < this.length; n++) { var e = this[n];
                e[2] ? t.push("@media " + e[2] + "{" + e[1] + "}") : t.push(e[1]) } return t.join("") }, t.i = function(n, e) { "string" == typeof n && (n = [
                [null, n, ""]
            ]); for (var r = {}, i = 0; i < this.length; i++) { var a = this[i][0]; "number" == typeof a && (r[a] = !0) } for (i = 0; i < n.length; i++) { var o = n[i]; "number" == typeof o[0] && r[o[0]] || (e && !o[2] ? o[2] = e : e && (o[2] = "(" + o[2] + ") and (" + e + ")"), t.push(o)) } }, t } }, function(t, n) {
    function e(t, n) { for (var e = 0; e < t.length; e++) { var r = t[e],
                i = d[r.id]; if (i) { i.refs++; for (var a = 0; a < i.parts.length; a++) i.parts[a](r.parts[a]); for (; a < r.parts.length; a++) i.parts.push(c(r.parts[a], n)) } else { for (var o = [], a = 0; a < r.parts.length; a++) o.push(c(r.parts[a], n));
                d[r.id] = { id: r.id, refs: 1, parts: o } } } }

    function r(t) { for (var n = [], e = {}, r = 0; r < t.length; r++) { var i = t[r],
                a = i[0],
                o = i[1],
                u = i[2],
                c = i[3],
                f = { css: o, media: u, sourceMap: c };
            e[a] ? e[a].parts.push(f) : n.push(e[a] = { id: a, parts: [f] }) } return n }

    function i(t, n) { var e = b(),
            r = _[_.length - 1]; if ("top" === t.insertAt) r ? r.nextSibling ? e.insertBefore(n, r.nextSibling) : e.appendChild(n) : e.insertBefore(n, e.firstChild), _.push(n);
        else { if ("bottom" !== t.insertAt) throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
            e.appendChild(n) } }

    function a(t) { t.parentNode.removeChild(t); var n = _.indexOf(t);
        n >= 0 && _.splice(n, 1) }

    function o(t) { var n = document.createElement("style"); return n.type = "text/css", i(t, n), n }

    function u(t) { var n = document.createElement("link"); return n.rel = "stylesheet", i(t, n), n }

    function c(t, n) { var e, r, i; if (n.singleton) { var c = y++;
            e = v || (v = o(n)), r = f.bind(null, e, c, !1), i = f.bind(null, e, c, !0) } else t.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (e = u(n), r = l.bind(null, e), i = function() { a(e), e.href && URL.revokeObjectURL(e.href) }) : (e = o(n), r = s.bind(null, e), i = function() { a(e) }); return r(t),
            function(n) { if (n) { if (n.css === t.css && n.media === t.media && n.sourceMap === t.sourceMap) return;
                    r(t = n) } else i() } }

    function f(t, n, e, r) { var i = e ? "" : r.css; if (t.styleSheet) t.styleSheet.cssText = g(n, i);
        else { var a = document.createTextNode(i),
                o = t.childNodes;
            o[n] && t.removeChild(o[n]), o.length ? t.insertBefore(a, o[n]) : t.appendChild(a) } }

    function s(t, n) { var e = n.css,
            r = n.media; if (r && t.setAttribute("media", r), t.styleSheet) t.styleSheet.cssText = e;
        else { for (; t.firstChild;) t.removeChild(t.firstChild);
            t.appendChild(document.createTextNode(e)) } }

    function l(t, n) { var e = n.css,
            r = n.sourceMap;
        r && (e += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(r)))) + " */"); var i = new Blob([e], { type: "text/css" }),
            a = t.href;
        t.href = URL.createObjectURL(i), a && URL.revokeObjectURL(a) } var d = {},
        h = function(t) { var n; return function() { return void 0 === n && (n = t.apply(this, arguments)), n } },
        p = h(function() { return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase()) }),
        b = h(function() { return document.head || document.getElementsByTagName("head")[0] }),
        v = null,
        y = 0,
        _ = [];
    t.exports = function(t, n) { if ("undefined" != typeof DEBUG && DEBUG && "object" != typeof document) throw new Error("The style-loader cannot be used in a non-browser environment");
        n = n || {}, void 0 === n.singleton && (n.singleton = p()), void 0 === n.insertAt && (n.insertAt = "bottom"); var i = r(t); return e(i, n),
            function(t) { for (var a = [], o = 0; o < i.length; o++) { var u = i[o],
                        c = d[u.id];
                    c.refs--, a.push(c) } if (t) { e(r(t), n) } for (var o = 0; o < a.length; o++) { var c = a[o]; if (0 === c.refs) { for (var f = 0; f < c.parts.length; f++) c.parts[f]();
                        delete d[c.id] } } } }; var g = function() { var t = []; return function(n, e) { return t[n] = e, t.filter(Boolean).join("\n") } }() }, function(t, n, e) { "use strict";

    function r(t) { return t && t.__esModule ? t : { default: t } }
    Object.defineProperty(n, "__esModule", { value: !0 }), n.getConf = void 0; var i = e(163),
        a = r(i),
        o = e(32),
        u = r(o),
        c = e(23),
        f = r(c),
        s = e(14),
        l = r(s),
        d = e(205),
        h = function t() { var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                e = arguments[1],
                r = {}; return (0, u.default)(e, function(e, i) { void 0 !== e.iteratee ? e.iteratee ? Object.keys(n).indexOf(i) > -1 ? ((0, f.default)(n[i]), r[i] = n[i]) : r[i] = function() { return e.value } : r[i] = Object.keys(n).indexOf(i) > -1 ? n[i] : e.value : r[i] = t(n[i], e) }), r },
        p = function(t, n) { return { cmin: null === t.min ? n.min : t.min, cmax: null === t.max ? n.max : t.max } },
        b = function(t, n) { if (0 === t.innerRadius && 0 === t.outerRadius) { var e = (0, d.smartBorders)(t, n._layout, n.tracks); return { innerRadius: e.in, outerRadius: e.out } } return t.innerRadius <= 1 && t.outerRadius <= 1 ? { innerRadius: t.innerRadius * n._layout.conf.innerRadius, outerRadius: t.outerRadius * n._layout.conf.innerRadius } : t.innerRadius <= 10 && t.outerRadius <= 10 ? { innerRadius: t.innerRadius * n._layout.conf.outerRadius, outerRadius: t.outerRadius * n._layout.conf.outerRadius } : void 0 },
        v = function(t, n, e, r) { var i = h(t, (0, a.default)(n)); return (0, l.default)(i, p(i, e), b(i, r)), i };
    n.getConf = v }, function(t, n, e) { var r = e(37),
        i = r("sortBy", e(97));
    i.placeholder = e(26), t.exports = i }, function(t, n, e) {
    function r(t, n) { return 2 == n ? function(n, e) { return t.apply(void 0, arguments) } : function(n) { return t.apply(void 0, arguments) } }

    function i(t, n) { return 2 == n ? function(n, e) { return t(n, e) } : function(n) { return t(n) } }

    function a(t) { for (var n = t ? t.length : 0, e = Array(n); n--;) e[n] = t[n]; return e }

    function o(t) { return function(n) { return t({}, n) } }

    function u(t, n) { return function() { for (var e = arguments.length, r = e - 1, i = Array(e); e--;) i[e] = arguments[e]; var a = i[n],
                o = i.slice(0, n); return a && d.apply(o, a), n != r && d.apply(o, i.slice(n + 1)), t.apply(this, o) } }

    function c(t, n) { return function() { var e = arguments.length; if (e) { for (var r = Array(e); e--;) r[e] = arguments[e]; var i = r[0] = n.apply(void 0, r); return t.apply(void 0, r), i } } }

    function f(t, n, e, d) {
        function h(t, n) { if (A.cap) { var e = s.iterateeRearg[t]; if (e) return x(n, e); var r = !M && s.iterateeAry[t]; if (r) return m(n, r) } return n }

        function p(t, n, e) { return T || A.curry && e > 1 ? B(n, e) : n }

        function b(t, n, e) { if (A.fixed && (R || !s.skipFixed[t])) { var r = s.methodSpread[t],
                    i = r && r.start; return void 0 === i ? N(n, e) : u(n, i) } return n }

        function v(t, n, e) { return A.rearg && e > 1 && (P || !s.skipRearg[t]) ? W(n, s.methodRearg[t] || s.aryRearg[e]) : n }

        function y(t, n) { n = q(n); for (var e = -1, r = n.length, i = r - 1, a = D(Object(t)), o = a; null != o && ++e < r;) { var u = n[e],
                    c = o[u];
                null != c && (o[n[e]] = D(e == i ? c : Object(c))), o = o[u] } return a }

        function _(t) { return H.runInContext.convert(t)(void 0) }

        function g(t, n) { var e = s.aliasToReal[t] || t,
                r = s.remap[e] || e,
                i = d; return function(t) { var a = M ? C : E,
                    o = M ? C[r] : n,
                    u = I(I({}, i), t); return f(a, e, o, u) } }

        function m(t, n) { return w(t, function(t) { return "function" == typeof t ? i(t, n) : t }) }

        function x(t, n) { return w(t, function(t) { var e = n.length; return r(W(i(t, e), n), e) }) }

        function w(t, n) { return function() { var e = arguments.length; if (!e) return t(); for (var r = Array(e); e--;) r[e] = arguments[e]; var i = A.rearg ? 0 : e - 1; return r[i] = n(r[i]), t.apply(void 0, r) } }

        function j(t, n) { var e, r = s.aliasToReal[t] || t,
                i = n,
                u = V[r]; return u ? i = u(n) : A.immutable && (s.mutate.array[r] ? i = c(n, a) : s.mutate.object[r] ? i = c(n, o(n)) : s.mutate.set[r] && (i = c(n, y))), z(G, function(t) { return z(s.aryMethod[t], function(n) { if (r == n) { var a = s.methodSpread[r],
                            o = a && a.afterRearg; return e = o ? b(r, v(r, i, t), t) : v(r, b(r, i, t), t), e = h(r, e), e = p(r, e, t), !1 } }), !e }), e || (e = i), e == n && (e = T ? B(e, 1) : function() { return n.apply(this, arguments) }), e.convert = g(r, n), s.placeholder[r] && (O = !0, e.placeholder = n.placeholder = S), e } var O, M = "function" == typeof n,
            k = n === Object(n); if (k && (d = e, e = n, n = void 0), null == e) throw new TypeError;
        d || (d = {}); var A = { cap: !("cap" in d) || d.cap, curry: !("curry" in d) || d.curry, fixed: !("fixed" in d) || d.fixed, immutable: !("immutable" in d) || d.immutable, rearg: !("rearg" in d) || d.rearg },
            T = "curry" in d && d.curry,
            R = "fixed" in d && d.fixed,
            P = "rearg" in d && d.rearg,
            S = M ? e : l,
            C = M ? e.runInContext() : void 0,
            E = M ? e : { ary: t.ary, assign: t.assign, clone: t.clone, curry: t.curry, forEach: t.forEach, isArray: t.isArray, isFunction: t.isFunction, iteratee: t.iteratee, keys: t.keys, rearg: t.rearg, toInteger: t.toInteger, toPath: t.toPath },
            N = E.ary,
            I = E.assign,
            D = E.clone,
            B = E.curry,
            z = E.forEach,
            L = E.isArray,
            F = E.isFunction,
            U = E.keys,
            W = E.rearg,
            Y = E.toInteger,
            q = E.toPath,
            G = U(s.aryMethod),
            V = { castArray: function(t) { return function() { var n = arguments[0]; return L(n) ? t(a(n)) : t.apply(void 0, arguments) } }, iteratee: function(t) { return function() { var n = arguments[0],
                            e = arguments[1],
                            r = t(n, e),
                            a = r.length; return A.cap && "number" == typeof e ? (e = e > 2 ? e - 2 : 1, a && a <= e ? r : i(r, e)) : r } }, mixin: function(t) { return function(n) { var e = this; if (!F(e)) return t(e, Object(n)); var r = []; return z(U(n), function(t) { F(n[t]) && r.push([t, e.prototype[t]]) }), t(e, Object(n)), z(r, function(t) { var n = t[1];
                            F(n) ? e.prototype[t[0]] = n : delete e.prototype[t[0]] }), e } }, nthArg: function(t) { return function(n) { var e = n < 0 ? 1 : Y(n) + 1; return B(t(n), e) } }, rearg: function(t) { return function(n, e) { var r = e ? e.length : 0; return B(t(n, e), r) } }, runInContext: function(n) { return function(e) { return f(t, n(e), d) } } }; if (!k) return j(n, e); var H = e,
            X = []; return z(G, function(t) { z(s.aryMethod[t], function(t) { var n = H[s.remap[t] || t];
                n && X.push([t, j(t, n)]) }) }), z(U(H), function(t) { var n = H[t]; if ("function" == typeof n) { for (var e = X.length; e--;)
                    if (X[e][0] == t) return;
                n.convert = g(t, n), X.push([t, n]) } }), z(X, function(t) { H[t[0]] = t[1] }), H.convert = _, O && (H.placeholder = S), z(U(H), function(t) { z(s.realToAlias[t] || [], function(n) { H[n] = H[t] }) }), H } var s = e(461),
        l = e(26),
        d = Array.prototype.push;
    t.exports = f }, function(t, n) { n.aliasToReal = { each: "forEach", eachRight: "forEachRight", entries: "toPairs", entriesIn: "toPairsIn", extend: "assignIn", extendAll: "assignInAll", extendAllWith: "assignInAllWith", extendWith: "assignInWith", first: "head", conforms: "conformsTo", matches: "isMatch", property: "get", __: "placeholder", F: "stubFalse", T: "stubTrue", all: "every", allPass: "overEvery", always: "constant", any: "some", anyPass: "overSome", apply: "spread", assoc: "set", assocPath: "set", complement: "negate", compose: "flowRight", contains: "includes", dissoc: "unset", dissocPath: "unset", dropLast: "dropRight", dropLastWhile: "dropRightWhile", equals: "isEqual", identical: "eq", indexBy: "keyBy", init: "initial", invertObj: "invert", juxt: "over", omitAll: "omit", nAry: "ary", path: "get", pathEq: "matchesProperty", pathOr: "getOr", paths: "at", pickAll: "pick", pipe: "flow", pluck: "map", prop: "get", propEq: "matchesProperty", propOr: "getOr", props: "at", symmetricDifference: "xor", symmetricDifferenceBy: "xorBy", symmetricDifferenceWith: "xorWith", takeLast: "takeRight", takeLastWhile: "takeRightWhile", unapply: "rest", unnest: "flatten", useWith: "overArgs", where: "conformsTo", whereEq: "isMatch", zipObj: "zipObject" }, n.aryMethod = { 1: ["assignAll", "assignInAll", "attempt", "castArray", "ceil", "create", "curry", "curryRight", "defaultsAll", "defaultsDeepAll", "floor", "flow", "flowRight", "fromPairs", "invert", "iteratee", "memoize", "method", "mergeAll", "methodOf", "mixin", "nthArg", "over", "overEvery", "overSome", "rest", "reverse", "round", "runInContext", "spread", "template", "trim", "trimEnd", "trimStart", "uniqueId", "words", "zipAll"], 2: ["add", "after", "ary", "assign", "assignAllWith", "assignIn", "assignInAllWith", "at", "before", "bind", "bindAll", "bindKey", "chunk", "cloneDeepWith", "cloneWith", "concat", "conformsTo", "countBy", "curryN", "curryRightN", "debounce", "defaults", "defaultsDeep", "defaultTo", "delay", "difference", "divide", "drop", "dropRight", "dropRightWhile", "dropWhile", "endsWith", "eq", "every", "filter", "find", "findIndex", "findKey", "findLast", "findLastIndex", "findLastKey", "flatMap", "flatMapDeep", "flattenDepth", "forEach", "forEachRight", "forIn", "forInRight", "forOwn", "forOwnRight", "get", "groupBy", "gt", "gte", "has", "hasIn", "includes", "indexOf", "intersection", "invertBy", "invoke", "invokeMap", "isEqual", "isMatch", "join", "keyBy", "lastIndexOf", "lt", "lte", "map", "mapKeys", "mapValues", "matchesProperty", "maxBy", "meanBy", "merge", "mergeAllWith", "minBy", "multiply", "nth", "omit", "omitBy", "overArgs", "pad", "padEnd", "padStart", "parseInt", "partial", "partialRight", "partition", "pick", "pickBy", "propertyOf", "pull", "pullAll", "pullAt", "random", "range", "rangeRight", "rearg", "reject", "remove", "repeat", "restFrom", "result", "sampleSize", "some", "sortBy", "sortedIndex", "sortedIndexOf", "sortedLastIndex", "sortedLastIndexOf", "sortedUniqBy", "split", "spreadFrom", "startsWith", "subtract", "sumBy", "take", "takeRight", "takeRightWhile", "takeWhile", "tap", "throttle", "thru", "times", "trimChars", "trimCharsEnd", "trimCharsStart", "truncate", "union", "uniqBy", "uniqWith", "unset", "unzipWith", "without", "wrap", "xor", "zip", "zipObject", "zipObjectDeep"], 3: ["assignInWith", "assignWith", "clamp", "differenceBy", "differenceWith", "findFrom", "findIndexFrom", "findLastFrom", "findLastIndexFrom", "getOr", "includesFrom", "indexOfFrom", "inRange", "intersectionBy", "intersectionWith", "invokeArgs", "invokeArgsMap", "isEqualWith", "isMatchWith", "flatMapDepth", "lastIndexOfFrom", "mergeWith", "orderBy", "padChars", "padCharsEnd", "padCharsStart", "pullAllBy", "pullAllWith", "rangeStep", "rangeStepRight", "reduce", "reduceRight", "replace", "set", "slice", "sortedIndexBy", "sortedLastIndexBy", "transform", "unionBy", "unionWith", "update", "xorBy", "xorWith", "zipWith"], 4: ["fill", "setWith", "updateWith"] }, n.aryRearg = { 2: [1, 0], 3: [2, 0, 1], 4: [3, 2, 0, 1] }, n.iterateeAry = { dropRightWhile: 1, dropWhile: 1, every: 1, filter: 1, find: 1, findFrom: 1, findIndex: 1, findIndexFrom: 1, findKey: 1, findLast: 1, findLastFrom: 1, findLastIndex: 1, findLastIndexFrom: 1, findLastKey: 1, flatMap: 1, flatMapDeep: 1, flatMapDepth: 1, forEach: 1, forEachRight: 1, forIn: 1, forInRight: 1, forOwn: 1, forOwnRight: 1, map: 1, mapKeys: 1, mapValues: 1, partition: 1, reduce: 2, reduceRight: 2, reject: 1, remove: 1, some: 1, takeRightWhile: 1, takeWhile: 1, times: 1, transform: 2 }, n.iterateeRearg = { mapKeys: [1], reduceRight: [1, 0] }, n.methodRearg = { assignInAllWith: [1, 0], assignInWith: [1, 2, 0], assignAllWith: [1, 0], assignWith: [1, 2, 0], differenceBy: [1, 2, 0], differenceWith: [1, 2, 0], getOr: [2, 1, 0], intersectionBy: [1, 2, 0], intersectionWith: [1, 2, 0], isEqualWith: [1, 2, 0], isMatchWith: [2, 1, 0], mergeAllWith: [1, 0], mergeWith: [1, 2, 0], padChars: [2, 1, 0], padCharsEnd: [2, 1, 0], padCharsStart: [2, 1, 0], pullAllBy: [2, 1, 0], pullAllWith: [2, 1, 0], rangeStep: [1, 2, 0], rangeStepRight: [1, 2, 0], setWith: [3, 1, 2, 0], sortedIndexBy: [2, 1, 0], sortedLastIndexBy: [2, 1, 0], unionBy: [1, 2, 0], unionWith: [1, 2, 0], updateWith: [3, 1, 2, 0], xorBy: [1, 2, 0], xorWith: [1, 2, 0], zipWith: [1, 2, 0] }, n.methodSpread = { assignAll: { start: 0 }, assignAllWith: { start: 0 }, assignInAll: { start: 0 }, assignInAllWith: { start: 0 }, defaultsAll: { start: 0 }, defaultsDeepAll: { start: 0 }, invokeArgs: { start: 2 }, invokeArgsMap: { start: 2 }, mergeAll: { start: 0 }, mergeAllWith: { start: 0 }, partial: { start: 1 }, partialRight: { start: 1 }, without: { start: 1 }, zipAll: { start: 0 } }, n.mutate = { array: { fill: !0, pull: !0, pullAll: !0, pullAllBy: !0, pullAllWith: !0, pullAt: !0, remove: !0, reverse: !0 }, object: { assign: !0, assignAll: !0, assignAllWith: !0, assignIn: !0, assignInAll: !0, assignInAllWith: !0, assignInWith: !0, assignWith: !0, defaults: !0, defaultsAll: !0, defaultsDeep: !0, defaultsDeepAll: !0, merge: !0, mergeAll: !0, mergeAllWith: !0, mergeWith: !0 }, set: { set: !0, setWith: !0, unset: !0, update: !0, updateWith: !0 } }, n.placeholder = { bind: !0, bindKey: !0, curry: !0, curryRight: !0, partial: !0, partialRight: !0 }, n.realToAlias = function() { var t = Object.prototype.hasOwnProperty,
            e = n.aliasToReal,
            r = {}; for (var i in e) { var a = e[i];
            t.call(r, a) ? r[a].push(i) : r[a] = [i] } return r }(), n.remap = { assignAll: "assign", assignAllWith: "assignWith", assignInAll: "assignIn", assignInAllWith: "assignInWith", curryN: "curry", curryRightN: "curryRight", defaultsAll: "defaults", defaultsDeepAll: "defaultsDeep", findFrom: "find", findIndexFrom: "findIndex", findLastFrom: "findLast", findLastIndexFrom: "findLastIndex", getOr: "get", includesFrom: "includes", indexOfFrom: "indexOf", invokeArgs: "invoke", invokeArgsMap: "invokeMap", lastIndexOfFrom: "lastIndexOf", mergeAll: "merge", mergeAllWith: "mergeWith", padChars: "pad", padCharsEnd: "padEnd", padCharsStart: "padStart", propertyOf: "get", rangeStep: "range", rangeStepRight: "rangeRight", restFrom: "rest", spreadFrom: "spread", trimChars: "trim", trimCharsEnd: "trimEnd", trimCharsStart: "trimStart", zipAll: "zip" }, n.skipFixed = { castArray: !0, flow: !0, flowRight: !0, iteratee: !0, mixin: !0, rearg: !0, runInContext: !0 }, n.skipRearg = { add: !0, assign: !0, assignIn: !0, bind: !0, bindKey: !0, concat: !0, difference: !0, divide: !0, eq: !0, gt: !0, gte: !0, isEqual: !0, lt: !0, lte: !0, matchesProperty: !0, merge: !0, multiply: !0, overArgs: !0, partial: !0, partialRight: !0, propertyOf: !0, random: !0, range: !0, rangeRight: !0, subtract: !0, zip: !0, zipObject: !0, zipObjectDeep: !0 } }, function(t, n, e) { t.exports = { ary: e(463), assign: e(164), clone: e(482), curry: e(483), forEach: e(62), isArray: e(2), isFunction: e(23), iteratee: e(484), keys: e(139), rearg: e(485), toInteger: e(115), toPath: e(487) } }, function(t, n, e) {
    function r(t, n, e) { return n = e ? void 0 : n, n = t && null == n ? t.length : n, i(t, a, void 0, void 0, void 0, void 0, n) } var i = e(109),
        a = 128;
    t.exports = r }, function(t, n, e) {
    function r(t, n, e) {
        function r() { return (this && this !== a && this instanceof r ? c : t).apply(u ? e : this, arguments) } var u = n & o,
            c = i(t); return r } var i = e(70),
        a = e(5),
        o = 1;
    t.exports = r }, function(t, n, e) {
    function r(t, n, e) {
        function r() { for (var a = arguments.length, d = Array(a), h = a, p = c(r); h--;) d[h] = arguments[h]; var b = a < 3 && d[0] !== p && d[a - 1] !== p ? [] : f(d, p); return (a -= b.length) < e ? u(t, n, o, r.placeholder, void 0, d, b, void 0, void 0, e - a) : i(this && this !== s && this instanceof r ? l : t, this, d) } var l = a(t); return r } var i = e(49),
        a = e(70),
        o = e(208),
        u = e(211),
        c = e(217),
        f = e(114),
        s = e(5);
    t.exports = r }, function(t, n) {
    function e(t, n) { for (var e = t.length, r = 0; e--;) t[e] === n && ++r; return r }
    t.exports = e }, function(t, n) {
    function e() {}
    t.exports = e }, function(t, n) { var e = {};
    t.exports = e }, function(t, n, e) {
    function r(t) { if (c(t) && !u(t) && !(t instanceof i)) { if (t instanceof a) return t; if (l.call(t, "__wrapped__")) return f(t) } return new a(t) } var i = e(110),
        a = e(113),
        o = e(111),
        u = e(2),
        c = e(10),
        f = e(470),
        s = Object.prototype,
        l = s.hasOwnProperty;
    r.prototype = o.prototype, r.prototype.constructor = r, t.exports = r }, function(t, n, e) {
    function r(t) { if (t instanceof i) return t.clone(); var n = new a(t.__wrapped__, t.__chain__); return n.__actions__ = o(t.__actions__), n.__index__ = t.__index__, n.__values__ = t.__values__, n } var i = e(110),
        a = e(113),
        o = e(30);
    t.exports = r }, function(t, n) {
    function e(t) { var n = t.match(r); return n ? n[1].split(i) : [] } var r = /\{\n\/\* \[wrapped with (.+)\] \*/,
        i = /,? & /;
    t.exports = e }, function(t, n) {
    function e(t, n) { var e = n.length; if (!e) return t; var i = e - 1; return n[i] = (e > 1 ? "& " : "") + n[i], n = n.join(e > 2 ? ", " : " "), t.replace(r, "{\n/* [wrapped with " + n + "] */\n") } var r = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
    t.exports = e }, function(t, n, e) {
    function r(t, n) { return i(o, function(e) { var r = "_." + e[0];
            n & e[1] && !a(t, r) && t.push(r) }), t.sort() } var i = e(62),
        a = e(474),
        o = [
            ["ary", 128],
            ["bind", 1],
            ["bindKey", 2],
            ["curry", 8],
            ["curryRight", 16],
            ["flip", 512],
            ["partial", 32],
            ["partialRight", 64],
            ["rearg", 256]
        ];
    t.exports = r }, function(t, n, e) {
    function r(t, n) { return !!(null == t ? 0 : t.length) && i(t, n, 0) > -1 } var i = e(216);
    t.exports = r }, function(t, n) {
    function e(t, n, e, r) { for (var i = t.length, a = e + (r ? 1 : -1); r ? a-- : ++a < i;)
            if (n(t[a], a, t)) return a;
        return -1 }
    t.exports = e }, function(t, n) {
    function e(t) { return t !== t }
    t.exports = e }, function(t, n) {
    function e(t, n, e) { for (var r = e - 1, i = t.length; ++r < i;)
            if (t[r] === n) return r;
        return -1 }
    t.exports = e }, function(t, n, e) {
    function r(t, n) { for (var e = t.length, r = o(n.length, e), u = i(t); r--;) { var c = n[r];
            t[r] = a(c, e) ? u[c] : void 0 } return t } var i = e(30),
        a = e(60),
        o = Math.min;
    t.exports = r }, function(t, n, e) {
    function r(t, n, e, r) {
        function c() { for (var n = -1, a = arguments.length, u = -1, l = r.length, d = Array(l + a), h = this && this !== o && this instanceof c ? s : t; ++u < l;) d[u] = r[u]; for (; a--;) d[u++] = arguments[++n]; return i(h, f ? e : this, d) } var f = n & u,
            s = a(t); return c } var i = e(49),
        a = e(70),
        o = e(5),
        u = 1;
    t.exports = r }, function(t, n, e) {
    function r(t, n) { var e = t[1],
            r = n[1],
            b = e | r,
            v = b < (c | f | d),
            y = r == d && e == l || r == d && e == h && t[7].length <= n[8] || r == (d | h) && n[7].length <= n[8] && e == l; if (!v && !y) return t;
        r & c && (t[2] = n[2], b |= e & c ? 0 : s); var _ = n[3]; if (_) { var g = t[3];
            t[3] = g ? i(g, _, n[4]) : _, t[4] = g ? o(t[3], u) : n[4] } return _ = n[5], _ && (g = t[5], t[5] = g ? a(g, _, n[6]) : _, t[6] = g ? o(t[5], u) : n[6]), _ = n[7], _ && (t[7] = _), r & d && (t[8] = null == t[8] ? n[8] : p(t[8], n[8])), null == t[9] && (t[9] = n[9]), t[0] = n[0], t[1] = b, t } var i = e(209),
        a = e(210),
        o = e(114),
        u = "__lodash_placeholder__",
        c = 1,
        f = 2,
        s = 4,
        l = 8,
        d = 128,
        h = 256,
        p = Math.min;
    t.exports = r }, function(t, n, e) {
    function r(t) { if ("number" == typeof t) return t; if (a(t)) return o; if (i(t)) { var n = "function" == typeof t.valueOf ? t.valueOf() : t;
            t = i(n) ? n + "" : n } if ("string" != typeof t) return 0 === t ? t : +t;
        t = t.replace(u, ""); var e = f.test(t); return e || s.test(t) ? l(t.slice(2), e ? 2 : 8) : c.test(t) ? o : +t } var i = e(6),
        a = e(34),
        o = NaN,
        u = /^\s+|\s+$/g,
        c = /^[-+]0x[0-9a-f]+$/i,
        f = /^0b[01]+$/i,
        s = /^0o[0-7]+$/i,
        l = parseInt;
    t.exports = r }, function(t, n, e) {
    function r(t) { return i(t, a) } var i = e(94),
        a = 4;
    t.exports = r }, function(t, n, e) {
    function r(t, n, e) { n = e ? void 0 : n; var o = i(t, a, void 0, void 0, void 0, void 0, void 0, n); return o.placeholder = r.placeholder, o } var i = e(109),
        a = 8;
    r.placeholder = {}, t.exports = r }, function(t, n, e) {
    function r(t) { return a("function" == typeof t ? t : i(t, o)) } var i = e(94),
        a = e(33),
        o = 1;
    t.exports = r }, function(t, n, e) { var r = e(109),
        i = e(219),
        a = i(function(t, n) { return r(t, 256, void 0, void 0, void 0, n) });
    t.exports = a }, function(t, n, e) {
    function r(t) { return (null == t ? 0 : t.length) ? i(t, 1) : [] } var i = e(98);
    t.exports = r }, function(t, n, e) {
    function r(t) { return o(t) ? i(t, f) : u(t) ? [t] : a(c(s(t))) } var i = e(40),
        a = e(30),
        o = e(2),
        u = e(34),
        c = e(155),
        f = e(41),
        s = e(156);
    t.exports = r }, function(t, n, e) { var r = e(37),
        i = r("flow", e(489));
    i.placeholder = e(26), t.exports = i }, function(t, n, e) { var r = e(490),
        i = r();
    t.exports = i }, function(t, n, e) {
    function r(t) { return a(function(n) { var e = n.length,
                r = e,
                a = i.prototype.thru; for (t && n.reverse(); r--;) { var b = n[r]; if ("function" != typeof b) throw new TypeError(s); if (a && !v && "wrapper" == u(b)) var v = new i([], !0) } for (r = v ? r : e; ++r < e;) { b = n[r]; var y = u(b),
                    _ = "wrapper" == y ? o(b) : void 0;
                v = _ && f(_[0]) && _[1] == (h | l | d | p) && !_[4].length && 1 == _[9] ? v[u(_[0])].apply(v, _[3]) : 1 == b.length && f(b) ? v[y]() : v.thru(b) } return function() { var t = arguments,
                    r = t[0]; if (v && 1 == t.length && c(r)) return v.plant(r).value(); for (var i = 0, a = e ? n[i].apply(this, t) : r; ++i < e;) a = n[i].call(this, a); return a } }) } var i = e(113),
        a = e(219),
        o = e(112),
        u = e(213),
        c = e(2),
        f = e(212),
        s = "Expected a function",
        l = 8,
        d = 32,
        h = 128,
        p = 256;
    t.exports = r }, function(t, n, e) { var r = e(37),
        i = r("concat", e(492));
    i.placeholder = e(26), t.exports = i }, function(t, n, e) {
    function r() { var t = arguments.length; if (!t) return []; for (var n = Array(t - 1), e = arguments[0], r = t; r--;) n[r - 1] = arguments[r]; return i(u(e) ? o(e) : [e], a(n, 1)) } var i = e(63),
        a = e(98),
        o = e(30),
        u = e(2);
    t.exports = r }, function(t, n, e) { var r = e(37),
        i = r("filter", e(494));
    i.placeholder = e(26), t.exports = i }, function(t, n, e) {
    function r(t, n) { return (u(t) ? i : a)(t, o(n, 3)) } var i = e(147),
        a = e(495),
        o = e(33),
        u = e(2);
    t.exports = r }, function(t, n, e) {
    function r(t, n) { var e = []; return i(t, function(t, r, i) { n(t, r, i) && e.push(t) }), e } var i = e(39);
    t.exports = r }, function(t, n, e) { t.exports = e(497) }, function(t, n, e) { var r = e(37),
        i = r("head", e(498), e(499));
    i.placeholder = e(26), t.exports = i }, function(t, n) {
    function e(t) { return t && t.length ? t[0] : void 0 }
    t.exports = e }, function(t, n) { t.exports = { cap: !1, curry: !1, fixed: !1, immutable: !1, rearg: !1 } }, function(t, n, e) { var r = e(37),
        i = r("reverse", e(501));
    i.placeholder = e(26), t.exports = i }, function(t, n) {
    function e(t) { return null == t ? t : i.call(t) } var r = Array.prototype,
        i = r.reverse;
    t.exports = e }, function(t, n, e) { "use strict";

    function r() {
        function t() { var t = a().length,
                r = f[1] < f[0],
                i = f[r - 0],
                u = f[1 - r];
            n = (u - i) / Math.max(1, t - l + 2 * d), s && (n = Math.floor(n)), i += (u - i - n * (t - l)) * h, e = n * (1 - l), s && (i = Math.round(i), e = Math.round(e)); var p = Object(o.range)(t).map(function(t) { return i + n * t }); return c(r ? p.reverse() : p) } var n, e, i = Object(u.a)().unknown(void 0),
            a = i.domain,
            c = i.range,
            f = [0, 1],
            s = !1,
            l = 0,
            d = 0,
            h = .5; return delete i.unknown, i.domain = function(n) { return arguments.length ? (a(n), t()) : a() }, i.range = function(n) { return arguments.length ? (f = [+n[0], +n[1]], t()) : f.slice() }, i.rangeRound = function(n) { return f = [+n[0], +n[1]], s = !0, t() }, i.bandwidth = function() { return e }, i.step = function() { return n }, i.round = function(n) { return arguments.length ? (s = !!n, t()) : s }, i.padding = function(n) { return arguments.length ? (l = d = Math.max(0, Math.min(1, n)), t()) : l }, i.paddingInner = function(n) { return arguments.length ? (l = Math.max(0, Math.min(1, n)), t()) : l }, i.paddingOuter = function(n) { return arguments.length ? (d = Math.max(0, Math.min(1, n)), t()) : d }, i.align = function(n) { return arguments.length ? (h = Math.max(0, Math.min(1, n)), t()) : h }, i.copy = function() { return r().domain(a()).range(f).round(s).paddingInner(l).paddingOuter(d).align(h) }, t() }

    function i(t) { var n = t.copy; return t.padding = t.paddingOuter, delete t.paddingInner, delete t.paddingOuter, t.copy = function() { return i(n()) }, t }

    function a() { return i(r().paddingInner(1)) }
    n.a = r, n.b = a; var o = e(7),
        u = e(221) }, function(t, n, e) { "use strict";

    function r() { return {} }

    function i(t, n, e) { t[n] = e }

    function a() { return Object(u.a)() }

    function o(t, n, e) { t.set(n, e) } var u = e(116);
    n.a = function() {
        function t(n, r, i, a) { if (r >= s.length) return null != e && n.sort(e), null != c ? c(n) : n; for (var o, f, l, d = -1, h = n.length, p = s[r++], b = Object(u.a)(), v = i(); ++d < h;)(l = b.get(o = p(f = n[d]) + "")) ? l.push(f) : b.set(o, [f]); return b.each(function(n, e) { a(v, e, t(n, r, i, a)) }), v }

        function n(t, e) { if (++e > s.length) return t; var r, i = l[e - 1]; return null != c && e >= s.length ? r = t.entries() : (r = [], t.each(function(t, i) { r.push({ key: i, values: n(t, e) }) })), null != i ? r.sort(function(t, n) { return i(t.key, n.key) }) : r } var e, c, f, s = [],
            l = []; return f = { object: function(n) { return t(n, 0, r, i) }, map: function(n) { return t(n, 0, a, o) }, entries: function(e) { return n(t(e, 0, a, o), 0) }, key: function(t) { return s.push(t), f }, sortKeys: function(t) { return l[s.length - 1] = t, f }, sortValues: function(t) { return e = t, f }, rollup: function(t) { return c = t, f } } } }, function(t, n, e) { "use strict";

    function r() {}

    function i(t, n) { var e = new r; if (t instanceof r) t.each(function(t) { e.add(t) });
        else if (t) { var i = -1,
                a = t.length; if (null == n)
                for (; ++i < a;) e.add(t[i]);
            else
                for (; ++i < a;) e.add(n(t[i], i, t)) } return e } var a = e(116),
        o = a.a.prototype;
    r.prototype = i.prototype = { constructor: r, has: o.has, add: function(t) { return t += "", this[a.b + t] = t, this }, remove: o.remove, clear: o.clear, values: o.keys, size: o.size, empty: o.empty, each: o.each }, n.a = i }, function(t, n, e) { "use strict";
    n.a = function(t) { var n = []; for (var e in t) n.push(e); return n } }, function(t, n, e) { "use strict";
    n.a = function(t) { var n = []; for (var e in t) n.push(t[e]); return n } }, function(t, n, e) { "use strict";
    n.a = function(t) { var n = []; for (var e in t) n.push({ key: e, value: t[e] }); return n } }, function(t, n, e) { "use strict";

    function r() {
        function t(t) { return +t } var n = [0, 1]; return t.invert = t, t.domain = t.range = function(e) { return arguments.length ? (n = i.a.call(e, o.a), t) : n.slice() }, t.copy = function() { return r().domain(n) }, Object(a.b)(t) }
    n.a = r; var i = e(27),
        a = e(47),
        o = e(223) }, function(t, n, e) { "use strict"; var r = e(7),
        i = e(224);
    n.a = function(t, n, e) { var a, o = t[0],
            u = t[t.length - 1],
            c = Object(r.tickStep)(o, u, null == n ? 10 : n); switch (e = Object(i.c)(null == e ? ",f" : e), e.type) {
            case "s":
                var f = Math.max(Math.abs(o), Math.abs(u)); return null != e.precision || isNaN(a = Object(i.e)(c, f)) || (e.precision = a), Object(i.b)(e, f);
            case "":
            case "e":
            case "g":
            case "p":
            case "r":
                null != e.precision || isNaN(a = Object(i.f)(c, Math.max(Math.abs(o), Math.abs(u)))) || (e.precision = a - ("e" === e.type)); break;
            case "f":
            case "%":
                null != e.precision || isNaN(a = Object(i.d)(c)) || (e.precision = a - 2 * ("%" === e.type)) } return Object(i.a)(e) } }, function(t, n, e) { "use strict";
    e.d(n, "a", function() { return i }), e.d(n, "b", function() { return a }); var r, i, a, o = e(225);! function(t) { r = Object(o.a)(t), i = r.format, a = r.formatPrefix }({ decimal: ".", thousands: ",", grouping: [3], currency: ["$", ""] }) }, function(t, n, e) { "use strict";
    n.a = function(t, n) { return function(e, r) { for (var i = e.length, a = [], o = 0, u = t[0], c = 0; i > 0 && u > 0 && (c + u + 1 > r && (u = Math.max(1, r - c)), a.push(e.substring(i -= u, i + u)), !((c += u + 1) > r));) u = t[o = (o + 1) % t.length]; return a.reverse().join(n) } } }, function(t, n, e) { "use strict";
    n.a = function(t) { return function(n) { return n.replace(/[0-9]/g, function(n) { return t[+n] }) } } }, function(t, n, e) { "use strict";
    n.a = function(t, n) { t = t.toPrecision(n);
        t: for (var e, r = t.length, i = 1, a = -1; i < r; ++i) switch (t[i]) {
            case ".":
                a = e = i; break;
            case "0":
                0 === a && (a = i), e = i; break;
            case "e":
                break t;
            default:
                a > 0 && (a = 0) }
        return a > 0 ? t.slice(0, a) + t.slice(e + 1) : t } }, function(t, n, e) { "use strict"; var r = e(118);
    n.a = function(t, n) { var e = Object(r.a)(t, n); if (!e) return t + ""; var i = e[0],
            a = e[1]; return a < 0 ? "0." + new Array(-a).join("0") + i : i.length > a + 1 ? i.slice(0, a + 1) + "." + i.slice(a + 1) : i + new Array(a - i.length + 2).join("0") } }, function(t, n, e) { "use strict";
    n.a = function(t) { return t } }, function(t, n, e) { "use strict"; var r = e(72);
    n.a = function(t) { return Math.max(0, -Object(r.a)(Math.abs(t))) } }, function(t, n, e) { "use strict"; var r = e(72);
    n.a = function(t, n) { return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor(Object(r.a)(n) / 3))) - Object(r.a)(Math.abs(t))) } }, function(t, n, e) { "use strict"; var r = e(72);
    n.a = function(t, n) { return t = Math.abs(t), n = Math.abs(n) - t, Math.max(0, Object(r.a)(n) - Object(r.a)(t)) + 1 } }, function(t, n, e) { "use strict";

    function r(t, n) { return (n = Math.log(n / t)) ? function(e) { return Math.log(e / t) / n } : Object(d.a)(n) }

    function i(t, n) { return t < 0 ? function(e) { return -Math.pow(-n, e) * Math.pow(-t, 1 - e) } : function(e) { return Math.pow(n, e) * Math.pow(t, 1 - e) } }

    function a(t) { return isFinite(t) ? +("1e" + t) : t < 0 ? 0 : t }

    function o(t) { return 10 === t ? a : t === Math.E ? Math.exp : function(n) { return Math.pow(t, n) } }

    function u(t) { return t === Math.E ? Math.log : 10 === t && Math.log10 || 2 === t && Math.log2 || (t = Math.log(t), function(n) { return Math.log(n) / t }) }

    function c(t) { return function(n) { return -t(-n) } }

    function f() {
        function t() { return d = u(a), b = o(a), e()[0] < 0 && (d = c(d), b = c(b)), n } var n = Object(p.b)(r, i).domain([1, 10]),
            e = n.domain,
            a = 10,
            d = u(10),
            b = o(10); return n.base = function(n) { return arguments.length ? (a = +n, t()) : a }, n.domain = function(n) { return arguments.length ? (e(n), t()) : e() }, n.ticks = function(t) { var n, r = e(),
                i = r[0],
                o = r[r.length - 1];
            (n = o < i) && (l = i, i = o, o = l); var u, c, f, l = d(i),
                h = d(o),
                p = null == t ? 10 : +t,
                v = []; if (!(a % 1) && h - l < p) { if (l = Math.round(l) - 1, h = Math.round(h) + 1, i > 0) { for (; l < h; ++l)
                        for (c = 1, u = b(l); c < a; ++c)
                            if (!((f = u * c) < i)) { if (f > o) break;
                                v.push(f) } } else
                    for (; l < h; ++l)
                        for (c = a - 1, u = b(l); c >= 1; --c)
                            if (!((f = u * c) < i)) { if (f > o) break;
                                v.push(f) } } else v = Object(s.ticks)(l, h, Math.min(h - l, p)).map(b); return n ? v.reverse() : v }, n.tickFormat = function(t, e) { if (null == e && (e = 10 === a ? ".0e" : ","), "function" != typeof e && (e = Object(l.a)(e)), t === 1 / 0) return e;
            null == t && (t = 10); var r = Math.max(1, a * t / n.ticks().length); return function(t) { var n = t / b(Math.round(d(t))); return n * a < a - .5 && (n *= a), n <= r ? e(t) : "" } }, n.nice = function() { return e(Object(h.a)(e(), { floor: function(t) { return b(Math.floor(d(t))) }, ceil: function(t) { return b(Math.ceil(d(t))) } })) }, n.copy = function() { return Object(p.a)(n, f().base(a)) }, n }
    n.a = f; var s = e(7),
        l = e(224),
        d = e(117),
        h = e(229),
        p = e(71) }, function(t, n, e) { "use strict";

    function r(t, n) { return t < 0 ? -Math.pow(-t, n) : Math.pow(t, n) }

    function i() {
        function t(t, n) { return (n = r(n, e) - (t = r(t, e))) ? function(i) { return (r(i, e) - t) / n } : Object(o.a)(n) }

        function n(t, n) { return n = r(n, e) - (t = r(t, e)),
                function(i) { return r(t + n * i, 1 / e) } } var e = 1,
            a = Object(c.b)(t, n),
            f = a.domain; return a.exponent = function(t) { return arguments.length ? (e = +t, f(f())) : e }, a.copy = function() { return Object(c.a)(a, i().exponent(e)) }, Object(u.b)(a) }

    function a() { return i().exponent(.5) }
    n.a = i, n.b = a; var o = e(117),
        u = e(47),
        c = e(71) }, function(t, n, e) { "use strict";

    function r() {
        function t() { var t = 0,
                r = Math.max(1, o.length); for (u = new Array(r - 1); ++t < r;) u[t - 1] = Object(i.quantile)(e, t / r); return n }

        function n(t) { if (!isNaN(t = +t)) return o[Object(i.bisect)(u, t)] } var e = [],
            o = [],
            u = []; return n.invertExtent = function(t) { var n = o.indexOf(t); return n < 0 ? [NaN, NaN] : [n > 0 ? u[n - 1] : e[0], n < u.length ? u[n] : e[e.length - 1]] }, n.domain = function(n) { if (!arguments.length) return e.slice();
            e = []; for (var r, a = 0, o = n.length; a < o; ++a) null == (r = n[a]) || isNaN(r = +r) || e.push(r); return e.sort(i.ascending), t() }, n.range = function(n) { return arguments.length ? (o = a.b.call(n), t()) : o.slice() }, n.quantiles = function() { return u.slice() }, n.copy = function() { return r().domain(e).range(o) }, n }
    n.a = r; var i = e(7),
        a = e(27) }, function(t, n, e) { "use strict";

    function r() {
        function t(t) { if (t <= t) return s[Object(i.bisect)(f, t, 0, c)] }

        function n() { var n = -1; for (f = new Array(c); ++n < c;) f[n] = ((n + 1) * u - (n - c) * e) / (c + 1); return t } var e = 0,
            u = 1,
            c = 1,
            f = [.5],
            s = [0, 1]; return t.domain = function(t) { return arguments.length ? (e = +t[0], u = +t[1], n()) : [e, u] }, t.range = function(t) { return arguments.length ? (c = (s = a.b.call(t)).length - 1, n()) : s.slice() }, t.invertExtent = function(t) { var n = s.indexOf(t); return n < 0 ? [NaN, NaN] : n < 1 ? [e, f[0]] : n >= c ? [f[c - 1], u] : [f[n - 1], f[n]] }, t.copy = function() { return r().domain([e, u]).range(s) }, Object(o.b)(t) }
    n.a = r; var i = e(7),
        a = e(27),
        o = e(47) }, function(t, n, e) { "use strict";

    function r() {
        function t(t) { if (t <= t) return e[Object(i.bisect)(n, t, 0, o)] } var n = [.5],
            e = [0, 1],
            o = 1; return t.domain = function(r) { return arguments.length ? (n = a.b.call(r), o = Math.min(n.length, e.length - 1), t) : n.slice() }, t.range = function(r) { return arguments.length ? (e = a.b.call(r), o = Math.min(n.length, e.length - 1), t) : e.slice() }, t.invertExtent = function(t) { var r = e.indexOf(t); return [n[r - 1], n[r]] }, t.copy = function() { return r().domain(n).range(e) }, t }
    n.a = r; var i = e(7),
        a = e(27) }, function(t, n, e) { "use strict"; var r = e(4),
        i = Object(r.a)(function() {}, function(t, n) { t.setTime(+t + n) }, function(t, n) { return n - t });
    i.every = function(t) { return t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? Object(r.a)(function(n) { n.setTime(Math.floor(n / t) * t) }, function(n, e) { n.setTime(+n + e * t) }, function(n, e) { return (e - n) / t }) : i : null }, n.a = i;
    i.range }, function(t, n, e) { "use strict"; var r = e(4),
        i = e(15),
        a = Object(r.a)(function(t) { t.setTime(Math.floor(t / i.d) * i.d) }, function(t, n) { t.setTime(+t + n * i.d) }, function(t, n) { return (n - t) / i.d }, function(t) { return t.getUTCSeconds() });
    n.a = a;
    a.range }, function(t, n, e) { "use strict"; var r = e(4),
        i = e(15),
        a = Object(r.a)(function(t) { t.setTime(Math.floor(t / i.c) * i.c) }, function(t, n) { t.setTime(+t + n * i.c) }, function(t, n) { return (n - t) / i.c }, function(t) { return t.getMinutes() });
    n.a = a;
    a.range }, function(t, n, e) { "use strict"; var r = e(4),
        i = e(15),
        a = Object(r.a)(function(t) { var n = t.getTimezoneOffset() * i.c % i.b;
            n < 0 && (n += i.b), t.setTime(Math.floor((+t - n) / i.b) * i.b + n) }, function(t, n) { t.setTime(+t + n * i.b) }, function(t, n) { return (n - t) / i.b }, function(t) { return t.getHours() });
    n.a = a;
    a.range }, function(t, n, e) { "use strict"; var r = e(4),
        i = e(15),
        a = Object(r.a)(function(t) { t.setHours(0, 0, 0, 0) }, function(t, n) { t.setDate(t.getDate() + n) }, function(t, n) { return (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * i.c) / i.a }, function(t) { return t.getDate() - 1 });
    n.a = a;
    a.range }, function(t, n, e) { "use strict";

    function r(t) { return Object(i.a)(function(n) { n.setDate(n.getDate() - (n.getDay() + 7 - t) % 7), n.setHours(0, 0, 0, 0) }, function(t, n) { t.setDate(t.getDate() + 7 * n) }, function(t, n) { return (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * a.c) / a.e }) }
    e.d(n, "b", function() { return o }), e.d(n, "a", function() { return u }); var i = e(4),
        a = e(15),
        o = r(0),
        u = r(1),
        c = r(2),
        f = r(3),
        s = r(4),
        l = r(5),
        d = r(6);
    o.range, u.range, c.range, f.range, s.range, l.range, d.range }, function(t, n, e) { "use strict"; var r = e(4),
        i = Object(r.a)(function(t) { t.setDate(1), t.setHours(0, 0, 0, 0) }, function(t, n) { t.setMonth(t.getMonth() + n) }, function(t, n) { return n.getMonth() - t.getMonth() + 12 * (n.getFullYear() - t.getFullYear()) }, function(t) { return t.getMonth() });
    n.a = i;
    i.range }, function(t, n, e) { "use strict"; var r = e(4),
        i = Object(r.a)(function(t) { t.setMonth(0, 1), t.setHours(0, 0, 0, 0) }, function(t, n) { t.setFullYear(t.getFullYear() + n) }, function(t, n) { return n.getFullYear() - t.getFullYear() }, function(t) { return t.getFullYear() });
    i.every = function(t) { return isFinite(t = Math.floor(t)) && t > 0 ? Object(r.a)(function(n) { n.setFullYear(Math.floor(n.getFullYear() / t) * t), n.setMonth(0, 1), n.setHours(0, 0, 0, 0) }, function(n, e) { n.setFullYear(n.getFullYear() + e * t) }) : null }, n.a = i;
    i.range }, function(t, n, e) { "use strict"; var r = e(4),
        i = e(15),
        a = Object(r.a)(function(t) { t.setUTCSeconds(0, 0) }, function(t, n) { t.setTime(+t + n * i.c) }, function(t, n) { return (n - t) / i.c }, function(t) { return t.getUTCMinutes() });
    n.a = a;
    a.range }, function(t, n, e) { "use strict"; var r = e(4),
        i = e(15),
        a = Object(r.a)(function(t) { t.setUTCMinutes(0, 0, 0) }, function(t, n) { t.setTime(+t + n * i.b) }, function(t, n) { return (n - t) / i.b }, function(t) { return t.getUTCHours() });
    n.a = a;
    a.range }, function(t, n, e) { "use strict"; var r = e(4),
        i = e(15),
        a = Object(r.a)(function(t) { t.setUTCHours(0, 0, 0, 0) }, function(t, n) { t.setUTCDate(t.getUTCDate() + n) }, function(t, n) { return (n - t) / i.a }, function(t) { return t.getUTCDate() - 1 });
    n.a = a;
    a.range }, function(t, n, e) { "use strict";

    function r(t) { return Object(i.a)(function(n) { n.setUTCDate(n.getUTCDate() - (n.getUTCDay() + 7 - t) % 7), n.setUTCHours(0, 0, 0, 0) }, function(t, n) { t.setUTCDate(t.getUTCDate() + 7 * n) }, function(t, n) { return (n - t) / a.e }) }
    e.d(n, "b", function() { return o }), e.d(n, "a", function() { return u }); var i = e(4),
        a = e(15),
        o = r(0),
        u = r(1),
        c = r(2),
        f = r(3),
        s = r(4),
        l = r(5),
        d = r(6);
    o.range, u.range, c.range, f.range, s.range, l.range, d.range }, function(t, n, e) { "use strict"; var r = e(4),
        i = Object(r.a)(function(t) { t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0) }, function(t, n) { t.setUTCMonth(t.getUTCMonth() + n) }, function(t, n) { return n.getUTCMonth() - t.getUTCMonth() + 12 * (n.getUTCFullYear() - t.getUTCFullYear()) }, function(t) { return t.getUTCMonth() });
    n.a = i;
    i.range }, function(t, n, e) { "use strict"; var r = e(4),
        i = Object(r.a)(function(t) { t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0) }, function(t, n) { t.setUTCFullYear(t.getUTCFullYear() + n) }, function(t, n) { return n.getUTCFullYear() - t.getUTCFullYear() }, function(t) { return t.getUTCFullYear() });
    i.every = function(t) { return isFinite(t = Math.floor(t)) && t > 0 ? Object(r.a)(function(n) { n.setUTCFullYear(Math.floor(n.getUTCFullYear() / t) * t), n.setUTCMonth(0, 1), n.setUTCHours(0, 0, 0, 0) }, function(n, e) { n.setUTCFullYear(n.getUTCFullYear() + e * t) }) : null }, n.a = i;
    i.range }, function(t, n, e) { "use strict";

    function r(t) { var n = new Date(t); return isNaN(n) ? null : n } var i = e(233),
        a = e(120); + new Date("2000-01-01T00:00:00.000Z") || Object(a.c)(i.a) }, function(t, n, e) { "use strict"; var r = e(230),
        i = e(231),
        a = e(119);
    n.a = function() { return Object(r.a)(a.t, a.p, a.s, a.k, a.l, a.n, a.q, a.m, i.b).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]) } }, function(t, n, e) { "use strict"; var r = e(48);
    n.a = Object(r.a)("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf") }, function(t, n, e) { "use strict"; var r = e(48);
    n.a = Object(r.a)("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6") }, function(t, n, e) { "use strict"; var r = e(48);
    n.a = Object(r.a)("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9") }, function(t, n, e) { "use strict"; var r = e(48);
    n.a = Object(r.a)("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5") }, function(t, n, e) { "use strict"; var r = e(13),
        i = e(12);
    n.a = Object(i.b)(Object(r.b)(300, .5, 0), Object(r.b)(-240, .5, 1)) }, function(t, n, e) { "use strict";
    e.d(n, "c", function() { return a }), e.d(n, "a", function() { return o }); var r = e(13),
        i = e(12),
        a = Object(i.b)(Object(r.b)(-100, .75, .35), Object(r.b)(80, 1.5, .8)),
        o = Object(i.b)(Object(r.b)(260, .75, .35), Object(r.b)(80, 1.5, .8)),
        u = Object(r.b)();
    n.b = function(t) {
        (t < 0 || t > 1) && (t -= Math.floor(t)); var n = Math.abs(t - .5); return u.h = 360 * t - 100, u.s = 1.5 - 1.5 * n, u.l = .8 - .9 * n, u + "" } }, function(t, n, e) { "use strict";

    function r(t) { var n = t.length; return function(e) { return t[Math.max(0, Math.min(n - 1, Math.floor(e * n)))] } }
    e.d(n, "c", function() { return a }), e.d(n, "b", function() { return o }), e.d(n, "d", function() { return u }); var i = e(48);
    n.a = r(Object(i.a)("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")); var a = r(Object(i.a)("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")),
        o = r(Object(i.a)("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")),
        u = r(Object(i.a)("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921")) }, function(t, n, e) { "use strict";

    function r(t) {
        function n(n) { var r = (n - e) / (a - e); return t(o ? Math.max(0, Math.min(1, r)) : r) } var e = 0,
            a = 1,
            o = !1; return n.domain = function(t) { return arguments.length ? (e = +t[0], a = +t[1], n) : [e, a] }, n.clamp = function(t) { return arguments.length ? (o = !!t, n) : o }, n.interpolator = function(e) { return arguments.length ? (t = e, n) : t }, n.copy = function() { return r(t).domain([e, a]).clamp(o) }, Object(i.b)(n) }
    n.a = r; var i = e(47) }, function(t, n, e) { "use strict";

    function r(t) { var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
            e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
            r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
            i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Math.E; if ((0, a.default)(t)) return t; var o = "-" === t[0],
            u = "-" === t[0] ? t.slice(1) : t; if (c[u]) { var s = f(c[u], n, e, o, r, i); return function(t) { return s(t.value) } } return t }
    Object.defineProperty(n, "__esModule", { value: !0 }), n.buildColorValue = r; var i = e(23),
        a = function(t) { return t && t.__esModule ? t : { default: t } }(i),
        o = e(220),
        u = e(549),
        c = { BrBG: u.interpolateBrBG, PRGn: u.interpolatePRGn, PiYG: u.interpolatePiYG, PuOr: u.interpolatePuOr, RdBu: u.interpolateRdBu, RdGy: u.interpolateRdGy, RdYlBu: u.interpolateRdYlBu, RdYlGn: u.interpolateRdYlGn, Spectral: u.interpolateSpectral, Blues: u.interpolateBlues, Greens: u.interpolateGreens, Greys: u.interpolateGreys, Oranges: u.interpolateOranges, Purples: u.interpolatePurples, Reds: u.interpolateReds, BuGn: u.interpolateBuGn, BuPu: u.interpolateBuPu, GnBu: u.interpolateGnBu, OrRd: u.interpolateOrRd, PuBuGn: u.interpolatePuBuGn, PuBu: u.interpolatePuBu, PuRd: u.interpolatePuRd, RdPu: u.interpolateRdPu, YlGnBu: u.interpolateYlGnBu, YlGn: u.interpolateYlGn, YlOrBr: u.interpolateYlOrBr, YlOrRd: u.interpolateYlOrRd },
        f = function(t, n, e) { var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
                a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : Math.E; if (i && n * e <= 0 && console.warn("As log(0) = -, a log scale domain must be\n      strictly-positive or strictly-negative. logscale ignored"), i && n * e > 0) { var u = (0, o.scaleLog)().base(a).domain(r ? [e, n] : [n, e]).range([0, 1]); return (0, o.scaleSequential)(function(n) { return t(u(n)) }).domain([0, 1]) } return (0, o.scaleSequential)(t).domain(r ? [e, n] : [n, e]) } }, function(t, n, e) { "use strict";
    Object.defineProperty(n, "__esModule", { value: !0 }); var r = e(550);
    e.d(n, "schemeAccent", function() { return r.a }); var i = e(551);
    e.d(n, "schemeDark2", function() { return i.a }); var a = e(552);
    e.d(n, "schemePaired", function() { return a.a }); var o = e(553);
    e.d(n, "schemePastel1", function() { return o.a }); var u = e(554);
    e.d(n, "schemePastel2", function() { return u.a }); var c = e(555);
    e.d(n, "schemeSet1", function() { return c.a }); var f = e(556);
    e.d(n, "schemeSet2", function() { return f.a }); var s = e(557);
    e.d(n, "schemeSet3", function() { return s.a }); var l = e(558);
    e.d(n, "interpolateBrBG", function() { return l.a }), e.d(n, "schemeBrBG", function() { return l.b }); var d = e(559);
    e.d(n, "interpolatePRGn", function() { return d.a }), e.d(n, "schemePRGn", function() { return d.b }); var h = e(560);
    e.d(n, "interpolatePiYG", function() { return h.a }), e.d(n, "schemePiYG", function() { return h.b }); var p = e(561);
    e.d(n, "interpolatePuOr", function() { return p.a }), e.d(n, "schemePuOr", function() { return p.b }); var b = e(562);
    e.d(n, "interpolateRdBu", function() { return b.a }), e.d(n, "schemeRdBu", function() { return b.b }); var v = e(563);
    e.d(n, "interpolateRdGy", function() { return v.a }), e.d(n, "schemeRdGy", function() { return v.b }); var y = e(564);
    e.d(n, "interpolateRdYlBu", function() { return y.a }), e.d(n, "schemeRdYlBu", function() { return y.b }); var _ = e(565);
    e.d(n, "interpolateRdYlGn", function() { return _.a }), e.d(n, "schemeRdYlGn", function() { return _.b }); var g = e(566);
    e.d(n, "interpolateSpectral", function() { return g.a }), e.d(n, "schemeSpectral", function() { return g.b }); var m = e(567);
    e.d(n, "interpolateBuGn", function() { return m.a }), e.d(n, "schemeBuGn", function() { return m.b }); var x = e(568);
    e.d(n, "interpolateBuPu", function() { return x.a }), e.d(n, "schemeBuPu", function() { return x.b }); var w = e(569);
    e.d(n, "interpolateGnBu", function() { return w.a }), e.d(n, "schemeGnBu", function() { return w.b }); var j = e(570);
    e.d(n, "interpolateOrRd", function() { return j.a }), e.d(n, "schemeOrRd", function() { return j.b }); var O = e(571);
    e.d(n, "interpolatePuBuGn", function() { return O.a }), e.d(n, "schemePuBuGn", function() { return O.b }); var M = e(572);
    e.d(n, "interpolatePuBu", function() { return M.a }), e.d(n, "schemePuBu", function() { return M.b }); var k = e(573);
    e.d(n, "interpolatePuRd", function() { return k.a }), e.d(n, "schemePuRd", function() { return k.b }); var A = e(574);
    e.d(n, "interpolateRdPu", function() { return A.a }), e.d(n, "schemeRdPu", function() { return A.b }); var T = e(575);
    e.d(n, "interpolateYlGnBu", function() { return T.a }), e.d(n, "schemeYlGnBu", function() { return T.b }); var R = e(576);
    e.d(n, "interpolateYlGn", function() { return R.a }), e.d(n, "schemeYlGn", function() { return R.b }); var P = e(577);
    e.d(n, "interpolateYlOrBr", function() { return P.a }), e.d(n, "schemeYlOrBr", function() { return P.b }); var S = e(578);
    e.d(n, "interpolateYlOrRd", function() { return S.a }), e.d(n, "schemeYlOrRd", function() { return S.b }); var C = e(579);
    e.d(n, "interpolateBlues", function() { return C.a }), e.d(n, "schemeBlues", function() { return C.b }); var E = e(580);
    e.d(n, "interpolateGreens", function() { return E.a }), e.d(n, "schemeGreens", function() { return E.b }); var N = e(581);
    e.d(n, "interpolateGreys", function() { return N.a }), e.d(n, "schemeGreys", function() { return N.b }); var I = e(582);
    e.d(n, "interpolatePurples", function() { return I.a }), e.d(n, "schemePurples", function() { return I.b }); var D = e(583);
    e.d(n, "interpolateReds", function() { return D.a }), e.d(n, "schemeReds", function() { return D.b }); var B = e(584);
    e.d(n, "interpolateOranges", function() { return B.a }), e.d(n, "schemeOranges", function() { return B.b }) }, function(t, n, e) { "use strict"; var r = e(0);
    n.a = Object(r.a)("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666") }, function(t, n, e) { "use strict"; var r = e(0);
    n.a = Object(r.a)("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666") }, function(t, n, e) { "use strict"; var r = e(0);
    n.a = Object(r.a)("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928") }, function(t, n, e) { "use strict"; var r = e(0);
    n.a = Object(r.a)("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2") }, function(t, n, e) { "use strict"; var r = e(0);
    n.a = Object(r.a)("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc") }, function(t, n, e) { "use strict"; var r = e(0);
    n.a = Object(r.a)("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999") }, function(t, n, e) { "use strict"; var r = e(0);
    n.a = Object(r.a)("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3") }, function(t, n, e) { "use strict"; var r = e(0);
    n.a = Object(r.a)("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f") }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("d8b365f5f5f55ab4ac", "a6611adfc27d80cdc1018571", "a6611adfc27df5f5f580cdc1018571", "8c510ad8b365f6e8c3c7eae55ab4ac01665e", "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e", "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e", "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e", "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30", "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("af8dc3f7f7f77fbf7b", "7b3294c2a5cfa6dba0008837", "7b3294c2a5cff7f7f7a6dba0008837", "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837", "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837", "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837", "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837", "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b", "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("e9a3c9f7f7f7a1d76a", "d01c8bf1b6dab8e1864dac26", "d01c8bf1b6daf7f7f7b8e1864dac26", "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221", "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221", "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221", "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221", "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419", "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("998ec3f7f7f7f1a340", "5e3c99b2abd2fdb863e66101", "5e3c99b2abd2f7f7f7fdb863e66101", "542788998ec3d8daebfee0b6f1a340b35806", "542788998ec3d8daebf7f7f7fee0b6f1a340b35806", "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806", "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806", "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08", "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("ef8a62f7f7f767a9cf", "ca0020f4a58292c5de0571b0", "ca0020f4a582f7f7f792c5de0571b0", "b2182bef8a62fddbc7d1e5f067a9cf2166ac", "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac", "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac", "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac", "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061", "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("ef8a62ffffff999999", "ca0020f4a582bababa404040", "ca0020f4a582ffffffbababa404040", "b2182bef8a62fddbc7e0e0e09999994d4d4d", "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d", "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d", "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d", "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a", "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("fc8d59ffffbf91bfdb", "d7191cfdae61abd9e92c7bb6", "d7191cfdae61ffffbfabd9e92c7bb6", "d73027fc8d59fee090e0f3f891bfdb4575b4", "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4", "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4", "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4", "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695", "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("fc8d59ffffbf91cf60", "d7191cfdae61a6d96a1a9641", "d7191cfdae61ffffbfa6d96a1a9641", "d73027fc8d59fee08bd9ef8b91cf601a9850", "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850", "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850", "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850", "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837", "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("fc8d59ffffbf99d594", "d7191cfdae61abdda42b83ba", "d7191cfdae61ffffbfabdda42b83ba", "d53e4ffc8d59fee08be6f59899d5943288bd", "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd", "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd", "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd", "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2", "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("e5f5f999d8c92ca25f", "edf8fbb2e2e266c2a4238b45", "edf8fbb2e2e266c2a42ca25f006d2c", "edf8fbccece699d8c966c2a42ca25f006d2c", "edf8fbccece699d8c966c2a441ae76238b45005824", "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824", "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("e0ecf49ebcda8856a7", "edf8fbb3cde38c96c688419d", "edf8fbb3cde38c96c68856a7810f7c", "edf8fbbfd3e69ebcda8c96c68856a7810f7c", "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b", "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b", "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("e0f3dba8ddb543a2ca", "f0f9e8bae4bc7bccc42b8cbe", "f0f9e8bae4bc7bccc443a2ca0868ac", "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac", "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e", "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e", "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("fee8c8fdbb84e34a33", "fef0d9fdcc8afc8d59d7301f", "fef0d9fdcc8afc8d59e34a33b30000", "fef0d9fdd49efdbb84fc8d59e34a33b30000", "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000", "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000", "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("ece2f0a6bddb1c9099", "f6eff7bdc9e167a9cf02818a", "f6eff7bdc9e167a9cf1c9099016c59", "f6eff7d0d1e6a6bddb67a9cf1c9099016c59", "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450", "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450", "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("ece7f2a6bddb2b8cbe", "f1eef6bdc9e174a9cf0570b0", "f1eef6bdc9e174a9cf2b8cbe045a8d", "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d", "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b", "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b", "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("e7e1efc994c7dd1c77", "f1eef6d7b5d8df65b0ce1256", "f1eef6d7b5d8df65b0dd1c77980043", "f1eef6d4b9dac994c7df65b0dd1c77980043", "f1eef6d4b9dac994c7df65b0e7298ace125691003f", "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f", "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("fde0ddfa9fb5c51b8a", "feebe2fbb4b9f768a1ae017e", "feebe2fbb4b9f768a1c51b8a7a0177", "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177", "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177", "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177", "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("edf8b17fcdbb2c7fb8", "ffffcca1dab441b6c4225ea8", "ffffcca1dab441b6c42c7fb8253494", "ffffccc7e9b47fcdbb41b6c42c7fb8253494", "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84", "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84", "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("f7fcb9addd8e31a354", "ffffccc2e69978c679238443", "ffffccc2e69978c67931a354006837", "ffffccd9f0a3addd8e78c67931a354006837", "ffffccd9f0a3addd8e78c67941ab5d238443005a32", "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32", "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("fff7bcfec44fd95f0e", "ffffd4fed98efe9929cc4c02", "ffffd4fed98efe9929d95f0e993404", "ffffd4fee391fec44ffe9929d95f0e993404", "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04", "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04", "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("ffeda0feb24cf03b20", "ffffb2fecc5cfd8d3ce31a1c", "ffffb2fecc5cfd8d3cf03b20bd0026", "ffffb2fed976feb24cfd8d3cf03b20bd0026", "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026", "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026", "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("deebf79ecae13182bd", "eff3ffbdd7e76baed62171b5", "eff3ffbdd7e76baed63182bd08519c", "eff3ffc6dbef9ecae16baed63182bd08519c", "eff3ffc6dbef9ecae16baed64292c62171b5084594", "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594", "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("e5f5e0a1d99b31a354", "edf8e9bae4b374c476238b45", "edf8e9bae4b374c47631a354006d2c", "edf8e9c7e9c0a1d99b74c47631a354006d2c", "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32", "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32", "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("f0f0f0bdbdbd636363", "f7f7f7cccccc969696525252", "f7f7f7cccccc969696636363252525", "f7f7f7d9d9d9bdbdbd969696636363252525", "f7f7f7d9d9d9bdbdbd969696737373525252252525", "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525", "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("efedf5bcbddc756bb1", "f2f0f7cbc9e29e9ac86a51a3", "f2f0f7cbc9e29e9ac8756bb154278f", "f2f0f7dadaebbcbddc9e9ac8756bb154278f", "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486", "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486", "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("fee0d2fc9272de2d26", "fee5d9fcae91fb6a4acb181d", "fee5d9fcae91fb6a4ade2d26a50f15", "fee5d9fcbba1fc9272fb6a4ade2d26a50f15", "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d", "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d", "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";
    e.d(n, "b", function() { return a }); var r = e(0),
        i = e(1),
        a = new Array(3).concat("fee6cefdae6be6550d", "feeddefdbe85fd8d3cd94701", "feeddefdbe85fd8d3ce6550da63603", "feeddefdd0a2fdae6bfd8d3ce6550da63603", "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04", "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04", "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704").map(r.a);
    n.a = Object(i.a)(a) }, function(t, n, e) { "use strict";

    function r(t) { return t && t.__esModule ? t : { default: t } }
    Object.defineProperty(n, "__esModule", { value: !0 }), n.renderAxes = n._buildAxesData = void 0; var i = e(586),
        a = r(i),
        o = e(96),
        u = r(o),
        c = e(11),
        f = e(589),
        s = r(f),
        l = function(t, n, e) { return { value: t, thickness: n.thickness || 1, color: n.color || "#d3d3d3", opacity: n.opacity || e.opacity } },
        d = n._buildAxesData = function(t) { return (0, u.default)(t.axes, function(n, e) { if (!e.position && !e.spacing) return s.default.warn("Skipping axe group with no position and spacing defined"), n; if (e.position && n.push(l(e.position, e, t)), e.spacing) { var r = (0, a.default)(e.start || t.cmin, e.end || t.cmax, e.spacing).map(function(n) { return l(n, e, t) }); return n.concat(r) } return n }, []) };
    n.renderAxes = function(t, n, e, r) { var i = d(n),
            a = (0, c.arc)().innerRadius(function(t) { return "in" === n.direction ? n.outerRadius - r(t.value) : n.innerRadius + r(t.value) }).outerRadius(function(t) { return "in" === n.direction ? n.outerRadius - r(t.value) : n.innerRadius + r(t.value) }).startAngle(0).endAngle(function(t) { return t.length }),
            o = t.selectAll(".axis").data(function(t) { var n = e._layout.blocks[t.key]; return i.map(function(e) { return { value: e.value, thickness: e.thickness, color: e.color, opacity: e.opacity, block_id: t.key, length: n.end - n.start } }) }).enter().append("path").attr("opacity", function(t) { return t.opacity }).attr("class", "axis").attr("d", a).attr("stroke-width", function(t) { return t.thickness }).attr("stroke", function(t) { return t.color }); return n.showAxesTooltip && (o.on("mouseover", function(t, n) { e.tip.html(t.value).transition().style("opacity", .9).style("left", event.pageX + "px").style("top", event.pageY - 28 + "px") }), o.on("mouseout", function(t, n) { e.tip.transition().duration(500).style("opacity", 0) })), o } }, function(t, n, e) { var r = e(587),
        i = r();
    t.exports = i }, function(t, n, e) {
    function r(t) { return function(n, e, r) { return r && "number" != typeof r && a(n, e, r) && (e = r = void 0), n = o(n), void 0 === e ? (e = n, n = 0) : e = o(e), r = void 0 === r ? n < e ? 1 : -1 : o(r), i(n, e, r, t) } } var i = e(588),
        a = e(61),
        o = e(218);
    t.exports = r }, function(t, n) {
    function e(t, n, e, a) { for (var o = -1, u = i(r((n - t) / (e || 1)), 0), c = Array(u); u--;) c[a ? u : ++o] = t, t += e; return c } var r = Math.ceil,
        i = Math.max;
    t.exports = e }, function(t, n, e) { "use strict";
    Object.defineProperty(n, "__esModule", { value: !0 }), n.default = console }, function(t, n, e) {
    function r(t, n, e, r) { t = a(t) ? t : c(t), e = e && !r ? u(e) : 0; var s = t.length; return e < 0 && (e = f(s + e, 0)), o(t) ? e <= s && t.indexOf(n, e) > -1 : !!s && i(t, n, e) > -1 } var i = e(216),
        a = e(16),
        o = e(591),
        u = e(115),
        c = e(592),
        f = Math.max;
    t.exports = r }, function(t, n, e) {
    function r(t) { return "string" == typeof t || !a(t) && o(t) && i(t) == u } var i = e(24),
        a = e(2),
        o = e(10),
        u = "[object String]";
    t.exports = r }, function(t, n, e) {
    function r(t) { return null == t ? [] : i(t, a(t)) } var i = e(593),
        a = e(17);
    t.exports = r }, function(t, n, e) {
    function r(t, n) { return i(n, function(n) { return t[n] }) } var i = e(40);
    t.exports = r }, function(t, n, e) {
    function r(t, n, e) { var r = u(t) ? i : a; return e && c(t, n, e) && (n = void 0), r(t, o(n, 3)) } var i = e(595),
        a = e(596),
        o = e(33),
        u = e(2),
        c = e(61);
    t.exports = r }, function(t, n) {
    function e(t, n) { for (var e = -1, r = null == t ? 0 : t.length; ++e < r;)
            if (!n(t[e], e, t)) return !1;
        return !0 }
    t.exports = e }, function(t, n, e) {
    function r(t, n) { var e = !0; return i(t, function(t, r, i) { return e = !!n(t, r, i) }), e } var i = e(39);
    t.exports = r }, function(t, n, e) { "use strict";

    function r(t) { return t && t.__esModule ? t : { default: t } }

    function i(t, n) { if (!(t instanceof n)) throw new TypeError("Cannot call a class as a function") }

    function a(t, n) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !n || "object" != typeof n && "function" != typeof n ? t : n }

    function o(t, n) { if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function, not " + typeof n);
        t.prototype = Object.create(n && n.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : t.__proto__ = n) }
    Object.defineProperty(n, "__esModule", { value: !0 }); var u = function() {
            function t(t, n) { for (var e = 0; e < n.length; e++) { var r = n[e];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } return function(n, e, r) { return e && t(n.prototype, e), r && t(n, r), n } }(),
        c = e(18),
        f = r(c),
        s = e(20),
        l = e(14),
        d = r(l),
        h = e(21),
        p = e(11),
        b = (0, d.default)({ color: { value: "#fd6a62", iteratee: !0 }, strokeColor: { value: "#d3d3d3", iteratee: !0 }, strokeWidth: { value: 0, iteratee: !0 } }, h.radial, h.common),
        v = function(t) {
            function n(t, e, r) { return i(this, n), a(this, (n.__proto__ || Object.getPrototypeOf(n)).call(this, t, e, b, r, s.parseSpanStringData)) } return o(n, t), u(n, [{ key: "renderDatum", value: function(t, n, e) { var r = this; return t.selectAll("tile").data(function(t) { return t.values }).enter().append("path").attr("class", "tile").attr("d", (0, p.arc)().innerRadius(n.innerRadius).outerRadius(n.outerRadius).startAngle(function(t, n) { return r.theta(t.start, e.blocks[t.block_id]) }).endAngle(function(t, n) { return r.theta(t.end, e.blocks[t.block_id]) })).attr("fill", n.colorValue).attr("opacity", n.opacity).attr("stroke-width", n.strokeWidth).attr("stroke", n.strokeColor) } }]), n }(f.default);
    n.default = v }, function(t, n, e) { "use strict";

    function r(t) { return t && t.__esModule ? t : { default: t } }

    function i(t, n) { if (!(t instanceof n)) throw new TypeError("Cannot call a class as a function") }

    function a(t, n) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !n || "object" != typeof n && "function" != typeof n ? t : n }

    function o(t, n) { if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function, not " + typeof n);
        t.prototype = Object.create(n && n.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : t.__proto__ = n) }
    Object.defineProperty(n, "__esModule", { value: !0 }); var u = function() {
            function t(t, n) { for (var e = 0; e < n.length; e++) { var r = n[e];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } return function(n, e, r) { return e && t(n.prototype, e), r && t(n, r), n } }(),
        c = e(18),
        f = r(c),
        s = e(20),
        l = e(11),
        d = e(14),
        h = r(d),
        p = e(21),
        b = (0, h.default)({ direction: { value: "out", iteratee: !1 }, color: { value: "#fd6a62", iteratee: !0 }, backgrounds: { value: [], iteratee: !1 } }, p.axes, p.radial, p.common, p.values),
        v = function(t) {
            function n(t, e, r) { return i(this, n), a(this, (n.__proto__ || Object.getPrototypeOf(n)).call(this, t, e, b, r, s.parseSpanValueData)) } return o(n, t), u(n, [{ key: "renderDatum", value: function(t, n, e) { var r = this,
                        i = t.selectAll(".bin").data(function(t) { return t.values }).enter().append("path").attr("class", "bin").attr("opacity", function(t) { return n.opacity }).attr("d", (0, l.arc)().innerRadius(function(t) { return "in" == n.direction ? n.outerRadius - r.scale(t.value) : n.innerRadius }).outerRadius(function(t) { return "out" == n.direction ? n.innerRadius + r.scale(t.value) : n.outerRadius }).startAngle(function(t) { return r.theta(t.start, e.blocks[t.block_id]) }).endAngle(function(t) { return r.theta(t.end, e.blocks[t.block_id]) })); return i.attr("fill", n.colorValue), i } }]), n }(f.default);
    n.default = v }, function(t, n, e) { "use strict";

    function r(t) { return t && t.__esModule ? t : { default: t } }

    function i(t, n) { if (!(t instanceof n)) throw new TypeError("Cannot call a class as a function") }

    function a(t, n) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !n || "object" != typeof n && "function" != typeof n ? t : n }

    function o(t, n) { if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function, not " + typeof n);
        t.prototype = Object.create(n && n.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : t.__proto__ = n) }
    Object.defineProperty(n, "__esModule", { value: !0 }); var u = function() {
            function t(t, n) { for (var e = 0; e < n.length; e++) { var r = n[e];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } return function(n, e, r) { return e && t(n.prototype, e), r && t(n, r), n } }(),
        c = e(18),
        f = r(c),
        s = e(20),
        l = e(192),
        d = e(600),
        h = e(14),
        p = r(h),
        b = e(23),
        v = r(b),
        y = e(3),
        _ = e(21),
        g = (0, p.default)({ color: { value: "#fd6a62", iteratee: !0 }, radius: { value: null, iteratee: !1 } }, _.common, _.values),
        m = function(t, n) { return t >= 1 ? t : t * n },
        x = function(t) {
            function n(t, e, r) { return i(this, n), a(this, (n.__proto__ || Object.getPrototypeOf(n)).call(this, t, e, g, r, s.parseChordData)) } return o(n, t), u(n, [{ key: "getCoordinates", value: function(t, n, e, r) { var i = n.blocks[t.id],
                        a = i.start + t.start / i.len * (i.end - i.start),
                        o = i.start + t.end / i.len * (i.end - i.start),
                        u = void 0; return (0, v.default)(e.radius) ? u = m(e.radius(r), n.conf.innerRadius) : e.radius && (u = m(e.radius, n.conf.innerRadius)), u || (u = n.conf.innerRadius), { radius: u, startAngle: a, endAngle: o } } }, { key: "renderChords", value: function(t, n, e, r, i, a) { var o = this,
                        u = t.append("g"),
                        c = u.selectAll(".chord").data(r).enter().append("path").attr("class", "chord").attr("d", (0, d.ribbon)().source(function(t) { return a(t.source, i._layout, o.conf, t) }).target(function(t) { return a(t.target, i._layout, o.conf, t) })).attr("opacity", e.opacity).on("mouseover", function(t) { o.dispatch.call("mouseover", o, t), i.clipboard.attr("value", e.tooltipContent(t)) }).on("mouseout", function(t) { return o.dispatch.call("mouseout", o, t) }); return Object.keys(e.events).forEach(function(t) { c.on(t, function(n, r, i) { e.events[t](n, r, i, y.event) }) }), c.attr("fill", e.colorValue), c } }, { key: "render", value: function(t, n, e) { n.select("." + e).remove(); var r = n.append("g").attr("class", e).attr("z-index", this.conf.zIndex),
                        i = this.renderChords(r, e, this.conf, this.data, t, this.getCoordinates); return this.conf.tooltipContent && (0, l.registerTooltip)(this, t, i, this.conf), this } }]), n }(f.default);
    n.default = x }, function(t, n, e) { "use strict";
    Object.defineProperty(n, "__esModule", { value: !0 }); var r = e(601);
    e.d(n, "chord", function() { return r.a }); var i = e(602);
    e.d(n, "ribbon", function() { return i.a }) }, function(t, n, e) { "use strict";

    function r(t) { return function(n, e) { return t(n.source.value + n.target.value, e.source.value + e.target.value) } } var i = e(7),
        a = e(234);
    n.a = function() {
        function t(t) { var r, c, f, s, l, d, h = t.length,
                p = [],
                b = Object(i.range)(h),
                v = [],
                y = [],
                _ = y.groups = new Array(h),
                g = new Array(h * h); for (r = 0, l = -1; ++l < h;) { for (c = 0, d = -1; ++d < h;) c += t[l][d];
                p.push(c), v.push(Object(i.range)(h)), r += c } for (e && b.sort(function(t, n) { return e(p[t], p[n]) }), o && v.forEach(function(n, e) { n.sort(function(n, r) { return o(t[e][n], t[e][r]) }) }), r = Object(a.c)(0, a.e - n * h) / r, s = r ? n : a.e / h, c = 0, l = -1; ++l < h;) { for (f = c, d = -1; ++d < h;) { var m = b[l],
                        x = v[m][d],
                        w = t[m][x],
                        j = c,
                        O = c += w * r;
                    g[x * h + m] = { index: m, subindex: x, startAngle: j, endAngle: O, value: w } }
                _[m] = { index: m, startAngle: f, endAngle: c, value: p[m] }, c += s } for (l = -1; ++l < h;)
                for (d = l - 1; ++d < h;) { var M = g[d * h + l],
                        k = g[l * h + d];
                    (M.value || k.value) && y.push(M.value < k.value ? { source: k, target: M } : { source: M, target: k }) }
            return u ? y.sort(u) : y } var n = 0,
            e = null,
            o = null,
            u = null; return t.padAngle = function(e) { return arguments.length ? (n = Object(a.c)(0, e), t) : n }, t.sortGroups = function(n) { return arguments.length ? (e = n, t) : e }, t.sortSubgroups = function(n) { return arguments.length ? (o = n, t) : o }, t.sortChords = function(n) { return arguments.length ? (null == n ? u = null : (u = r(n))._ = n, t) : u && u._ }, t } }, function(t, n, e) { "use strict";

    function r(t) { return t.source }

    function i(t) { return t.target }

    function a(t) { return t.radius }

    function o(t) { return t.startAngle }

    function u(t) { return t.endAngle } var c = e(603),
        f = e(604),
        s = e(234),
        l = e(35);
    n.a = function() {
        function t() { var t, r = c.a.call(arguments),
                i = n.apply(this, r),
                a = e.apply(this, r),
                o = +d.apply(this, (r[0] = i, r)),
                u = h.apply(this, r) - s.b,
                f = p.apply(this, r) - s.b,
                v = o * Object(s.a)(u),
                y = o * Object(s.d)(u),
                _ = +d.apply(this, (r[0] = a, r)),
                g = h.apply(this, r) - s.b,
                m = p.apply(this, r) - s.b; if (b || (b = t = Object(l.a)()), b.moveTo(v, y), b.arc(0, 0, o, u, f), u === g && f === m || (b.quadraticCurveTo(0, 0, _ * Object(s.a)(g), _ * Object(s.d)(g)), b.arc(0, 0, _, g, m)), b.quadraticCurveTo(0, 0, v, y), b.closePath(), t) return b = null, t + "" || null } var n = r,
            e = i,
            d = a,
            h = o,
            p = u,
            b = null; return t.radius = function(n) { return arguments.length ? (d = "function" == typeof n ? n : Object(f.a)(+n), t) : d }, t.startAngle = function(n) { return arguments.length ? (h = "function" == typeof n ? n : Object(f.a)(+n), t) : h }, t.endAngle = function(n) { return arguments.length ? (p = "function" == typeof n ? n : Object(f.a)(+n), t) : p }, t.source = function(e) { return arguments.length ? (n = e, t) : n }, t.target = function(n) { return arguments.length ? (e = n, t) : e }, t.context = function(n) { return arguments.length ? (b = null == n ? null : n, t) : b }, t } }, function(t, n, e) { "use strict";
    e.d(n, "a", function() { return r }); var r = Array.prototype.slice }, function(t, n, e) { "use strict";
    n.a = function(t) { return function() { return t } } }, function(t, n, e) { "use strict";

    function r(t) { return t && t.__esModule ? t : { default: t } }

    function i(t, n) { if (!(t instanceof n)) throw new TypeError("Cannot call a class as a function") }

    function a(t, n) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !n || "object" != typeof n && "function" != typeof n ? t : n }

    function o(t, n) { if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function, not " + typeof n);
        t.prototype = Object.create(n && n.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : t.__proto__ = n) }
    Object.defineProperty(n, "__esModule", { value: !0 }); var u = function() {
            function t(t, n) { for (var e = 0; e < n.length; e++) { var r = n[e];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } return function(n, e, r) { return e && t(n.prototype, e), r && t(n, r), n } }(),
        c = e(18),
        f = r(c),
        s = e(20),
        l = e(11),
        d = e(14),
        h = r(d),
        p = e(21),
        b = (0, h.default)({ color: { value: "Spectral", iteratee: !1 }, backgrounds: { value: [], iteratee: !1 } }, p.radial, p.values, p.common),
        v = function(t) {
            function n(t, e, r) { return i(this, n), a(this, (n.__proto__ || Object.getPrototypeOf(n)).call(this, t, e, b, r, s.parseSpanValueData)) } return o(n, t), u(n, [{ key: "renderDatum", value: function(t, n, e) { var r = this; return t.selectAll("tile").data(function(t) { return t.values }).enter().append("path").attr("class", "tile").attr("opacity", n.opacity).attr("d", (0, l.arc)().innerRadius(n.innerRadius).outerRadius(n.outerRadius).startAngle(function(t, n) { return r.theta(t.start, e.blocks[t.block_id]) }).endAngle(function(t, n) { return r.theta(t.end, e.blocks[t.block_id]) })).attr("fill", n.colorValue) } }]), n }(f.default);
    n.default = v }, function(t, n, e) { "use strict";

    function r(t) { return t && t.__esModule ? t : { default: t } }

    function i(t, n) { if (!(t instanceof n)) throw new TypeError("Cannot call a class as a function") }

    function a(t, n) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !n || "object" != typeof n && "function" != typeof n ? t : n }

    function o(t, n) { if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function, not " + typeof n);
        t.prototype = Object.create(n && n.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : t.__proto__ = n) }
    Object.defineProperty(n, "__esModule", { value: !0 }); var u = function() {
            function t(t, n) { for (var e = 0; e < n.length; e++) { var r = n[e];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } return function(n, e, r) { return e && t(n.prototype, e), r && t(n, r), n } }(),
        c = e(18),
        f = r(c),
        s = e(20),
        l = e(14),
        d = r(l),
        h = e(96),
        p = r(h),
        b = e(97),
        v = r(b),
        y = e(21),
        _ = e(11),
        g = (0, d.default)({ direction: { value: "out", iteratee: !1 }, color: { value: "#fd6a62", iteratee: !0 }, fill: { value: !1, iteratee: !1 }, fillColor: { value: "#d3d3d3", iteratee: !0 }, thickness: { value: 1, iteratee: !0 }, maxGap: { value: null, iteratee: !1 }, backgrounds: { value: [], iteratee: !1 } }, y.axes, y.radial, y.common, y.values),
        m = function(t, n) { return (0, p.default)((0, v.default)(t, "position"), function(t, e) { return null === t.position ? { position: e.position, groups: [
                        [e]
                    ] } : (e.position > t.position + n ? t.groups.push([e]) : t.groups[t.groups.length - 1].push(e), t.position = e.position, t) }, { position: null, groups: [] }).groups },
        x = function(t) {
            function n(t, e, r) { return i(this, n), a(this, (n.__proto__ || Object.getPrototypeOf(n)).call(this, t, e, g, r, s.parsePositionValueData)) } return o(n, t), u(n, [{ key: "renderDatum", value: function(t, n, e) { var r = this,
                        i = (0, _.radialLine)().angle(function(t) { return t.angle }).radius(function(t) { return t.radius }).curve(_.curveLinear),
                        a = (0, _.radialArea)().angle(function(t) { return t.angle }).innerRadius(function(t) { return t.innerRadius }).outerRadius(function(t) { return t.outerRadius }).curve(_.curveLinear),
                        o = n.fill ? a : i,
                        u = function(t) { return n.fill ? { innerRadius: "out" === n.direction ? n.innerRadius : n.outerRadius - t, outerRadius: "out" === n.direction ? n.innerRadius + t : n.outerRadius } : { radius: "out" === n.direction ? n.innerRadius + t : n.outerRadius - t } },
                        c = t.selectAll(".line").data(function(t) { return n.maxGap ? m(t.values, n.maxGap) : [t.values] }).enter().append("g").attr("class", "line").append("path").datum(function(t) { return t.map(function(t) { var n = r.scale(t.value); return (0, d.default)(t, { angle: r.theta(t.position, e.blocks[t.block_id]) }, u(n)) }) }).attr("d", o).attr("opacity", n.opacity).attr("stroke-width", n.thickness).attr("stroke", n.colorValue).attr("fill", "none"); return n.fill && c.attr("fill", n.fillColor), c } }]), n }(f.default);
    n.default = x }, function(t, n, e) { "use strict";

    function r(t) { return t && t.__esModule ? t : { default: t } }

    function i(t, n) { if (!(t instanceof n)) throw new TypeError("Cannot call a class as a function") }

    function a(t, n) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !n || "object" != typeof n && "function" != typeof n ? t : n }

    function o(t, n) { if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function, not " + typeof n);
        t.prototype = Object.create(n && n.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : t.__proto__ = n) }
    Object.defineProperty(n, "__esModule", { value: !0 }); var u = function() {
            function t(t, n) { for (var e = 0; e < n.length; e++) { var r = n[e];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } return function(n, e, r) { return e && t(n.prototype, e), r && t(n, r), n } }(),
        c = e(18),
        f = r(c),
        s = e(20),
        l = e(14),
        d = r(l),
        h = e(21),
        p = e(11),
        b = (0, d.default)({ direction: { value: "out", iteratee: !1 }, color: { value: "#fd6a62", iteratee: !0 }, fill: { value: !0, iteratee: !1 }, size: { value: 15, iteratee: !0 }, shape: { value: "circle", iteratee: !1 }, strokeColor: { value: "#d3d3d3", iteratee: !0 }, strokeWidth: { value: 2, iteratee: !0 }, backgrounds: { value: [], iteratee: !1 } }, h.axes, h.radial, h.common, h.values),
        v = function(t) { switch (t) {
                case "circle":
                    return p.symbolCircle;
                case "cross":
                    return p.symbolCross;
                case "diamond":
                    return p.symbolDiamond;
                case "square":
                    return p.symbolSquare;
                case "triangle":
                    return p.symbolTriangle;
                case "star":
                    return p.symbolStar;
                case "wye":
                    return p.symbolWye;
                default:
                    return p.symbolCross } },
        y = function(t) {
            function n(t, e, r) { return i(this, n), a(this, (n.__proto__ || Object.getPrototypeOf(n)).call(this, t, e, b, r, s.parsePositionValueData)) } return o(n, t), u(n, [{ key: "renderDatum", value: function(t, n, e) { var r = this,
                        i = t.selectAll(".point").data(function(t) { return t.values.forEach(function(t, e) { t.symbol = (0, p.symbol)().type(v(n.shape)).size(n.size) }), t.values }).enter().append("path").attr("class", "point").attr("opacity", n.opacity).attr("d", function(t, n, e) { return t.symbol(t, n, e) }).attr("transform", function(t) { return "\n          translate(\n            " + r.x(t, e, n) + ",\n            " + r.y(t, e, n) + "\n          ) rotate(\n            " + 360 * r.theta(t.position, e.blocks[t.block_id]) / (2 * Math.PI) + "\n          )" }).attr("stroke", n.strokeColor).attr("stroke-width", n.strokeWidth).attr("fill", "none"); return n.fill && i.attr("fill", n.colorValue), i } }]), n }(f.default);
    n.default = y }, function(t, n, e) { "use strict";

    function r(t) { return t && t.__esModule ? t : { default: t } }

    function i(t, n) { if (!(t instanceof n)) throw new TypeError("Cannot call a class as a function") }

    function a(t, n) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !n || "object" != typeof n && "function" != typeof n ? t : n }

    function o(t, n) { if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function, not " + typeof n);
        t.prototype = Object.create(n && n.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : t.__proto__ = n) }
    Object.defineProperty(n, "__esModule", { value: !0 }); var u = function() {
            function t(t, n) { for (var e = 0; e < n.length; e++) { var r = n[e];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } return function(n, e, r) { return e && t(n.prototype, e), r && t(n, r), n } }(),
        c = e(18),
        f = r(c),
        s = e(20),
        l = e(11),
        d = e(14),
        h = r(d),
        p = e(32),
        b = r(p),
        v = e(21),
        y = (0, h.default)({ color: { value: "#fd6a62", iteratee: !0 }, direction: { value: "out", iteratee: !1 }, thickness: { value: 10, iteratee: !1 }, radialMargin: { value: 2, iteratee: !1 }, margin: { value: 2, iteratee: !1 }, strokeWidth: { value: 1, iteratee: !0 }, strokeColor: { value: "#000000", iteratee: !0 }, backgrounds: { value: [], iteratee: !1 } }, v.axes, v.radial, v.values, v.common),
        _ = function(t) {
            function n(t, e, r) { i(this, n); var o = a(this, (n.__proto__ || Object.getPrototypeOf(n)).call(this, t, e, y, r, s.parseSpanValueData)); return o.buildLayers(o.data, o.conf.margin), o } return o(n, t), u(n, [{ key: "buildLayers", value: function(t, n) {
                    (0, b.default)(t, function(t, e) { t.values = t.values.sort(function(t, n) { return t.start < n.start ? -1 : t.start == n.start && t.end > n.end ? -1 : t.start == n.start && t.end == n.end ? 0 : 1 }); var r = [];
                        (0, b.default)(t.values, function(t) { var e = !1;
                            (0, b.default)(r, function(r, i) { if (r.slice(0).pop().end + n < t.start) return r.push(t), t.layer = i, e = !0, !1 }), e || (t.layer = r.length, r.push([t])) }) }) } }, { key: "datumRadialPosition", value: function(t) { var n = (this.conf.thickness + this.conf.radialMargin) * t.layer,
                        e = n + this.conf.thickness; if ("out" === this.conf.direction) return [Math.min(this.conf.innerRadius + n, this.conf.outerRadius), Math.min(this.conf.innerRadius + e, this.conf.outerRadius)]; if ("in" === this.conf.direction) return [Math.max(this.conf.outerRadius - e, this.conf.innerRadius), this.conf.outerRadius - n]; if ("center" === this.conf.direction) { var r = Math.floor((this.conf.outerRadius + this.conf.innerRadius) / 2),
                            i = (this.conf.thickness + this.conf.radialMargin) * Math.floor(t.layer / 2),
                            a = i + this.conf.thickness; return t.layer % 2 == 0 ? [r + i, r + a] : [r - i - this.conf.radialMargin, r - a - this.conf.radialMargin] } } }, { key: "renderDatum", value: function(t, n, e) { var r = this,
                        i = this; return t.selectAll(".tile").data(function(t) { return t.values.map(function(t) { var n = i.datumRadialPosition(t); return (0, h.default)(t, { innerRadius: n[0], outerRadius: n[1], startAngle: r.theta(t.start, e.blocks[t.block_id]), endAngle: r.theta(t.end, e.blocks[t.block_id]) }) }) }).enter().append("path").attr("class", "tile").attr("d", (0, l.arc)()).attr("opacity", n.opacity).attr("stroke-width", n.strokeWidth).attr("stroke", n.strokeColor).attr("fill", n.colorValue) } }]), n }(f.default);
    n.default = _ }, function(t, n, e) { "use strict";
    Object.defineProperty(n, "__esModule", { value: !0 }), n.initClipboard = void 0; var r = e(610),
        i = function(t) { return t && t.__esModule ? t : { default: t } }(r),
        a = e(3);
    n.initClipboard = function(t) { var n = (0, a.select)(t).append("input").attr("class", "circos-clipboard").attr("type", "hidden"); return (0, a.select)("body").on("keydown", function() { event.ctrlKey && "KeyC" === event.code && i.default.copy(n.attr("value")) }), n } }, function(t, n, e) {
    (function(n) {
        ! function(n, e) { t.exports = e() }(0, function() {
            if ("undefined" == typeof document || !document.addEventListener) return null;
            var e = {}; /*! promise-polyfill 2.0.1 */
            return e.copy = function() {
                function t() { e = !1, r = null, i && window.getSelection().removeAllRanges(), i = !1 }

                function n() { var t = document.getSelection(); if (!document.queryCommandEnabled("copy") && t.isCollapsed) { var n = document.createRange();
                        n.selectNodeContents(document.body), t.removeAllRanges(), t.addRange(n), i = !0 } } var e = !1,
                    r = null,
                    i = !1; return document.addEventListener("copy", function(t) { if (e) { for (var n in r) t.clipboardData.setData(n, r[n]);
                            t.preventDefault() } }),
                    function(i) { return new Promise(function(a, o) {
                            function u(e) { try { if (document.execCommand("copy")) t(), a();
                                    else { if (e) throw t(), new Error("Unable to copy. Perhaps it's not available in your browser?");
                                        n(), u(!0) } } catch (n) { t(), o(n) } }
                            e = !0, "string" == typeof i ? r = { "text/plain": i } : i instanceof Node ? r = { "text/html": (new XMLSerializer).serializeToString(i) } : i instanceof Object ? r = i : o("Invalid data type. Must be string, DOM node, or an object mapping MIME types to strings."), u(!1) }) } }(), e.paste = function() { var t, n, e = !1; return document.addEventListener("paste", function(r) { if (e) { e = !1, r.preventDefault(); var i = t;
                            t = null, i(r.clipboardData.getData(n)) } }),
                    function(r) { return new Promise(function(i, a) { e = !0, t = i, n = r || "text/plain"; try { document.execCommand("paste") || (e = !1, a(new Error("Unable to paste. Pasting only works in Internet Explorer at the moment."))) } catch (t) { e = !1, a(new Error(t)) } }) } }(), "undefined" == typeof ClipboardEvent && void 0 !== window.clipboardData && void 0 !== window.clipboardData.setData && (! function(e) {
                function r(t, n) { return function() { t.apply(n, arguments) } }

                function i(t) { if ("object" != typeof this) throw new TypeError("Promises must be constructed via new"); if ("function" != typeof t) throw new TypeError("not a function");
                    this._state = null, this._value = null, this._deferreds = [], s(t, r(o, this), r(u, this)) }

                function a(t) { var n = this; return null === this._state ? void this._deferreds.push(t) : void l(function() { var e = n._state ? t.onFulfilled : t.onRejected; if (null === e) return void(n._state ? t.resolve : t.reject)(n._value); var r; try { r = e(n._value) } catch (n) { return void t.reject(n) }
                        t.resolve(r) }) }

                function o(t) { try { if (t === this) throw new TypeError("A promise cannot be resolved with itself."); if (t && ("object" == typeof t || "function" == typeof t)) { var n = t.then; if ("function" == typeof n) return void s(r(n, t), r(o, this), r(u, this)) }
                        this._state = !0, this._value = t, c.call(this) } catch (t) { u.call(this, t) } }

                function u(t) { this._state = !1, this._value = t, c.call(this) }

                function c() { for (var t = 0, n = this._deferreds.length; n > t; t++) a.call(this, this._deferreds[t]);
                    this._deferreds = null }

                function f(t, n, e, r) { this.onFulfilled = "function" == typeof t ? t : null, this.onRejected = "function" == typeof n ? n : null, this.resolve = e, this.reject = r }

                function s(t, n, e) { var r = !1; try { t(function(t) { r || (r = !0, n(t)) }, function(t) { r || (r = !0, e(t)) }) } catch (t) { if (r) return;
                        r = !0, e(t) } } var l = i.immediateFn || "function" == typeof n && n || function(t) { setTimeout(t, 1) },
                    d = Array.isArray || function(t) { return "[object Array]" === Object.prototype.toString.call(t) };
                i.prototype.catch = function(t) { return this.then(null, t) }, i.prototype.then = function(t, n) { var e = this; return new i(function(r, i) { a.call(e, new f(t, n, r, i)) }) }, i.all = function() { var t = Array.prototype.slice.call(1 === arguments.length && d(arguments[0]) ? arguments[0] : arguments); return new i(function(n, e) {
                        function r(a, o) { try { if (o && ("object" == typeof o || "function" == typeof o)) { var u = o.then; if ("function" == typeof u) return void u.call(o, function(t) { r(a, t) }, e) }
                                t[a] = o, 0 == --i && n(t) } catch (t) { e(t) } } if (0 === t.length) return n([]); for (var i = t.length, a = 0; a < t.length; a++) r(a, t[a]) }) }, i.resolve = function(t) { return t && "object" == typeof t && t.constructor === i ? t : new i(function(n) { n(t) }) }, i.reject = function(t) { return new i(function(n, e) { e(t) }) }, i.race = function(t) { return new i(function(n, e) { for (var r = 0, i = t.length; i > r; r++) t[r].then(n, e) }) }, void 0 !== t && t.exports ? t.exports = i : e.Promise || (e.Promise = i) }(this), e.copy = function(t) { return new Promise(function(n, e) { if ("string" != typeof t && !("text/plain" in t)) throw new Error("You must provide a text/plain type."); var r = "string" == typeof t ? t : t["text/plain"];
                    window.clipboardData.setData("Text", r) ? n() : e(new Error("Copying was rejected.")) }) }, e.paste = function() { return new Promise(function(t, n) { var e = window.clipboardData.getData("Text");
                    e ? t(e) : n(new Error("Pasting was rejected.")) }) }), e
        })
    }).call(n, e(611).setImmediate)
}, function(t, n, e) {
    function r(t, n) { this._id = t, this._clearFn = n } var i = Function.prototype.apply;
    n.setTimeout = function() { return new r(i.call(setTimeout, window, arguments), clearTimeout) }, n.setInterval = function() { return new r(i.call(setInterval, window, arguments), clearInterval) }, n.clearTimeout = n.clearInterval = function(t) { t && t.close() }, r.prototype.unref = r.prototype.ref = function() {}, r.prototype.close = function() { this._clearFn.call(window, this._id) }, n.enroll = function(t, n) { clearTimeout(t._idleTimeoutId), t._idleTimeout = n }, n.unenroll = function(t) { clearTimeout(t._idleTimeoutId), t._idleTimeout = -1 }, n._unrefActive = n.active = function(t) { clearTimeout(t._idleTimeoutId); var n = t._idleTimeout;
        n >= 0 && (t._idleTimeoutId = setTimeout(function() { t._onTimeout && t._onTimeout() }, n)) }, e(612), n.setImmediate = setImmediate, n.clearImmediate = clearImmediate }, function(t, n, e) {
    (function(t, n) {! function(t, e) { "use strict";

            function r(t) { "function" != typeof t && (t = new Function("" + t)); for (var n = new Array(arguments.length - 1), e = 0; e < n.length; e++) n[e] = arguments[e + 1]; var r = { callback: t, args: n }; return f[c] = r, u(c), c++ }

            function i(t) { delete f[t] }

            function a(t) { var n = t.callback,
                    r = t.args; switch (r.length) {
                    case 0:
                        n(); break;
                    case 1:
                        n(r[0]); break;
                    case 2:
                        n(r[0], r[1]); break;
                    case 3:
                        n(r[0], r[1], r[2]); break;
                    default:
                        n.apply(e, r) } }

            function o(t) { if (s) setTimeout(o, 0, t);
                else { var n = f[t]; if (n) { s = !0; try { a(n) } finally { i(t), s = !1 } } } } if (!t.setImmediate) { var u, c = 1,
                    f = {},
                    s = !1,
                    l = t.document,
                    d = Object.getPrototypeOf && Object.getPrototypeOf(t);
                d = d && d.setTimeout ? d : t, "[object process]" === {}.toString.call(t.process) ? function() { u = function(t) { n.nextTick(function() { o(t) }) } }() : function() { if (t.postMessage && !t.importScripts) { var n = !0,
                            e = t.onmessage; return t.onmessage = function() { n = !1 }, t.postMessage("", "*"), t.onmessage = e, n } }() ? function() { var n = "setImmediate$" + Math.random() + "$",
                        e = function(e) { e.source === t && "string" == typeof e.data && 0 === e.data.indexOf(n) && o(+e.data.slice(n.length)) };
                    t.addEventListener ? t.addEventListener("message", e, !1) : t.attachEvent("onmessage", e), u = function(e) { t.postMessage(n + e, "*") } }() : t.MessageChannel ? function() { var t = new MessageChannel;
                    t.port1.onmessage = function(t) { o(t.data) }, u = function(n) { t.port2.postMessage(n) } }() : l && "onreadystatechange" in l.createElement("script") ? function() { var t = l.documentElement;
                    u = function(n) { var e = l.createElement("script");
                        e.onreadystatechange = function() { o(n), e.onreadystatechange = null, t.removeChild(e), e = null }, t.appendChild(e) } }() : function() { u = function(t) { setTimeout(o, 0, t) } }(), d.setImmediate = r, d.clearImmediate = i } }("undefined" == typeof self ? void 0 === t ? this : t : self) }).call(n, e(125), e(613)) }, function(t, n) {
    function e() { throw new Error("setTimeout has not been defined") }

    function r() { throw new Error("clearTimeout has not been defined") }

    function i(t) { if (s === setTimeout) return setTimeout(t, 0); if ((s === e || !s) && setTimeout) return s = setTimeout, setTimeout(t, 0); try { return s(t, 0) } catch (n) { try { return s.call(null, t, 0) } catch (n) { return s.call(this, t, 0) } } }

    function a(t) { if (l === clearTimeout) return clearTimeout(t); if ((l === r || !l) && clearTimeout) return l = clearTimeout, clearTimeout(t); try { return l(t) } catch (n) { try { return l.call(null, t) } catch (n) { return l.call(this, t) } } }

    function o() { b && h && (b = !1, h.length ? p = h.concat(p) : v = -1, p.length && u()) }

    function u() { if (!b) { var t = i(o);
            b = !0; for (var n = p.length; n;) { for (h = p, p = []; ++v < n;) h && h[v].run();
                v = -1, n = p.length }
            h = null, b = !1, a(t) } }

    function c(t, n) { this.fun = t, this.array = n }

    function f() {} var s, l, d = t.exports = {};! function() { try { s = "function" == typeof setTimeout ? setTimeout : e } catch (t) { s = e } try { l = "function" == typeof clearTimeout ? clearTimeout : r } catch (t) { l = r } }(); var h, p = [],
        b = !1,
        v = -1;
    d.nextTick = function(t) { var n = new Array(arguments.length - 1); if (arguments.length > 1)
            for (var e = 1; e < arguments.length; e++) n[e - 1] = arguments[e];
        p.push(new c(t, n)), 1 !== p.length || b || i(u) }, c.prototype.run = function() { this.fun.apply(null, this.array) }, d.title = "browser", d.browser = !0, d.env = {}, d.argv = [], d.version = "", d.versions = {}, d.on = f, d.addListener = f, d.once = f, d.off = f, d.removeListener = f, d.removeAllListeners = f, d.emit = f, d.prependListener = f, d.prependOnceListener = f, d.listeners = function(t) { return [] }, d.binding = function(t) { throw new Error("process.binding is not supported") }, d.cwd = function() { return "/" }, d.chdir = function(t) { throw new Error("process.chdir is not supported") }, d.umask = function() { return 0 } }]);
;(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["cytoscape"] = factory();
	else
		root["cytoscape"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 117);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*global HTMLElement DocumentTouch */

var window = __webpack_require__(4);
var navigator = window ? window.navigator : null;
var document = window ? window.document : null;

var typeofstr = _typeof('');
var typeofobj = _typeof({});
var typeoffn = _typeof(function () {});
var typeofhtmlele = typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement);

var instanceStr = function instanceStr(obj) {
  return obj && obj.instanceString && is.fn(obj.instanceString) ? obj.instanceString() : null;
};

var is = {
  defined: function defined(obj) {
    return obj != null; // not undefined or null
  },

  string: function string(obj) {
    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == typeofstr;
  },

  fn: function fn(obj) {
    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeoffn;
  },

  array: function array(obj) {
    return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;
  },

  plainObject: function plainObject(obj) {
    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeofobj && !is.array(obj) && obj.constructor === Object;
  },

  object: function object(obj) {
    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeofobj;
  },

  number: function number(obj) {
    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === _typeof(1) && !isNaN(obj);
  },

  integer: function integer(obj) {
    return is.number(obj) && Math.floor(obj) === obj;
  },

  bool: function bool(obj) {
    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === _typeof(true);
  },

  htmlElement: function htmlElement(obj) {
    if ('undefined' === typeofhtmlele) {
      return undefined;
    } else {
      return null != obj && obj instanceof HTMLElement;
    }
  },

  elementOrCollection: function elementOrCollection(obj) {
    return is.element(obj) || is.collection(obj);
  },

  element: function element(obj) {
    return instanceStr(obj) === 'collection' && obj._private.single;
  },

  collection: function collection(obj) {
    return instanceStr(obj) === 'collection' && !obj._private.single;
  },

  core: function core(obj) {
    return instanceStr(obj) === 'core';
  },

  style: function style(obj) {
    return instanceStr(obj) === 'style';
  },

  stylesheet: function stylesheet(obj) {
    return instanceStr(obj) === 'stylesheet';
  },

  event: function event(obj) {
    return instanceStr(obj) === 'event';
  },

  thread: function thread(obj) {
    return instanceStr(obj) === 'thread';
  },

  fabric: function fabric(obj) {
    return instanceStr(obj) === 'fabric';
  },

  emptyString: function emptyString(obj) {
    if (obj === undefined || obj === null) {
      // null is empty
      return true;
    } else if (obj === '' || obj.match(/^\s+$/)) {
      return true; // empty string is empty
    }

    return false; // otherwise, we don't know what we've got
  },

  nonemptyString: function nonemptyString(obj) {
    if (obj && is.string(obj) && obj !== '' && !obj.match(/^\s+$/)) {
      return true;
    }

    return false;
  },

  domElement: function domElement(obj) {
    if (typeof HTMLElement === 'undefined') {
      return false; // we're not in a browser so it doesn't matter
    } else {
      return obj instanceof HTMLElement;
    }
  },

  boundingBox: function boundingBox(obj) {
    return is.plainObject(obj) && is.number(obj.x1) && is.number(obj.x2) && is.number(obj.y1) && is.number(obj.y2);
  },

  promise: function promise(obj) {
    return is.object(obj) && is.fn(obj.then);
  },

  touch: function touch() {
    return window && ('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch);
  },

  gecko: function gecko() {
    return window && (typeof InstallTrigger !== 'undefined' || 'MozAppearance' in document.documentElement.style);
  },

  webkit: function webkit() {
    return window && (typeof webkitURL !== 'undefined' || 'WebkitAppearance' in document.documentElement.style);
  },

  chromium: function chromium() {
    return window && typeof chrome !== 'undefined';
  },

  khtml: function khtml() {
    return navigator && navigator.vendor.match(/kde/i); // probably a better way to detect this...
  },

  khtmlEtc: function khtmlEtc() {
    return is.khtml() || is.webkit() || is.chromium();
  },

  ms: function ms() {
    return navigator && navigator.userAgent.match(/msie|trident|edge/i); // probably a better way to detect this...
  },

  windows: function windows() {
    return navigator && navigator.appVersion.match(/Win/i);
  },

  mac: function mac() {
    return navigator && navigator.appVersion.match(/Mac/i);
  },

  linux: function linux() {
    return navigator && navigator.appVersion.match(/Linux/i);
  },

  unix: function unix() {
    return navigator && navigator.appVersion.match(/X11/i);
  }
};

module.exports = is;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*global console */

var is = __webpack_require__(0);
var math = __webpack_require__(2);

var util = {

  MAX_INT: Number.MAX_SAFE_INTEGER || 9007199254740991,

  trueify: function trueify() {
    return true;
  },

  falsify: function falsify() {
    return false;
  },

  zeroify: function zeroify() {
    return 0;
  },

  noop: function noop() {},

  error: function error(msg) {
    /* eslint-disable */
    if (console.error) {
      console.error.apply(console, arguments);

      if (console.trace) {
        console.trace();
      }
    } else {
      console.log.apply(console, arguments);

      if (console.trace) {
        console.trace();
      }
    }
    /* eslint-enable */
  },

  clone: function clone(obj) {
    return this.extend({}, obj);
  },

  // gets a shallow copy of the argument
  copy: function copy(obj) {
    if (obj == null) {
      return obj;
    }if (is.array(obj)) {
      return obj.slice();
    } else if (is.plainObject(obj)) {
      return this.clone(obj);
    } else {
      return obj;
    }
  },

  copyArray: function copyArray(arr) {
    return arr.slice();
  },

  clonePosition: function clonePosition(pos) {
    return { x: pos.x, y: pos.y };
  },

  uuid: function uuid(a, b // placeholders
  ) {
    for ( // loop :)
    b = a = ''; // b - result , a - numeric letiable
    a++ < 36; //
    b += a * 51 & 52 // if "a" is not 9 or 14 or 19 or 24
    ? //  return a random number or 4
    (a ^ 15 // if "a" is not 15
    ? // genetate a random number from 0 to 15
    8 ^ Math.random() * (a ^ 20 ? 16 : 4) // unless "a" is 20, in which case a random number from 8 to 11
    : 4 //  otherwise 4
    ).toString(16) : '-' //  in other cases (if "a" is 9,14,19,24) insert "-"
    ) {}
    return b;
  }

};

util.makeBoundingBox = math.makeBoundingBox.bind(math);

util._staticEmptyObject = {};

util.staticEmptyObject = function () {
  return util._staticEmptyObject;
};

util.extend = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {
  var args = arguments;

  for (var i = 1; i < args.length; i++) {
    var obj = args[i];

    if (obj == null) {
      continue;
    }

    var keys = Object.keys(obj);

    for (var j = 0; j < keys.length; j++) {
      var k = keys[j];

      tgt[k] = obj[k];
    }
  }

  return tgt;
};

util.assign = util.extend;

util.default = function (val, def) {
  if (val === undefined) {
    return def;
  } else {
    return val;
  }
};

util.removeFromArray = function (arr, ele, manyCopies) {
  for (var i = arr.length; i >= 0; i--) {
    if (arr[i] === ele) {
      arr.splice(i, 1);

      if (!manyCopies) {
        break;
      }
    }
  }
};

util.clearArray = function (arr) {
  arr.splice(0, arr.length);
};

util.push = function (arr, otherArr) {
  for (var i = 0; i < otherArr.length; i++) {
    var el = otherArr[i];

    arr.push(el);
  }
};

util.getPrefixedProperty = function (obj, propName, prefix) {
  if (prefix) {
    propName = this.prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
  }

  return obj[propName];
};

util.setPrefixedProperty = function (obj, propName, prefix, value) {
  if (prefix) {
    propName = this.prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
  }

  obj[propName] = value;
};

[__webpack_require__(131), __webpack_require__(132), { memoize: __webpack_require__(19) }, __webpack_require__(133), __webpack_require__(135), __webpack_require__(136), __webpack_require__(134)].forEach(function (req) {
  util.extend(util, req);
});

module.exports = util;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = {};

math.arePositionsSame = function (p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
};

math.copyPosition = function (p) {
  return { x: p.x, y: p.y };
};

math.modelToRenderedPosition = function (p, zoom, pan) {
  return {
    x: p.x * zoom + pan.x,
    y: p.y * zoom + pan.y
  };
};

math.renderedToModelPosition = function (p, zoom, pan) {
  return {
    x: (p.x - pan.x) / zoom,
    y: (p.y - pan.y) / zoom
  };
};

math.array2point = function (arr) {
  return {
    x: arr[0],
    y: arr[1]
  };
};

math.deg2rad = function (deg) {
  return Math.PI * deg / 180;
};

math.getAngleFromDisp = function (dispX, dispY) {
  return Math.atan2(dispY, dispX) - Math.PI / 2;
};

math.log2 = Math.log2 || function (n) {
  return Math.log(n) / Math.log(2);
};

math.signum = function (x) {
  if (x > 0) {
    return 1;
  } else if (x < 0) {
    return -1;
  } else {
    return 0;
  }
};

math.dist = function (p1, p2) {
  return Math.sqrt(math.sqdist(p1, p2));
};

math.sqdist = function (p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;

  return dx * dx + dy * dy;
};

// from http://en.wikipedia.org/wiki/Bzier_curve#Quadratic_curves
math.qbezierAt = function (p0, p1, p2, t) {
  return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
};

math.qbezierPtAt = function (p0, p1, p2, t) {
  return {
    x: math.qbezierAt(p0.x, p1.x, p2.x, t),
    y: math.qbezierAt(p0.y, p1.y, p2.y, t)
  };
};

math.lineAt = function (p0, p1, t, d) {
  var vec = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };

  var vecDist = math.dist(p0, p1);

  var normVec = {
    x: vec.x / vecDist,
    y: vec.y / vecDist
  };

  t = t == null ? 0 : t;

  d = d != null ? d : t * vecDist;

  return {
    x: p0.x + normVec.x * d,
    y: p0.y + normVec.y * d
  };
};

math.lineAtDist = function (p0, p1, d) {
  return math.lineAt(p0, p1, undefined, d);
};

// get angle at A via cosine law
math.triangleAngle = function (A, B, C) {
  var a = math.dist(B, C);
  var b = math.dist(A, C);
  var c = math.dist(A, B);

  return Math.acos((a * a + b * b - c * c) / (2 * a * b));
};

math.bound = function (min, val, max) {
  return Math.max(min, Math.min(max, val));
};

// makes a full bb (x1, y1, x2, y2, w, h) from implicit params
math.makeBoundingBox = function (bb) {
  if (bb == null) {
    return {
      x1: Infinity,
      y1: Infinity,
      x2: -Infinity,
      y2: -Infinity,
      w: 0,
      h: 0
    };
  } else if (bb.x1 != null && bb.y1 != null) {
    if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x2,
        y2: bb.y2,
        w: bb.x2 - bb.x1,
        h: bb.y2 - bb.y1
      };
    } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x1 + bb.w,
        y2: bb.y1 + bb.h,
        w: bb.w,
        h: bb.h
      };
    }
  }
};

math.updateBoundingBox = function (bb1, bb2) {
  // update bb1 with bb2 bounds

  bb1.x1 = Math.min(bb1.x1, bb2.x1);
  bb1.x2 = Math.max(bb1.x2, bb2.x2);
  bb1.w = bb1.x2 - bb1.x1;

  bb1.y1 = Math.min(bb1.y1, bb2.y1);
  bb1.y2 = Math.max(bb1.y2, bb2.y2);
  bb1.h = bb1.y2 - bb1.y1;
};

math.expandBoundingBoxByPoint = function (bb, x, y) {
  bb.x1 = Math.min(bb.x1, x);
  bb.x2 = Math.max(bb.x2, x);
  bb.w = bb.x2 - bb.x1;

  bb.y1 = Math.min(bb.y1, y);
  bb.y2 = Math.max(bb.y2, y);
  bb.h = bb.y2 - bb.y1;
};

math.expandBoundingBox = function (bb, padding) {
  bb.x1 -= padding;
  bb.x2 += padding;
  bb.y1 -= padding;
  bb.y2 += padding;
  bb.w = bb.x2 - bb.x1;
  bb.h = bb.y2 - bb.y1;

  return bb;
};

math.boundingBoxesIntersect = function (bb1, bb2) {
  // case: one bb to right of other
  if (bb1.x1 > bb2.x2) {
    return false;
  }
  if (bb2.x1 > bb1.x2) {
    return false;
  }

  // case: one bb to left of other
  if (bb1.x2 < bb2.x1) {
    return false;
  }
  if (bb2.x2 < bb1.x1) {
    return false;
  }

  // case: one bb above other
  if (bb1.y2 < bb2.y1) {
    return false;
  }
  if (bb2.y2 < bb1.y1) {
    return false;
  }

  // case: one bb below other
  if (bb1.y1 > bb2.y2) {
    return false;
  }
  if (bb2.y1 > bb1.y2) {
    return false;
  }

  // otherwise, must have some overlap
  return true;
};

math.inBoundingBox = function (bb, x, y) {
  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
};

math.pointInBoundingBox = function (bb, pt) {
  return this.inBoundingBox(bb, pt.x, pt.y);
};

math.boundingBoxInBoundingBox = function (bb1, bb2) {
  return math.inBoundingBox(bb1, bb2.x1, bb2.y1) && math.inBoundingBox(bb1, bb2.x2, bb2.y2);
};

math.roundRectangleIntersectLine = function (x, y, nodeX, nodeY, width, height, padding) {

  var cornerRadius = this.getRoundRectangleRadius(width, height);

  var halfWidth = width / 2;
  var halfHeight = height / 2;

  // Check intersections with straight line segments
  var straightLineIntersections = void 0;

  // Top segment, left to right
  {
    var topStartX = nodeX - halfWidth + cornerRadius - padding;
    var topStartY = nodeY - halfHeight - padding;
    var topEndX = nodeX + halfWidth - cornerRadius + padding;
    var topEndY = topStartY;

    straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }

  // Right segment, top to bottom
  {
    var rightStartX = nodeX + halfWidth + padding;
    var rightStartY = nodeY - halfHeight + cornerRadius - padding;
    var rightEndX = rightStartX;
    var rightEndY = nodeY + halfHeight - cornerRadius + padding;

    straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }

  // Bottom segment, left to right
  {
    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
    var bottomStartY = nodeY + halfHeight + padding;
    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
    var bottomEndY = bottomStartY;

    straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }

  // Left segment, top to bottom
  {
    var leftStartX = nodeX - halfWidth - padding;
    var leftStartY = nodeY - halfHeight + cornerRadius - padding;
    var leftEndX = leftStartX;
    var leftEndY = nodeY + halfHeight - cornerRadius + padding;

    straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }

  // Check intersections with arc segments
  var arcIntersections = void 0;

  // Top Left
  {
    var topLeftCenterX = nodeX - halfWidth + cornerRadius;
    var topLeftCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding);

    // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }

  // Top Right
  {
    var topRightCenterX = nodeX + halfWidth - cornerRadius;
    var topRightCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding);

    // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }

  // Bottom Right
  {
    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);

    // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }

  // Bottom Left
  {
    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);

    // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }

  return []; // if nothing
};

math.inLineVicinity = function (x, y, lx1, ly1, lx2, ly2, tolerance) {
  var t = tolerance;

  var x1 = Math.min(lx1, lx2);
  var x2 = Math.max(lx1, lx2);
  var y1 = Math.min(ly1, ly2);
  var y2 = Math.max(ly1, ly2);

  return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;
};

math.inBezierVicinity = function (x, y, x1, y1, x2, y2, x3, y3, tolerance) {

  var bb = {
    x1: Math.min(x1, x3, x2) - tolerance,
    x2: Math.max(x1, x3, x2) + tolerance,
    y1: Math.min(y1, y3, y2) - tolerance,
    y2: Math.max(y1, y3, y2) + tolerance
  };

  // if outside the rough bounding box for the bezier, then it can't be a hit
  if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {
    // console.log('bezier out of rough bb')
    return false;
  } else {
    // console.log('do more expensive check');
    return true;
  }
};
math.solveQuadratic = function (a, b, c, val) {
  c -= val;

  var r = b * b - 4 * a * c;

  if (r < 0) {
    return [];
  }

  var sqrtR = Math.sqrt(r);
  var denom = 2 * a;
  var root1 = (-b + sqrtR) / denom;
  var root2 = (-b - sqrtR) / denom;

  return [root1, root2];
};

math.solveCubic = function (a, b, c, d, result) {

  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
  // r is the real component, i is the imaginary component

  // An implementation of the Cardano method from the year 1545
  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots

  b /= a;
  c /= a;
  d /= a;

  var discriminant = void 0,
      q = void 0,
      r = void 0,
      dum1 = void 0,
      s = void 0,
      t = void 0,
      term1 = void 0,
      r13 = void 0;

  q = (3.0 * c - b * b) / 9.0;
  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
  r /= 54.0;

  discriminant = q * q * q + r * r;
  result[1] = 0;
  term1 = b / 3.0;

  if (discriminant > 0) {
    s = r + Math.sqrt(discriminant);
    s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);
    t = r - Math.sqrt(discriminant);
    t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);
    result[0] = -term1 + s + t;
    term1 += (s + t) / 2.0;
    result[4] = result[2] = -term1;
    term1 = Math.sqrt(3.0) * (-t + s) / 2;
    result[3] = term1;
    result[5] = -term1;
    return;
  }

  result[5] = result[3] = 0;

  if (discriminant === 0) {
    r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);
    result[0] = -term1 + 2.0 * r13;
    result[4] = result[2] = -(r13 + term1);
    return;
  }

  q = -q;
  dum1 = q * q * q;
  dum1 = Math.acos(r / Math.sqrt(dum1));
  r13 = 2.0 * Math.sqrt(q);
  result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
  result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
  result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);

  return;
};

math.sqdistToQuadraticBezier = function (x, y, x1, y1, x2, y2, x3, y3) {

  // Find minimum distance by using the minimum of the distance
  // function between the given point and the curve

  // This gives the coefficients of the resulting cubic equation
  // whose roots tell us where a possible minimum is
  // (Coefficients are divided by 4)

  var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;

  var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;

  var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;

  var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y;

  // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);

  var roots = [];

  // Use the cubic solving algorithm
  this.solveCubic(a, b, c, d, roots);

  var zeroThreshold = 0.0000001;

  var params = [];

  for (var index = 0; index < 6; index += 2) {
    if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {
      params.push(roots[index]);
    }
  }

  params.push(1.0);
  params.push(0.0);

  var minDistanceSquared = -1;

  var curX = void 0,
      curY = void 0,
      distSquared = void 0;
  for (var i = 0; i < params.length; i++) {
    curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;

    curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;

    distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);
    // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
    if (minDistanceSquared >= 0) {
      if (distSquared < minDistanceSquared) {
        minDistanceSquared = distSquared;
      }
    } else {
      minDistanceSquared = distSquared;
    }
  }

  return minDistanceSquared;
};

math.sqdistToFiniteLine = function (x, y, x1, y1, x2, y2) {
  var offset = [x - x1, y - y1];
  var line = [x2 - x1, y2 - y1];

  var lineSq = line[0] * line[0] + line[1] * line[1];
  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];

  var dotProduct = offset[0] * line[0] + offset[1] * line[1];
  var adjSq = dotProduct * dotProduct / lineSq;

  if (dotProduct < 0) {
    return hypSq;
  }

  if (adjSq > lineSq) {
    return (x - x2) * (x - x2) + (y - y2) * (y - y2);
  }

  return hypSq - adjSq;
};

math.pointInsidePolygonPoints = function (x, y, points) {
  var x1 = void 0,
      y1 = void 0,
      x2 = void 0,
      y2 = void 0;
  var y3 = void 0;

  // Intersect with vertical line through (x, y)
  var up = 0;
  // let down = 0;
  for (var i = 0; i < points.length / 2; i++) {
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];

    if (i + 1 < points.length / 2) {
      x2 = points[(i + 1) * 2];
      y2 = points[(i + 1) * 2 + 1];
    } else {
      x2 = points[(i + 1 - points.length / 2) * 2];
      y2 = points[(i + 1 - points.length / 2) * 2 + 1];
    }

    if (x1 == x && x2 == x) {
      // then ignore
    } else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {

      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;

      if (y3 > y) {
        up++;
      }

      // if( y3 < y ){
      // down++;
      // }
    } else {
      continue;
    }
  }

  if (up % 2 === 0) {
    return false;
  } else {
    return true;
  }
};

math.pointInsidePolygon = function (x, y, basePoints, centerX, centerY, width, height, direction, padding) {

  //let direction = arguments[6];
  var transformedPoints = new Array(basePoints.length);

  // Gives negative angle
  var angle = void 0;

  if (direction[0] != null) {
    angle = Math.atan(direction[1] / direction[0]);

    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
  } else {
    angle = direction;
  }

  var cos = Math.cos(-angle);
  var sin = Math.sin(-angle);

  //    console.log("base: " + basePoints);
  for (var i = 0; i < transformedPoints.length / 2; i++) {
    transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);

    transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);

    transformedPoints[i * 2] += centerX;
    transformedPoints[i * 2 + 1] += centerY;
  }

  var points = void 0;

  if (padding > 0) {
    var expandedLineSet = this.expandPolygon(transformedPoints, -padding);

    points = this.joinLines(expandedLineSet);
  } else {
    points = transformedPoints;
  }

  return math.pointInsidePolygonPoints(x, y, points);
};

math.joinLines = function (lineSet) {

  var vertices = new Array(lineSet.length / 2);

  var currentLineStartX = void 0,
      currentLineStartY = void 0,
      currentLineEndX = void 0,
      currentLineEndY = void 0;
  var nextLineStartX = void 0,
      nextLineStartY = void 0,
      nextLineEndX = void 0,
      nextLineEndY = void 0;

  for (var i = 0; i < lineSet.length / 4; i++) {
    currentLineStartX = lineSet[i * 4];
    currentLineStartY = lineSet[i * 4 + 1];
    currentLineEndX = lineSet[i * 4 + 2];
    currentLineEndY = lineSet[i * 4 + 3];

    if (i < lineSet.length / 4 - 1) {
      nextLineStartX = lineSet[(i + 1) * 4];
      nextLineStartY = lineSet[(i + 1) * 4 + 1];
      nextLineEndX = lineSet[(i + 1) * 4 + 2];
      nextLineEndY = lineSet[(i + 1) * 4 + 3];
    } else {
      nextLineStartX = lineSet[0];
      nextLineStartY = lineSet[1];
      nextLineEndX = lineSet[2];
      nextLineEndY = lineSet[3];
    }

    var intersection = this.finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);

    vertices[i * 2] = intersection[0];
    vertices[i * 2 + 1] = intersection[1];
  }

  return vertices;
};

math.expandPolygon = function (points, pad) {

  var expandedLineSet = new Array(points.length * 2);

  var currentPointX = void 0,
      currentPointY = void 0,
      nextPointX = void 0,
      nextPointY = void 0;

  for (var i = 0; i < points.length / 2; i++) {
    currentPointX = points[i * 2];
    currentPointY = points[i * 2 + 1];

    if (i < points.length / 2 - 1) {
      nextPointX = points[(i + 1) * 2];
      nextPointY = points[(i + 1) * 2 + 1];
    } else {
      nextPointX = points[0];
      nextPointY = points[1];
    }

    // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]

    // Assume CCW polygon winding

    var offsetX = nextPointY - currentPointY;
    var offsetY = -(nextPointX - currentPointX);

    // Normalize
    var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
    var normalizedOffsetX = offsetX / offsetLength;
    var normalizedOffsetY = offsetY / offsetLength;

    expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
    expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
    expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
    expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
  }

  return expandedLineSet;
};

math.intersectLineEllipse = function (x, y, centerX, centerY, ellipseWradius, ellipseHradius) {

  var dispX = centerX - x;
  var dispY = centerY - y;

  dispX /= ellipseWradius;
  dispY /= ellipseHradius;

  var len = Math.sqrt(dispX * dispX + dispY * dispY);

  var newLength = len - 1;

  if (newLength < 0) {
    return [];
  }

  var lenProportion = newLength / len;

  return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
};

math.checkInEllipse = function (x, y, width, height, centerX, centerY, padding) {
  x -= centerX;
  y -= centerY;

  x /= width / 2 + padding;
  y /= height / 2 + padding;

  return x * x + y * y <= 1;
};

// Returns intersections of increasing distance from line's start point
math.intersectLineCircle = function (x1, y1, x2, y2, centerX, centerY, radius) {

  // Calculate d, direction vector of line
  var d = [x2 - x1, y2 - y1]; // Direction vector of line
  var f = [x1 - centerX, y1 - centerY];

  var a = d[0] * d[0] + d[1] * d[1];
  var b = 2 * (f[0] * d[0] + f[1] * d[1]);
  var c = f[0] * f[0] + f[1] * f[1] - radius * radius;

  var discriminant = b * b - 4 * a * c;

  if (discriminant < 0) {
    return [];
  }

  var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
  var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);

  var tMin = Math.min(t1, t2);
  var tMax = Math.max(t1, t2);
  var inRangeParams = [];

  if (tMin >= 0 && tMin <= 1) {
    inRangeParams.push(tMin);
  }

  if (tMax >= 0 && tMax <= 1) {
    inRangeParams.push(tMax);
  }

  if (inRangeParams.length === 0) {
    return [];
  }

  var nearIntersectionX = inRangeParams[0] * d[0] + x1;
  var nearIntersectionY = inRangeParams[0] * d[1] + y1;

  if (inRangeParams.length > 1) {

    if (inRangeParams[0] == inRangeParams[1]) {
      return [nearIntersectionX, nearIntersectionY];
    } else {

      var farIntersectionX = inRangeParams[1] * d[0] + x1;
      var farIntersectionY = inRangeParams[1] * d[1] + y1;

      return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
    }
  } else {
    return [nearIntersectionX, nearIntersectionY];
  }
};

math.findCircleNearPoint = function (centerX, centerY, radius, farX, farY) {

  var displacementX = farX - centerX;
  var displacementY = farY - centerY;
  var distance = Math.sqrt(displacementX * displacementX + displacementY * displacementY);

  var unitDisplacementX = displacementX / distance;
  var unitDisplacementY = displacementY / distance;

  return [centerX + unitDisplacementX * radius, centerY + unitDisplacementY * radius];
};

math.findMaxSqDistanceToOrigin = function (points) {
  var maxSqDistance = 0.000001;
  var sqDistance = void 0;

  for (var i = 0; i < points.length / 2; i++) {

    sqDistance = points[i * 2] * points[i * 2] + points[i * 2 + 1] * points[i * 2 + 1];

    if (sqDistance > maxSqDistance) {
      maxSqDistance = sqDistance;
    }
  }

  return maxSqDistance;
};

math.midOfThree = function (a, b, c) {
  if (b <= a && a <= c || c <= a && a <= b) {
    return a;
  } else if (a <= b && b <= c || c <= b && b <= a) {
    return b;
  } else {
    return c;
  }
};

// (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)
math.finiteLinesIntersect = function (x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {

  var dx13 = x1 - x3;
  var dx21 = x2 - x1;
  var dx43 = x4 - x3;

  var dy13 = y1 - y3;
  var dy21 = y2 - y1;
  var dy43 = y4 - y3;

  var ua_t = dx43 * dy13 - dy43 * dx13;
  var ub_t = dx21 * dy13 - dy21 * dx13;
  var u_b = dy43 * dx21 - dx43 * dy21;

  if (u_b !== 0) {
    var ua = ua_t / u_b;
    var ub = ub_t / u_b;

    var flptThreshold = 0.001;
    var min = 0 - flptThreshold;
    var max = 1 + flptThreshold;

    if (min <= ua && ua <= max && min <= ub && ub <= max) {
      return [x1 + ua * dx21, y1 + ua * dy21];
    } else {
      if (!infiniteLines) {
        return [];
      } else {
        return [x1 + ua * dx21, y1 + ua * dy21];
      }
    }
  } else {
    if (ua_t === 0 || ub_t === 0) {

      // Parallel, coincident lines. Check if overlap

      // Check endpoint of second line
      if (this.midOfThree(x1, x2, x4) === x4) {
        return [x4, y4];
      }

      // Check start point of second line
      if (this.midOfThree(x1, x2, x3) === x3) {
        return [x3, y3];
      }

      // Endpoint of first line
      if (this.midOfThree(x3, x4, x2) === x2) {
        return [x2, y2];
      }

      return [];
    } else {

      // Parallel, non-coincident
      return [];
    }
  }
};

// math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )
// intersect a node polygon (pts transformed)
//
// math.polygonIntersectLine( x, y, basePoints, centerX, centerY )
// intersect the points (no transform)
math.polygonIntersectLine = function (x, y, basePoints, centerX, centerY, width, height, padding) {

  var intersections = [];
  var intersection = void 0;

  var transformedPoints = new Array(basePoints.length);

  var doTransform = true;
  if (arguments.length === 5) {
    doTransform = false;
  }

  var points = void 0;

  if (doTransform) {
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
    }

    if (padding > 0) {
      var expandedLineSet = math.expandPolygon(transformedPoints, -padding);

      points = math.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
  } else {
    points = basePoints;
  }

  var currentX = void 0,
      currentY = void 0,
      nextX = void 0,
      nextY = void 0;

  for (var _i = 0; _i < points.length / 2; _i++) {

    currentX = points[_i * 2];
    currentY = points[_i * 2 + 1];

    if (_i < points.length / 2 - 1) {
      nextX = points[(_i + 1) * 2];
      nextY = points[(_i + 1) * 2 + 1];
    } else {
      nextX = points[0];
      nextY = points[1];
    }

    intersection = this.finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);

    if (intersection.length !== 0) {
      intersections.push(intersection[0], intersection[1]);
    }
  }

  return intersections;
};

math.shortenIntersection = function (intersection, offset, amount) {

  var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];

  var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);

  var lenRatio = (length - amount) / length;

  if (lenRatio < 0) {
    lenRatio = 0.00001;
  }

  return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
};

math.generateUnitNgonPointsFitToSquare = function (sides, rotationRadians) {
  var points = math.generateUnitNgonPoints(sides, rotationRadians);
  points = math.fitPolygonToSquare(points);

  return points;
};

math.fitPolygonToSquare = function (points) {
  var x = void 0,
      y = void 0;
  var sides = points.length / 2;
  var minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;

  for (var i = 0; i < sides; i++) {
    x = points[2 * i];
    y = points[2 * i + 1];

    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);
  }

  // stretch factors
  var sx = 2 / (maxX - minX);
  var sy = 2 / (maxY - minY);

  for (var _i2 = 0; _i2 < sides; _i2++) {
    x = points[2 * _i2] = points[2 * _i2] * sx;
    y = points[2 * _i2 + 1] = points[2 * _i2 + 1] * sy;

    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);
  }

  if (minY < -1) {
    for (var _i3 = 0; _i3 < sides; _i3++) {
      y = points[2 * _i3 + 1] = points[2 * _i3 + 1] + (-1 - minY);
    }
  }

  return points;
};

math.generateUnitNgonPoints = function (sides, rotationRadians) {

  var increment = 1.0 / sides * 2 * Math.PI;
  var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;

  startAngle += rotationRadians;

  var points = new Array(sides * 2);

  var currentAngle = void 0;
  for (var i = 0; i < sides; i++) {
    currentAngle = i * increment + startAngle;

    points[2 * i] = Math.cos(currentAngle); // x
    points[2 * i + 1] = Math.sin(-currentAngle); // y
  }

  return points;
};

math.getRoundRectangleRadius = function (width, height) {

  // Set the default radius, unless half of width or height is smaller than default
  return Math.min(width / 4, height / 4, 8);
};

math.getCutRectangleCornerLength = function () {
  return 8;
};

math.bezierPtsToQuadCoeff = function (p0, p1, p2) {
  return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];
};

math.getBarrelCurveConstants = function (width, height) {
  // get curve width, height, and control point position offsets as a percentage of node height / width
  return {
    heightOffset: Math.min(15, 0.05 * height),
    widthOffset: Math.min(100, 0.25 * width),
    ctrlPtOffsetPct: 0.05
  };
};

module.exports = math;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// use this module to cherry pick functions into your prototype
// (useful for functions shared between the core and collections, for example)

// e.g.
// let foo = define.foo({ /* params... */ })

var util = __webpack_require__(1);

var define = {};

[__webpack_require__(73), __webpack_require__(74), __webpack_require__(75)].forEach(function (m) {
  util.assign(define, m);
});

module.exports = define;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = typeof window === 'undefined' ? null : window; // eslint-disable-line no-undef

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
Licensed under The MIT License (http://opensource.org/licenses/MIT)
*/

/*  promise states [Promises/A+ 2.1]  */
var STATE_PENDING = 0; /*  [Promises/A+ 2.1.1]  */
var STATE_FULFILLED = 1; /*  [Promises/A+ 2.1.2]  */
var STATE_REJECTED = 2; /*  [Promises/A+ 2.1.3]  */

/*  promise object constructor  */
var api = function api(executor) {
  /*  optionally support non-constructor/plain-function call  */
  if (!(this instanceof api)) return new api(executor);

  /*  initialize object  */
  this.id = 'Thenable/1.0.7';
  this.state = STATE_PENDING; /*  initial state  */
  this.fulfillValue = undefined; /*  initial value  */ /*  [Promises/A+ 1.3, 2.1.2.2]  */
  this.rejectReason = undefined; /*  initial reason */ /*  [Promises/A+ 1.5, 2.1.3.2]  */
  this.onFulfilled = []; /*  initial handlers  */
  this.onRejected = []; /*  initial handlers  */

  /*  provide optional information-hiding proxy  */
  this.proxy = {
    then: this.then.bind(this)
  };

  /*  support optional executor function  */
  if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
};

/*  promise API methods  */
api.prototype = {
  /*  promise resolving methods  */
  fulfill: function fulfill(value) {
    return deliver(this, STATE_FULFILLED, 'fulfillValue', value);
  },
  reject: function reject(value) {
    return deliver(this, STATE_REJECTED, 'rejectReason', value);
  },

  /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
  then: function then(onFulfilled, onRejected) {
    var curr = this;
    var next = new api(); /*  [Promises/A+ 2.2.7]  */
    curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill')); /*  [Promises/A+ 2.2.2/2.2.6]  */
    curr.onRejected.push(resolver(onRejected, next, 'reject')); /*  [Promises/A+ 2.2.3/2.2.6]  */
    execute(curr);
    return next.proxy; /*  [Promises/A+ 2.2.7, 3.3]  */
  }
};

/*  deliver an action  */
var deliver = function deliver(curr, state, name, value) {
  if (curr.state === STATE_PENDING) {
    curr.state = state; /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
    curr[name] = value; /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
    execute(curr);
  }
  return curr;
};

/*  execute all handlers  */
var execute = function execute(curr) {
  if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);
};

/*  execute particular set of handlers  */
var execute_handlers = function execute_handlers(curr, name, value) {
  /* global setImmediate: true */
  /* global setTimeout: true */

  /*  short-circuit processing  */
  if (curr[name].length === 0) return;

  /*  iterate over all handlers, exactly once  */
  var handlers = curr[name];
  curr[name] = []; /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
  var func = function func() {
    for (var i = 0; i < handlers.length; i++) {
      handlers[i](value);
    } /*  [Promises/A+ 2.2.5]  */
  };

  /*  execute procedure asynchronously  */ /*  [Promises/A+ 2.2.4, 3.1]  */
  if (typeof setImmediate === 'function') setImmediate(func);else setTimeout(func, 0);
};

/*  generate a resolver function  */
var resolver = function resolver(cb, next, method) {
  return function (value) {
    if (typeof cb !== 'function') /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
      next[method].call(next, value); /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
    else {
        var result;
        try {
          result = cb(value);
        } /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
        catch (e) {
          next.reject(e); /*  [Promises/A+ 2.2.7.2]  */
          return;
        }
        resolve(next, result); /*  [Promises/A+ 2.2.7.1]  */
      }
  };
};

/*  "Promise Resolution Procedure"  */ /*  [Promises/A+ 2.3]  */
var resolve = function resolve(promise, x) {
  /*  sanity check arguments  */ /*  [Promises/A+ 2.3.1]  */
  if (promise === x || promise.proxy === x) {
    promise.reject(new TypeError('cannot resolve promise with itself'));
    return;
  }

  /*  surgically check for a "then" method
    (mainly to just call the "getter" of "then" only once)  */
  var then;
  if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null || typeof x === 'function') {
    try {
      then = x.then;
    } /*  [Promises/A+ 2.3.3.1, 3.5]  */
    catch (e) {
      promise.reject(e); /*  [Promises/A+ 2.3.3.2]  */
      return;
    }
  }

  /*  handle own Thenables    [Promises/A+ 2.3.2]
    and similar "thenables" [Promises/A+ 2.3.3]  */
  if (typeof then === 'function') {
    var resolved = false;
    try {
      /*  call retrieved "then" method */ /*  [Promises/A+ 2.3.3.3]  */
      then.call(x,
      /*  resolvePromise  */ /*  [Promises/A+ 2.3.3.3.1]  */
      function (y) {
        if (resolved) return;resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */
        if (y === x) /*  [Promises/A+ 3.6]  */
          promise.reject(new TypeError('circular thenable chain'));else resolve(promise, y);
      },

      /*  rejectPromise  */ /*  [Promises/A+ 2.3.3.3.2]  */
      function (r) {
        if (resolved) return;resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */
        promise.reject(r);
      });
    } catch (e) {
      if (!resolved) /*  [Promises/A+ 2.3.3.3.3]  */
        promise.reject(e); /*  [Promises/A+ 2.3.3.3.4]  */
    }
    return;
  }

  /*  handle other values  */
  promise.fulfill(x); /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
};

// so we always have Promise.all()
api.all = function (ps) {
  return new api(function (resolveAll, rejectAll) {
    var vals = new Array(ps.length);
    var doneCount = 0;

    var fulfill = function fulfill(i, val) {
      vals[i] = val;
      doneCount++;

      if (doneCount === ps.length) {
        resolveAll(vals);
      }
    };

    for (var i = 0; i < ps.length; i++) {
      (function (i) {
        var p = ps[i];
        var isPromise = p != null && p.then != null;

        if (isPromise) {
          p.then(function (val) {
            fulfill(i, val);
          }, function (err) {
            rejectAll(err);
          });
        } else {
          var val = p;
          fulfill(i, val);
        }
      })(i);
    }
  });
};

api.resolve = function (val) {
  return new api(function (resolve, reject) {
    resolve(val);
  });
};

api.reject = function (val) {
  return new api(function (resolve, reject) {
    reject(val);
  });
};

module.exports = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(142).setImmediate))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);
var newQuery = __webpack_require__(11);

var Selector = function Selector(selector) {
  var self = this;

  self._private = {
    selectorText: selector,
    invalid: true
  };

  if (selector == null || is.string(selector) && selector.match(/^\s*$/)) {

    self.length = 0;
  } else if (selector === '*' || selector === 'edge' || selector === 'node') {

    // make single, group-only selectors cheap to make and cheap to filter

    self[0] = newQuery();
    self[0].group = selector === '*' ? selector : selector + 's';
    self[0].groupOnly = true;
    self[0].length = 1;
    self._private.invalid = false;
    self.length = 1;
  } else if (is.elementOrCollection(selector)) {

    var collection = selector.collection();

    self[0] = newQuery();
    self[0].collection = collection;
    self[0].length = 1;
    self.length = 1;
  } else if (is.fn(selector)) {

    self[0] = newQuery();
    self[0].filter = selector;
    self[0].length = 1;
    self.length = 1;
  } else if (is.string(selector)) {
    if (!self.parse(selector)) {
      return;
    }
  } else {
    util.error('A selector must be created from a string; found ', selector);
    return;
  }

  self._private.invalid = false;
};

var selfn = Selector.prototype;

selfn.valid = function () {
  return !this._private.invalid;
};

selfn.invalid = function () {
  return this._private.invalid;
};

selfn.text = function () {
  return this._private.selectorText;
};

selfn.size = function () {
  return this.length;
};

selfn.eq = function (i) {
  return this[i];
};

selfn.sameText = function (otherSel) {
  return this.text() === otherSel.text();
};

selfn.toString = selfn.selector = function () {

  if (this._private.toStringCache != null) {
    return this._private.toStringCache;
  }

  var i = void 0;
  var str = '';

  var clean = function clean(obj) {
    if (obj == null) {
      return '';
    } else {
      return obj;
    }
  };

  var cleanVal = function cleanVal(val) {
    if (is.string(val)) {
      return '"' + val + '"';
    } else {
      return clean(val);
    }
  };

  var space = function space(val) {
    return ' ' + val + ' ';
  };

  var queryToString = function queryToString(query) {
    var str = '';
    var j = void 0,
        sel = void 0;

    if (query.subject === query) {
      str += '$';
    }

    var group = clean(query.group);
    str += group.substring(0, group.length - 1);

    for (j = 0; j < query.data.length; j++) {
      var data = query.data[j];

      if (data.value) {
        str += '[' + data.field + space(clean(data.operator)) + cleanVal(data.value) + ']';
      } else {
        str += '[' + clean(data.operator) + data.field + ']';
      }
    }

    for (j = 0; j < query.meta.length; j++) {
      var meta = query.meta[j];
      str += '[[' + meta.field + space(clean(meta.operator)) + cleanVal(meta.value) + ']]';
    }

    for (j = 0; j < query.colonSelectors.length; j++) {
      sel = query.colonSelectors[i];
      str += sel;
    }

    for (j = 0; j < query.ids.length; j++) {
      sel = '#' + query.ids[i];
      str += sel;
    }

    for (j = 0; j < query.classes.length; j++) {
      sel = '.' + query.classes[j];
      str += sel;
    }

    if (query.source != null && query.target != null) {
      str = queryToString(query.source) + ' -> ' + queryToString(query.target);
    }

    if (query.connectedNodes != null) {
      var n = query.connectedNodes;

      str = queryToString(n[0]) + ' <-> ' + queryToString(n[1]);
    }

    if (query.parent != null) {
      str = queryToString(query.parent) + ' > ' + str;
    }

    if (query.ancestor != null) {
      str = queryToString(query.ancestor) + ' ' + str;
    }

    if (query.child != null) {
      str += ' > ' + queryToString(query.child);
    }

    if (query.descendant != null) {
      str += ' ' + queryToString(query.descendant);
    }

    return str;
  };

  for (i = 0; i < this.length; i++) {
    var query = this[i];

    str += queryToString(query);

    if (this.length > 1 && i < this.length - 1) {
      str += ', ';
    }
  }

  this._private.toStringCache = str;

  return str;
};

[__webpack_require__(121), __webpack_require__(120)].forEach(function (p) {
  return util.assign(selfn, p);
});

module.exports = Selector;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);
var Map = __webpack_require__(118);
var Set = __webpack_require__(9);

var Element = __webpack_require__(13);

// factory for generating edge ids when no id is specified for a new element
var idFactory = {
  generate: function generate(cy, element, tryThisId) {
    var id = tryThisId != null ? tryThisId : util.uuid();

    while (cy.hasElementWithId(id)) {
      id = util.uuid();
    }

    return id;
  }
};

// represents a set of nodes, edges, or both together
var Collection = function Collection(cy, elements, options) {
  if (cy === undefined || !is.core(cy)) {
    util.error('A collection must have a reference to the core');
    return;
  }

  var map = new Map();
  var createdElements = false;

  if (!elements) {
    elements = [];
  } else if (elements.length > 0 && is.plainObject(elements[0]) && !is.element(elements[0])) {
    createdElements = true;

    // make elements from json and restore all at once later
    var eles = [];
    var elesIds = new Set();

    for (var i = 0, l = elements.length; i < l; i++) {
      var json = elements[i];

      if (json.data == null) {
        json.data = {};
      }

      var data = json.data;

      // make sure newly created elements have valid ids
      if (data.id == null) {
        data.id = idFactory.generate(cy, json);
      } else if (cy.hasElementWithId(data.id) || elesIds.has(data.id)) {
        continue; // can't create element if prior id already exists
      }

      var ele = new Element(cy, json, false);
      eles.push(ele);
      elesIds.add(data.id);
    }

    elements = eles;
  }

  this.length = 0;

  for (var _i = 0, _l = elements.length; _i < _l; _i++) {
    var element = elements[_i];
    if (element == null) {
      continue;
    }

    var id = element._private.data.id;

    if (options == null || options.unique && !map.has(id)) {
      map.set(id, {
        index: this.length,
        ele: element
      });

      this[this.length] = element;
      this.length++;
    }
  }

  this._private = {
    cy: cy,
    map: map
  };

  // restore the elements if we created them from json
  if (createdElements) {
    this.restore();
  }
};

// Functions
////////////////////////////////////////////////////////////////////////////////////////////////////

// keep the prototypes in sync (an element has the same functions as a collection)
// and use elefn and elesfn as shorthands to the prototypes
var elesfn = Element.prototype = Collection.prototype;

elesfn.instanceString = function () {
  return 'collection';
};

elesfn.spawn = function (cy, eles, opts) {
  if (!is.core(cy)) {
    // cy is optional
    opts = eles;
    eles = cy;
    cy = this.cy();
  }

  return new Collection(cy, eles, opts);
};

elesfn.spawnSelf = function () {
  return this.spawn(this);
};

elesfn.cy = function () {
  return this._private.cy;
};

elesfn.renderer = function () {
  return this._private.cy.renderer();
};

elesfn.element = function () {
  return this[0];
};

elesfn.collection = function () {
  if (is.collection(this)) {
    return this;
  } else {
    // an element
    return new Collection(this._private.cy, [this]);
  }
};

elesfn.unique = function () {
  return new Collection(this._private.cy, this, { unique: true });
};

elesfn.hasElementWithId = function (id) {
  return this._private.map.has(id);
};

elesfn.getElementById = function (id) {
  var cy = this._private.cy;
  var entry = this._private.map.get(id);

  return entry ? entry.ele : new Collection(cy); // get ele or empty collection
};

elesfn.$id = elesfn.getElementById;

elesfn.poolIndex = function () {
  var cy = this._private.cy;
  var eles = cy._private.elements;
  var id = this._private.data.id;

  return eles._private.map.get(id).index;
};

elesfn.json = function (obj) {
  var ele = this.element();
  var cy = this.cy();

  if (ele == null && obj) {
    return this;
  } // can't set to no eles

  if (ele == null) {
    return undefined;
  } // can't get from no eles

  var p = ele._private;

  if (is.plainObject(obj)) {
    // set

    cy.startBatch();

    if (obj.data) {
      ele.data(obj.data);
    }

    if (obj.position) {
      ele.position(obj.position);
    }

    // ignore group -- immutable

    var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {
      var obj_k = obj[k];

      if (obj_k != null && obj_k !== p[k]) {
        if (obj_k) {
          ele[trueFnName]();
        } else {
          ele[falseFnName]();
        }
      }
    };

    checkSwitch('removed', 'remove', 'restore');

    checkSwitch('selected', 'select', 'unselect');

    checkSwitch('selectable', 'selectify', 'unselectify');

    checkSwitch('locked', 'lock', 'unlock');

    checkSwitch('grabbable', 'grabify', 'ungrabify');

    if (obj.classes != null) {
      ele.classes(obj.classes);
    }

    cy.endBatch();

    return this;
  } else if (obj === undefined) {
    // get

    var json = {
      data: util.copy(p.data),
      position: util.copy(p.position),
      group: p.group,
      removed: p.removed,
      selected: p.selected,
      selectable: p.selectable,
      locked: p.locked,
      grabbable: p.grabbable,
      classes: null
    };

    json.classes = '';

    var i = 0;
    p.classes.forEach(function (cls) {
      return json.classes += i++ === 0 ? cls : ' ' + cls;
    });

    return json;
  }
};

elesfn.jsons = function () {
  var jsons = [];

  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var json = ele.json();

    jsons.push(json);
  }

  return jsons;
};

elesfn.clone = function () {
  var cy = this.cy();
  var elesArr = [];

  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var json = ele.json();
    var clone = new Element(cy, json, false); // NB no restore

    elesArr.push(clone);
  }

  return new Collection(cy, elesArr);
};
elesfn.copy = elesfn.clone;

elesfn.restore = function (notifyRenderer) {
  var self = this;
  var cy = self.cy();
  var cy_p = cy._private;

  if (notifyRenderer === undefined) {
    notifyRenderer = true;
  }

  // create arrays of nodes and edges, since we need to
  // restore the nodes first
  var nodes = [];
  var edges = [];
  var elements = void 0;
  for (var _i2 = 0, l = self.length; _i2 < l; _i2++) {
    var ele = self[_i2];

    if (!ele.removed()) {
      // don't need to handle this ele
      continue;
    }

    // keep nodes first in the array and edges after
    if (ele.isNode()) {
      // put to front of array if node
      nodes.push(ele);
    } else {
      // put to end of array if edge
      edges.push(ele);
    }
  }

  elements = nodes.concat(edges);

  var i = void 0;
  var removeFromElements = function removeFromElements() {
    elements.splice(i, 1);
    i--;
  };

  // now, restore each element
  for (i = 0; i < elements.length; i++) {
    var _ele = elements[i];

    var _private = _ele._private;
    var data = _private.data;

    // the traversal cache should start fresh when ele is added
    _ele.clearTraversalCache();

    // set id and validate
    if (data.id === undefined) {
      data.id = idFactory.generate(cy, _ele);
    } else if (is.number(data.id)) {
      data.id = '' + data.id; // now it's a string
    } else if (is.emptyString(data.id) || !is.string(data.id)) {
      util.error('Can not create element with invalid string ID `' + data.id + '`');

      // can't create element if it has empty string as id or non-string id
      removeFromElements();
      continue;
    } else if (cy.hasElementWithId(data.id)) {
      util.error('Can not create second element with ID `' + data.id + '`');

      // can't create element if one already has that id
      removeFromElements();
      continue;
    }

    var id = data.id; // id is finalised, now let's keep a ref

    if (_ele.isNode()) {
      // extra checks for nodes
      var pos = _private.position;

      // make sure the nodes have a defined position

      if (pos.x == null) {
        pos.x = 0;
      }

      if (pos.y == null) {
        pos.y = 0;
      }
    }

    if (_ele.isEdge()) {
      // extra checks for edges

      var edge = _ele;
      var fields = ['source', 'target'];
      var fieldsLength = fields.length;
      var badSourceOrTarget = false;
      for (var j = 0; j < fieldsLength; j++) {

        var field = fields[j];
        var val = data[field];

        if (is.number(val)) {
          val = data[field] = '' + data[field]; // now string
        }

        if (val == null || val === '') {
          // can't create if source or target is not defined properly
          util.error('Can not create edge `' + id + '` with unspecified ' + field);
          badSourceOrTarget = true;
        } else if (!cy.hasElementWithId(val)) {
          // can't create edge if one of its nodes doesn't exist
          util.error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
          badSourceOrTarget = true;
        }
      }

      if (badSourceOrTarget) {
        removeFromElements();continue;
      } // can't create this

      var src = cy.getElementById(data.source);
      var tgt = cy.getElementById(data.target);

      src._private.edges.push(edge);
      tgt._private.edges.push(edge);

      edge._private.source = src;
      edge._private.target = tgt;
    } // if is edge

    // create mock ids / indexes maps for element so it can be used like collections
    _private.map = new Map();
    _private.map.set(id, { ele: _ele, index: 0 });

    _private.removed = false;
    cy.addToPool(_ele);
  } // for each element

  // do compound node sanity checks
  for (var _i3 = 0; _i3 < nodes.length; _i3++) {
    // each node
    var node = nodes[_i3];
    var _data = node._private.data;

    if (is.number(_data.parent)) {
      // then automake string
      _data.parent = '' + _data.parent;
    }

    var parentId = _data.parent;

    var specifiedParent = parentId != null;

    if (specifiedParent) {
      var parent = cy.getElementById(parentId);

      if (parent.empty()) {
        // non-existant parent; just remove it
        _data.parent = undefined;
      } else {
        var selfAsParent = false;
        var ancestor = parent;
        while (!ancestor.empty()) {
          if (node.same(ancestor)) {
            // mark self as parent and remove from data
            selfAsParent = true;
            _data.parent = undefined; // remove parent reference

            // exit or we loop forever
            break;
          }

          ancestor = ancestor.parent();
        }

        if (!selfAsParent) {
          // connect with children
          parent[0]._private.children.push(node);
          node._private.parent = parent[0];

          // let the core know we have a compound graph
          cy_p.hasCompoundNodes = true;
        }
      } // else
    } // if specified parent
  } // for each node

  if (elements.length > 0) {
    var restored = new Collection(cy, elements);

    for (var _i4 = 0; _i4 < restored.length; _i4++) {
      var _ele2 = restored[_i4];

      if (_ele2.isNode()) {
        continue;
      }

      // adding an edge invalidates the traversal caches for the parallel edges
      _ele2.parallelEdges().clearTraversalCache();

      // adding an edge invalidates the traversal cache for the connected nodes
      _ele2.source().clearTraversalCache();
      _ele2.target().clearTraversalCache();
    }

    var toUpdateStyle = void 0;

    if (cy_p.hasCompoundNodes) {
      toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());
    } else {
      toUpdateStyle = restored;
    }

    toUpdateStyle.dirtyCompoundBoundsCache().updateStyle(notifyRenderer);

    if (notifyRenderer) {
      restored.emitAndNotify('add');
    } else {
      restored.emit('add');
    }
  }

  return self; // chainability
};

elesfn.removed = function () {
  var ele = this[0];
  return ele && ele._private.removed;
};

elesfn.inside = function () {
  var ele = this[0];
  return ele && !ele._private.removed;
};

elesfn.remove = function (notifyRenderer) {
  var self = this;
  var removed = [];
  var elesToRemove = [];
  var elesToRemoveIds = {};
  var cy = self._private.cy;

  if (notifyRenderer === undefined) {
    notifyRenderer = true;
  }

  // add connected edges
  function addConnectedEdges(node) {
    var edges = node._private.edges;
    for (var i = 0; i < edges.length; i++) {
      add(edges[i]);
    }
  }

  // add descendant nodes
  function addChildren(node) {
    var children = node._private.children;

    for (var i = 0; i < children.length; i++) {
      add(children[i]);
    }
  }

  function add(ele) {
    var alreadyAdded = elesToRemoveIds[ele.id()];
    if (alreadyAdded) {
      return;
    } else {
      elesToRemoveIds[ele.id()] = true;
    }

    if (ele.isNode()) {
      elesToRemove.push(ele); // nodes are removed last

      addConnectedEdges(ele);
      addChildren(ele);
    } else {
      elesToRemove.unshift(ele); // edges are removed first
    }
  }

  // make the list of elements to remove
  // (may be removing more than specified due to connected edges etc)

  for (var i = 0, l = self.length; i < l; i++) {
    var ele = self[i];

    add(ele);
  }

  function removeEdgeRef(node, edge) {
    var connectedEdges = node._private.edges;

    util.removeFromArray(connectedEdges, edge);

    // removing an edges invalidates the traversal cache for its nodes
    node.clearTraversalCache();
  }

  function removeParallelRefs(edge) {
    // removing an edge invalidates the traversal caches for the parallel edges
    edge.parallelEdges().clearTraversalCache();
  }

  var alteredParents = [];
  alteredParents.ids = {};

  function removeChildRef(parent, ele) {
    ele = ele[0];
    parent = parent[0];

    var children = parent._private.children;
    var pid = parent.id();

    util.removeFromArray(children, ele);

    if (!alteredParents.ids[pid]) {
      alteredParents.ids[pid] = true;
      alteredParents.push(parent);
    }
  }

  self.dirtyCompoundBoundsCache();

  cy.removeFromPool(elesToRemove); // remove from core pool

  for (var _i5 = 0; _i5 < elesToRemove.length; _i5++) {
    var _ele3 = elesToRemove[_i5];

    // mark as removed
    _ele3._private.removed = true;

    // add to list of removed elements
    removed.push(_ele3);

    if (_ele3.isEdge()) {
      // remove references to this edge in its connected nodes
      var src = _ele3.source()[0];
      var tgt = _ele3.target()[0];

      removeEdgeRef(src, _ele3);
      removeEdgeRef(tgt, _ele3);
      removeParallelRefs(_ele3);
    } else {
      // remove reference to parent
      var parent = _ele3.parent();

      if (parent.length !== 0) {
        removeChildRef(parent, _ele3);
      }
    }
  }

  // check to see if we have a compound graph or not
  var elesStillInside = cy._private.elements;
  cy._private.hasCompoundNodes = false;
  for (var _i6 = 0; _i6 < elesStillInside.length; _i6++) {
    var _ele4 = elesStillInside[_i6];

    if (_ele4.isParent()) {
      cy._private.hasCompoundNodes = true;
      break;
    }
  }

  var removedElements = new Collection(this.cy(), removed);
  if (removedElements.size() > 0) {
    // must manually notify since trigger won't do this automatically once removed

    if (notifyRenderer) {
      this.cy().notify({
        type: 'remove',
        eles: removedElements
      });
    }

    removedElements.emit('remove');
  }

  // the parents who were modified by the removal need their style updated
  for (var _i7 = 0; _i7 < alteredParents.length; _i7++) {
    var _ele5 = alteredParents[_i7];

    if (!_ele5.removed()) {
      _ele5.updateStyle();
    }
  }

  return new Collection(cy, removed);
};

elesfn.move = function (struct) {
  var cy = this._private.cy;

  if (struct.source !== undefined || struct.target !== undefined) {
    var srcId = struct.source;
    var tgtId = struct.target;
    var srcExists = cy.hasElementWithId(srcId);
    var tgtExists = cy.hasElementWithId(tgtId);

    if (srcExists || tgtExists) {
      var jsons = this.jsons();

      this.remove();

      for (var i = 0; i < jsons.length; i++) {
        var json = jsons[i];
        var ele = this[i];

        if (json.group === 'edges') {
          if (srcExists) {
            json.data.source = srcId;
          }

          if (tgtExists) {
            json.data.target = tgtId;
          }

          json.scratch = ele._private.scratch;
        }
      }

      return cy.add(jsons);
    }
  } else if (struct.parent !== undefined) {
    // move node to new parent
    var parentId = struct.parent;
    var parentExists = parentId === null || cy.hasElementWithId(parentId);

    if (parentExists) {
      var _jsons = this.jsons();
      var descs = this.descendants();
      var descsEtcJsons = descs.union(descs.union(this).connectedEdges()).jsons();

      this.remove(); // NB: also removes descendants and their connected edges

      for (var _i8 = 0; _i8 < _jsons.length; _i8++) {
        var _json = _jsons[_i8];
        var _ele6 = this[_i8];

        if (_json.group === 'nodes') {
          _json.data.parent = parentId === null ? undefined : parentId;

          _json.scratch = _ele6._private.scratch;
        }
      }

      return cy.add(_jsons.concat(descsEtcJsons));
    }
  }

  return this; // if nothing done
};

[__webpack_require__(33), __webpack_require__(37), __webpack_require__(38), __webpack_require__(39), __webpack_require__(40), __webpack_require__(41), __webpack_require__(42), __webpack_require__(45), __webpack_require__(48), __webpack_require__(49), __webpack_require__(50), __webpack_require__(7), __webpack_require__(51), __webpack_require__(52), __webpack_require__(53), __webpack_require__(54), __webpack_require__(55)].forEach(function (props) {
  util.extend(elesfn, props);
});

module.exports = Collection;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(137);

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* global Set */

var undef =  true ? 'undefined' : _typeof(undefined);

var ObjectSet = function () {
  function ObjectSet(arrayOrObjectSet) {
    _classCallCheck(this, ObjectSet);

    this._obj = Object.create(null);

    if (arrayOrObjectSet != null) {
      var arr = void 0;

      if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {
        arr = arrayOrObjectSet.toArray();
      } else {
        arr = arrayOrObjectSet;
      }

      for (var i = 0; i < arr.length; i++) {
        this.add(arr[i]);
      }
    }
  }

  _createClass(ObjectSet, [{
    key: 'instanceString',
    value: function instanceString() {
      return 'set';
    }
  }, {
    key: 'add',
    value: function add(val) {
      this._obj[val] = 1;
    }
  }, {
    key: 'delete',
    value: function _delete(val) {
      this._obj[val] = 0;
    }
  }, {
    key: 'clear',
    value: function clear() {
      this._obj = Object.create(null);
    }
  }, {
    key: 'has',
    value: function has(val) {
      return this._obj[val] === 1;
    }
  }, {
    key: 'toArray',
    value: function toArray() {
      var _this = this;

      return Object.keys(this._obj).filter(function (key) {
        return _this.has(key);
      });
    }
  }, {
    key: 'forEach',
    value: function forEach(callback, thisArg) {
      return this.toArray().forEach(callback, thisArg);
    }
  }, {
    key: 'size',
    get: function get() {
      return this.toArray().length;
    }
  }]);

  return ObjectSet;
}();

// TODO use the stdlib Set in future...
// module.exports = typeof Set !== undef ? Set : ObjectSet;


module.exports = ObjectSet;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);
var Event = __webpack_require__(15);

var eventRegex = /^([^.]+)(\.(?:[^.]+))?$/; // regex for matching event strings (e.g. "click.namespace")
var universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally

var defaults = {
  qualifierCompare: function qualifierCompare(q1, q2) {
    return q1 === q2;
  },
  eventMatches: function eventMatches() /*context, listener, eventObj*/{
    return true;
  },
  eventFields: function eventFields() /*context*/{
    return {};
  },
  callbackContext: function callbackContext(context /*, listener, eventObj*/) {
    return context;
  },
  beforeEmit: function beforeEmit() /* context, listener, eventObj */{},
  afterEmit: function afterEmit() /* context, listener, eventObj */{},
  bubble: function bubble() /*context*/{
    return false;
  },
  parent: function parent() /*context*/{
    return null;
  },
  context: undefined
};

function Emitter(opts) {
  util.assign(this, defaults, opts);

  this.listeners = [];
  this.emitting = 0;
}

var p = Emitter.prototype;

var forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {
  if (is.fn(qualifier)) {
    callback = qualifier;
    qualifier = null;
  }

  if (confOverrides) {
    if (conf == null) {
      conf = confOverrides;
    } else {
      conf = util.assign({}, conf, confOverrides);
    }
  }

  var eventList = events.split(/\s+/);

  for (var i = 0; i < eventList.length; i++) {
    var evt = eventList[i];

    if (is.emptyString(evt)) {
      continue;
    }

    var match = evt.match(eventRegex); // type[.namespace]

    if (match) {
      var type = match[1];
      var namespace = match[2] ? match[2] : null;
      var ret = handler(self, evt, type, namespace, qualifier, callback, conf);

      if (ret === false) {
        break;
      } // allow exiting early
    }
  }
};

var makeEventObj = function makeEventObj(self, obj) {
  return new Event(obj.type, util.assign(obj, self.eventFields(self.context)));
};

var forEachEventObj = function forEachEventObj(self, handler, events) {
  if (is.event(events)) {
    handler(self, events);

    return;
  } else if (is.plainObject(events)) {
    handler(self, makeEventObj(self, events));

    return;
  }

  var eventList = events.split(/\s+/);

  for (var i = 0; i < eventList.length; i++) {
    var evt = eventList[i];

    if (is.emptyString(evt)) {
      continue;
    }

    var match = evt.match(eventRegex); // type[.namespace]

    if (match) {
      var type = match[1];
      var namespace = match[2] ? match[2] : null;
      var eventObj = makeEventObj(self, {
        type: type,
        namespace: namespace,
        target: self.context
      });

      handler(self, eventObj);
    }
  }
};

p.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {
  forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {
    if (is.fn(callback)) {
      self.listeners.push({
        event: event, // full event string
        callback: callback, // callback to run
        type: type, // the event type (e.g. 'click')
        namespace: namespace, // the event namespace (e.g. ".foo")
        qualifier: qualifier, // a restriction on whether to match this emitter
        conf: conf // additional configuration
      });
    }
  }, events, qualifier, callback, conf, confOverrides);

  return this;
};

p.one = function (events, qualifier, callback, conf) {
  return this.on(events, qualifier, callback, conf, { one: true });
};

p.removeListener = p.off = function (events, qualifier, callback, conf) {
  var _this = this;

  if (this.emitting !== 0) {
    this.listeners = util.copyArray(this.listeners);
  }

  var listeners = this.listeners;

  var _loop = function _loop(i) {
    var listener = listeners[i];

    forEachEvent(_this, function (self, event, type, namespace, qualifier, callback /*, conf*/) {
      if (listener.type === type && (!namespace || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {
        listeners.splice(i, 1);

        return false;
      }
    }, events, qualifier, callback, conf);
  };

  for (var i = listeners.length - 1; i >= 0; i--) {
    _loop(i);
  }

  return this;
};

p.emit = p.trigger = function (events, extraParams, manualCallback) {
  var listeners = this.listeners;
  var numListenersBeforeEmit = listeners.length;

  this.emitting++;

  if (!is.array(extraParams)) {
    extraParams = [extraParams];
  }

  forEachEventObj(this, function (self, eventObj) {
    if (manualCallback != null) {
      listeners = [{
        event: eventObj.event,
        type: eventObj.type,
        namespace: eventObj.namespace,
        callback: manualCallback
      }];

      numListenersBeforeEmit = listeners.length;
    }

    var _loop2 = function _loop2(i) {
      var listener = listeners[i];

      if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {
        var args = [eventObj];

        if (extraParams != null) {
          util.push(args, extraParams);
        }

        self.beforeEmit(self.context, listener, eventObj);

        if (listener.conf && listener.conf.one) {
          self.listeners = self.listeners.filter(function (l) {
            return l !== listener;
          });
        }

        var context = self.callbackContext(self.context, listener, eventObj);
        var ret = listener.callback.apply(context, args);

        self.afterEmit(self.context, listener, eventObj);

        if (ret === false) {
          eventObj.stopPropagation();
          eventObj.preventDefault();
        }
      } // if listener matches
    };

    for (var i = 0; i < numListenersBeforeEmit; i++) {
      _loop2(i);
    } // for listener

    if (self.bubble(self.context) && !eventObj.isPropagationStopped()) {
      self.parent(self.context).emit(eventObj, extraParams);
    }
  }, events);

  this.emitting--;

  return this;
};

module.exports = Emitter;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// storage for parsed queries
var newQuery = function newQuery() {
  return {
    classes: [],
    colonSelectors: [],
    data: [],
    group: null,
    ids: [],
    meta: [],

    // fake selectors
    collection: null, // a collection to match against
    filter: null, // filter function

    // these are defined in the upward direction rather than down (e.g. child)
    // because we need to go up in Selector.filter()
    parent: null, // parent query obj
    ancestor: null, // ancestor query obj
    subject: null, // defines subject in compound query (subject query obj; points to self if subject)

    // use these only when subject has been defined
    child: null,
    descendant: null
  };
};

module.exports = newQuery;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var window = __webpack_require__(4);
var util = __webpack_require__(1);
var Collection = __webpack_require__(7);
var is = __webpack_require__(0);
var Promise = __webpack_require__(5);
var define = __webpack_require__(3);

var Core = function Core(opts) {
  var cy = this;

  opts = util.extend({}, opts);

  var container = opts.container;

  // allow for passing a wrapped jquery object
  // e.g. cytoscape({ container: $('#cy') })
  if (container && !is.htmlElement(container) && is.htmlElement(container[0])) {
    container = container[0];
  }

  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
  reg = reg || {};

  if (reg && reg.cy) {
    reg.cy.destroy();

    reg = {}; // old instance => replace reg completely
  }

  var readies = reg.readies = reg.readies || [];

  if (container) {
    container._cyreg = reg;
  } // make sure container assoc'd reg points to this cy
  reg.cy = cy;

  var head = window !== undefined && container !== undefined && !opts.headless;
  var options = opts;
  options.layout = util.extend({ name: head ? 'grid' : 'null' }, options.layout);
  options.renderer = util.extend({ name: head ? 'canvas' : 'null' }, options.renderer);

  var defVal = function defVal(def, val, altVal) {
    if (val !== undefined) {
      return val;
    } else if (altVal !== undefined) {
      return altVal;
    } else {
      return def;
    }
  };

  var _p = this._private = {
    container: container, // html dom ele container
    ready: false, // whether ready has been triggered
    options: options, // cached options
    elements: new Collection(this), // elements in the graph
    listeners: [], // list of listeners
    aniEles: new Collection(this), // elements being animated
    scratch: {}, // scratch object for core
    layout: null,
    renderer: null,
    destroyed: false, // whether destroy was called
    notificationsEnabled: true, // whether notifications are sent to the renderer
    minZoom: 1e-50,
    maxZoom: 1e50,
    zoomingEnabled: defVal(true, options.zoomingEnabled),
    userZoomingEnabled: defVal(true, options.userZoomingEnabled),
    panningEnabled: defVal(true, options.panningEnabled),
    userPanningEnabled: defVal(true, options.userPanningEnabled),
    boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),
    autolock: defVal(false, options.autolock, options.autolockNodes),
    autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
    autounselectify: defVal(false, options.autounselectify),
    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
    zoom: is.number(options.zoom) ? options.zoom : 1,
    pan: {
      x: is.plainObject(options.pan) && is.number(options.pan.x) ? options.pan.x : 0,
      y: is.plainObject(options.pan) && is.number(options.pan.y) ? options.pan.y : 0
    },
    animation: { // object for currently-running animations
      current: [],
      queue: []
    },
    hasCompoundNodes: false
  };

  this.createEmitter();

  // set selection type
  var selType = options.selectionType;
  if (selType === undefined || selType !== 'additive' && selType !== 'single') {
    // then set default

    _p.selectionType = 'single';
  } else {
    _p.selectionType = selType;
  }

  // init zoom bounds
  if (is.number(options.minZoom) && is.number(options.maxZoom) && options.minZoom < options.maxZoom) {
    _p.minZoom = options.minZoom;
    _p.maxZoom = options.maxZoom;
  } else if (is.number(options.minZoom) && options.maxZoom === undefined) {
    _p.minZoom = options.minZoom;
  } else if (is.number(options.maxZoom) && options.minZoom === undefined) {
    _p.maxZoom = options.maxZoom;
  }

  var loadExtData = function loadExtData(extData, next) {
    var anyIsPromise = extData.some(is.promise);

    if (anyIsPromise) {
      return Promise.all(extData).then(next); // load all data asynchronously, then exec rest of init
    } else {
      next(extData); // exec synchronously for convenience
    }
  };

  // start with the default stylesheet so we have something before loading an external stylesheet
  if (_p.styleEnabled) {
    cy.setStyle([]);
  }

  // create the renderer
  cy.initRenderer(util.extend({
    hideEdgesOnViewport: options.hideEdgesOnViewport,
    textureOnViewport: options.textureOnViewport,
    wheelSensitivity: is.number(options.wheelSensitivity) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,
    motionBlur: options.motionBlur === undefined ? false : options.motionBlur, // off by default
    motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,
    pixelRatio: is.number(options.pixelRatio) && options.pixelRatio > 0 ? options.pixelRatio : undefined,
    desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,
    touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold
  }, options.renderer));

  var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {
    cy.notifications(false);

    // remove old elements
    var oldEles = cy.mutableElements();
    if (oldEles.length > 0) {
      oldEles.remove();
    }

    if (elements != null) {
      if (is.plainObject(elements) || is.array(elements)) {
        cy.add(elements);
      }
    }

    cy.one('layoutready', function (e) {
      cy.notifications(true);
      cy.emit(e); // we missed this event by turning notifications off, so pass it on

      cy.notify({
        type: 'load',
        eles: cy.mutableElements()
      });

      cy.one('load', onload);
      cy.emit('load');
    }).one('layoutstop', function () {
      cy.one('done', ondone);
      cy.emit('done');
    });

    var layoutOpts = util.extend({}, cy._private.options.layout);
    layoutOpts.eles = cy.elements();

    cy.layout(layoutOpts).run();
  };

  loadExtData([options.style, options.elements], function (thens) {
    var initStyle = thens[0];
    var initEles = thens[1];

    // init style
    if (_p.styleEnabled) {
      cy.style().append(initStyle);
    }

    // initial load
    setElesAndLayout(initEles, function () {
      // onready
      cy.startAnimationLoop();
      _p.ready = true;

      // if a ready callback is specified as an option, the bind it
      if (is.fn(options.ready)) {
        cy.on('ready', options.ready);
      }

      // bind all the ready handlers registered before creating this instance
      for (var i = 0; i < readies.length; i++) {
        var fn = readies[i];
        cy.on('ready', fn);
      }
      if (reg) {
        reg.readies = [];
      } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc

      cy.emit('ready');
    }, options.done);
  });
};

var corefn = Core.prototype; // short alias

util.extend(corefn, {
  instanceString: function instanceString() {
    return 'core';
  },

  isReady: function isReady() {
    return this._private.ready;
  },

  isDestroyed: function isDestroyed() {
    return this._private.destroyed;
  },

  ready: function ready(fn) {
    if (this.isReady()) {
      this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event
    } else {
      this.on('ready', fn);
    }

    return this;
  },

  destroy: function destroy() {
    var cy = this;
    if (cy.isDestroyed()) return;

    cy.stopAnimationLoop();

    cy.destroyRenderer();

    this.emit('destroy');

    cy._private.destroyed = true;

    return cy;
  },

  hasElementWithId: function hasElementWithId(id) {
    return this._private.elements.hasElementWithId(id);
  },

  getElementById: function getElementById(id) {
    return this._private.elements.getElementById(id);
  },

  selectionType: function selectionType() {
    return this._private.selectionType;
  },

  hasCompoundNodes: function hasCompoundNodes() {
    return this._private.hasCompoundNodes;
  },

  headless: function headless() {
    return this._private.options.renderer.name === 'null';
  },

  styleEnabled: function styleEnabled() {
    return this._private.styleEnabled;
  },

  addToPool: function addToPool(eles) {
    this._private.elements.merge(eles);

    return this; // chaining
  },

  removeFromPool: function removeFromPool(eles) {
    this._private.elements.unmerge(eles);

    return this;
  },

  container: function container() {
    return this._private.container;
  },

  options: function options() {
    return util.copy(this._private.options);
  },

  json: function json(obj) {
    var cy = this;
    var _p = cy._private;
    var eles = cy.mutableElements();

    if (is.plainObject(obj)) {
      // set

      cy.startBatch();

      if (obj.elements) {
        var idInJson = {};

        var updateEles = function updateEles(jsons, gr) {
          for (var i = 0; i < jsons.length; i++) {
            var json = jsons[i];
            var id = json.data.id;
            var ele = cy.getElementById(id);

            idInJson[id] = true;

            if (ele.length !== 0) {
              // existing element should be updated
              ele.json(json);
            } else {
              // otherwise should be added
              if (gr) {
                cy.add(util.extend({ group: gr }, json));
              } else {
                cy.add(json);
              }
            }
          }
        };

        if (is.array(obj.elements)) {
          // elements: []
          updateEles(obj.elements);
        } else {
          // elements: { nodes: [], edges: [] }
          var grs = ['nodes', 'edges'];
          for (var i = 0; i < grs.length; i++) {
            var gr = grs[i];
            var elements = obj.elements[gr];

            if (is.array(elements)) {
              updateEles(elements, gr);
            }
          }
        }

        // elements not specified in json should be removed
        eles.stdFilter(function (ele) {
          return !idInJson[ele.id()];
        }).remove();
      }

      if (obj.style) {
        cy.style(obj.style);
      }

      if (obj.zoom != null && obj.zoom !== _p.zoom) {
        cy.zoom(obj.zoom);
      }

      if (obj.pan) {
        if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {
          cy.pan(obj.pan);
        }
      }

      var fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify'];

      for (var _i = 0; _i < fields.length; _i++) {
        var f = fields[_i];

        if (obj[f] != null) {
          cy[f](obj[f]);
        }
      }

      cy.endBatch();

      return this; // chaining
    } else if (obj === undefined) {
      // get
      var json = {};

      json.elements = {};
      eles.forEach(function (ele) {
        var group = ele.group();

        if (!json.elements[group]) {
          json.elements[group] = [];
        }

        json.elements[group].push(ele.json());
      });

      if (this._private.styleEnabled) {
        json.style = cy.style().json();
      }

      json.zoomingEnabled = cy._private.zoomingEnabled;
      json.userZoomingEnabled = cy._private.userZoomingEnabled;
      json.zoom = cy._private.zoom;
      json.minZoom = cy._private.minZoom;
      json.maxZoom = cy._private.maxZoom;
      json.panningEnabled = cy._private.panningEnabled;
      json.userPanningEnabled = cy._private.userPanningEnabled;
      json.pan = util.copy(cy._private.pan);
      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;
      json.renderer = util.copy(cy._private.options.renderer);
      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;
      json.textureOnViewport = cy._private.options.textureOnViewport;
      json.wheelSensitivity = cy._private.options.wheelSensitivity;
      json.motionBlur = cy._private.options.motionBlur;

      return json;
    }
  },

  scratch: define.data({
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true
  }),

  removeScratch: define.removeData({
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true
  })

});

corefn.$id = corefn.getElementById;

[__webpack_require__(56), __webpack_require__(60), __webpack_require__(65), __webpack_require__(66), __webpack_require__(67), __webpack_require__(68), __webpack_require__(69), __webpack_require__(70), __webpack_require__(71), __webpack_require__(72)].forEach(function (props) {
  util.extend(corefn, props);
});

module.exports = Core;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);
var Set = __webpack_require__(9);

// represents a node or an edge
var Element = function Element(cy, params, restore) {
  restore = restore === undefined || restore ? true : false;

  if (cy === undefined || params === undefined || !is.core(cy)) {
    util.error('An element must have a core reference and parameters set');
    return;
  }

  var group = params.group;

  // try to automatically infer the group if unspecified
  if (group == null) {
    if (params.data && params.data.source != null && params.data.target != null) {
      group = 'edges';
    } else {
      group = 'nodes';
    }
  }

  // validate group
  if (group !== 'nodes' && group !== 'edges') {
    util.error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');
    return;
  }

  // make the element array-like, just like a collection
  this.length = 1;
  this[0] = this;

  // NOTE: when something is added here, add also to ele.json()
  var _p = this._private = {
    cy: cy,
    single: true, // indicates this is an element
    data: params.data || {}, // data object
    position: params.position || {}, // (x, y) position pair
    autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value
    autoHeight: undefined,
    autoPadding: undefined,
    compoundBoundsClean: false, // whether the compound dimensions need to be recalculated the next time dimensions are read
    listeners: [], // array of bound listeners
    group: group, // string; 'nodes' or 'edges'
    style: {}, // properties as set by the style
    rstyle: {}, // properties for style sent from the renderer to the core
    styleCxts: [], // applied style contexts from the styler
    removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)
    selected: params.selected ? true : false, // whether it's selected
    selectable: params.selectable === undefined ? true : params.selectable ? true : false, // whether it's selectable
    locked: params.locked ? true : false, // whether the element is locked (cannot be moved)
    grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately
    grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false, // whether the element can be grabbed
    active: false, // whether the element is active from user interaction
    classes: new Set(), // map ( className => true )
    animation: { // object for currently-running animations
      current: [],
      queue: []
    },
    rscratch: {}, // object in which the renderer can store information
    scratch: params.scratch || {}, // scratch objects
    edges: [], // array of connected edges
    children: [], // array of children
    parent: null, // parent ref
    traversalCache: {}, // cache of output of traversal functions
    backgrounding: false // whether background images are loading
  };

  // renderedPosition overrides if specified
  if (params.renderedPosition) {
    var rpos = params.renderedPosition;
    var pan = cy.pan();
    var zoom = cy.zoom();

    _p.position = {
      x: (rpos.x - pan.x) / zoom,
      y: (rpos.y - pan.y) / zoom
    };
  }

  if (is.string(params.classes)) {
    var classes = params.classes.split(/\s+/);
    for (var i = 0, l = classes.length; i < l; i++) {
      var cls = classes[i];
      if (!cls || cls === '') {
        continue;
      }

      _p.classes.add(cls);
    }
  }

  if (params.style || params.css) {
    cy.style().applyBypass(this, params.style || params.css);
  }

  this.createEmitter();

  if (restore === undefined || restore) {
    this.restore();
  }
};

module.exports = Element;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),
 *  and z-index (low to high).  These styles affect how this applies:
 *
 *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the
 *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from
 *      root to leaves of the compound graph.  The last drawn is `top`.
 *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.
 *      `manual` ignores this convention and draws based on the `z-index` value setting.
 *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher
 *      `z-index` will be drawn on top of an element with a lower `z-index`.
 */
var util = __webpack_require__(1);

var zIndexSort = function zIndexSort(a, b) {
  var cy = a.cy();
  var hasCompoundNodes = cy.hasCompoundNodes();

  function getDepth(ele) {
    var style = ele.pstyle('z-compound-depth');
    if (style.value === 'auto') {
      return hasCompoundNodes ? ele.zDepth() : 0;
    } else if (style.value === 'bottom') {
      return -1;
    } else if (style.value === 'top') {
      return util.MAX_INT;
    }
    // 'orphan'
    return 0;
  }
  var depthDiff = getDepth(a) - getDepth(b);
  if (depthDiff !== 0) {
    return depthDiff;
  }

  function getEleDepth(ele) {
    var style = ele.pstyle('z-index-compare');
    if (style.value === 'auto') {
      return ele.isNode() ? 1 : 0;
    }
    // 'manual'
    return 0;
  }
  var eleDiff = getEleDepth(a) - getEleDepth(b);
  if (eleDiff !== 0) {
    return eleDiff;
  }

  var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;
  if (zDiff !== 0) {
    return zDiff;
  }
  // compare indices in the core (order added to graph w/ last on top)
  return a.poolIndex() - b.poolIndex();
};

module.exports = zIndexSort;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*!
Event object based on jQuery events, MIT license

https://jquery.org/license/
https://tldrlegal.com/license/mit-license
https://github.com/jquery/jquery/blob/master/src/event.js
*/

var Event = function Event(src, props) {
  this.recycle(src, props);
};

function returnFalse() {
  return false;
}

function returnTrue() {
  return true;
}

// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
Event.prototype = {
  instanceString: function instanceString() {
    return 'event';
  },

  recycle: function recycle(src, props) {
    this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;

    if (src != null && src.preventDefault) {
      // Browser Event object
      this.type = src.type;

      // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.
      this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;
    } else if (src != null && src.type) {
      // Plain object containing all event details
      props = src;
    } else {
      // Event string
      this.type = src;
    }

    // Put explicitly provided properties onto the event object
    if (props != null) {
      // more efficient to manually copy fields we use
      this.originalEvent = props.originalEvent;
      this.type = props.type != null ? props.type : this.type;
      this.cy = props.cy;
      this.target = props.target;
      this.position = props.position;
      this.renderedPosition = props.renderedPosition;
      this.namespace = props.namespace;
      this.layout = props.layout;
    }

    if (this.cy != null && this.position != null && this.renderedPosition == null) {
      // create a rendered position based on the passed position
      var pos = this.position;
      var zoom = this.cy.zoom();
      var pan = this.cy.pan();

      this.renderedPosition = {
        x: pos.x * zoom + pan.x,
        y: pos.y * zoom + pan.y
      };
    }

    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = src && src.timeStamp || Date.now();
  },

  preventDefault: function preventDefault() {
    this.isDefaultPrevented = returnTrue;

    var e = this.originalEvent;
    if (!e) {
      return;
    }

    // if preventDefault exists run it on the original event
    if (e.preventDefault) {
      e.preventDefault();
    }
  },

  stopPropagation: function stopPropagation() {
    this.isPropagationStopped = returnTrue;

    var e = this.originalEvent;
    if (!e) {
      return;
    }

    // if stopPropagation exists run it on the original event
    if (e.stopPropagation) {
      e.stopPropagation();
    }
  },

  stopImmediatePropagation: function stopImmediatePropagation() {
    this.isImmediatePropagationStopped = returnTrue;
    this.stopPropagation();
  },

  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse
};

module.exports = Event;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

var fullFpsTime = 1000 / 60; // assume 60 frames per second

module.exports = {
  setupDequeueing: function setupDequeueing(opts) {
    return function setupDequeueingImpl() {
      var self = this;
      var r = this.renderer;

      if (self.dequeueingSetup) {
        return;
      } else {
        self.dequeueingSetup = true;
      }

      var queueRedraw = util.debounce(function () {
        r.redrawHint('eles', true);
        r.redrawHint('drag', true);

        r.redraw();
      }, opts.deqRedrawThreshold);

      var dequeue = function dequeue(willDraw, frameStartTime) {
        var startTime = util.performanceNow();
        var avgRenderTime = r.averageRedrawTime;
        var renderTime = r.lastRedrawTime;
        var deqd = [];
        var extent = r.cy.extent();
        var pixelRatio = r.getPixelRatio();

        while (true) {
          var now = util.performanceNow();
          var duration = now - startTime;
          var frameDuration = now - frameStartTime;

          if (renderTime < fullFpsTime) {
            // if we're rendering faster than the ideal fps, then do dequeueing
            // during all of the remaining frame time

            var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);

            if (frameDuration >= opts.deqFastCost * timeAvailable) {
              break;
            }
          } else {
            if (willDraw) {
              if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {
                break;
              }
            } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {
              break;
            }
          }

          var thisDeqd = opts.deq(self, pixelRatio, extent);

          if (thisDeqd.length > 0) {
            for (var i = 0; i < thisDeqd.length; i++) {
              deqd.push(thisDeqd[i]);
            }
          } else {
            break;
          }
        }

        // callbacks on dequeue
        if (deqd.length > 0) {
          opts.onDeqd(self, deqd);

          if (!willDraw && opts.shouldRedraw(self, deqd, pixelRatio, extent)) {
            queueRedraw();
          }
        }
      };

      var priority = opts.priority || util.noop;

      r.beforeRender(dequeue, priority(self));
    };
  }
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

var stateSelectors = [{
  selector: ':selected',
  matches: function matches(ele) {
    return ele.selected();
  }
}, {
  selector: ':unselected',
  matches: function matches(ele) {
    return !ele.selected();
  }
}, {
  selector: ':selectable',
  matches: function matches(ele) {
    return ele.selectable();
  }
}, {
  selector: ':unselectable',
  matches: function matches(ele) {
    return !ele.selectable();
  }
}, {
  selector: ':locked',
  matches: function matches(ele) {
    return ele.locked();
  }
}, {
  selector: ':unlocked',
  matches: function matches(ele) {
    return !ele.locked();
  }
}, {
  selector: ':visible',
  matches: function matches(ele) {
    return ele.visible();
  }
}, {
  selector: ':hidden',
  matches: function matches(ele) {
    return !ele.visible();
  }
}, {
  selector: ':transparent',
  matches: function matches(ele) {
    return ele.transparent();
  }
}, {
  selector: ':grabbed',
  matches: function matches(ele) {
    return ele.grabbed();
  }
}, {
  selector: ':free',
  matches: function matches(ele) {
    return !ele.grabbed();
  }
}, {
  selector: ':removed',
  matches: function matches(ele) {
    return ele.removed();
  }
}, {
  selector: ':inside',
  matches: function matches(ele) {
    return !ele.removed();
  }
}, {
  selector: ':grabbable',
  matches: function matches(ele) {
    return ele.grabbable();
  }
}, {
  selector: ':ungrabbable',
  matches: function matches(ele) {
    return !ele.grabbable();
  }
}, {
  selector: ':animated',
  matches: function matches(ele) {
    return ele.animated();
  }
}, {
  selector: ':unanimated',
  matches: function matches(ele) {
    return !ele.animated();
  }
}, {
  selector: ':parent',
  matches: function matches(ele) {
    return ele.isParent();
  }
}, {
  selector: ':childless',
  matches: function matches(ele) {
    return ele.isChildless();
  }
}, {
  selector: ':child',
  matches: function matches(ele) {
    return ele.isChild();
  }
}, {
  selector: ':orphan',
  matches: function matches(ele) {
    return ele.isOrphan();
  }
}, {
  selector: ':nonorphan',
  matches: function matches(ele) {
    return ele.isChild();
  }
}, {
  selector: ':loop',
  matches: function matches(ele) {
    return ele.isLoop();
  }
}, {
  selector: ':simple',
  matches: function matches(ele) {
    return ele.isSimple();
  }
}, {
  selector: ':active',
  matches: function matches(ele) {
    return ele.active();
  }
}, {
  selector: ':inactive',
  matches: function matches(ele) {
    return !ele.active();
  }
}, {
  selector: ':backgrounding',
  matches: function matches(ele) {
    return ele.backgrounding();
  }
}, {
  selector: ':nonbackgrounding',
  matches: function matches(ele) {
    return !ele.backgrounding();
  }
}].sort(function (a, b) {
  // n.b. selectors that are starting substrings of others must have the longer ones first
  return util.sort.descending(a.selector, b.selector);
});

var stateSelectorMatches = function stateSelectorMatches(sel, ele) {
  var lookup = stateSelectorMatches.lookup = stateSelectorMatches.lookup || function () {
    var selToFn = {};
    var s = void 0;

    for (var i = 0; i < stateSelectors.length; i++) {
      s = stateSelectors[i];

      selToFn[s.selector] = s.matches;
    }

    return selToFn;
  }();

  return lookup[sel](ele);
};

var stateSelectorRegex = '(' + stateSelectors.map(function (s) {
  return s.selector;
}).join('|') + ')';

module.exports = { stateSelectors: stateSelectors, stateSelectorMatches: stateSelectorMatches, stateSelectorRegex: stateSelectorRegex };

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);
var Selector = __webpack_require__(6);

var Style = function Style(cy) {

  if (!(this instanceof Style)) {
    return new Style(cy);
  }

  if (!is.core(cy)) {
    util.error('A style must have a core reference');
    return;
  }

  this._private = {
    cy: cy,
    coreStyle: {}
  };

  this.length = 0;

  this.resetToDefault();
};

var styfn = Style.prototype;

styfn.instanceString = function () {
  return 'style';
};

// remove all contexts
styfn.clear = function () {
  for (var i = 0; i < this.length; i++) {
    this[i] = undefined;
  }
  this.length = 0;

  var _p = this._private;

  _p.newStyle = true;

  return this; // chaining
};

styfn.resetToDefault = function () {
  this.clear();
  this.addDefaultStylesheet();

  return this;
};

// builds a style object for the 'core' selector
styfn.core = function () {
  return this._private.coreStyle;
};

// create a new context from the specified selector string and switch to that context
styfn.selector = function (selectorStr) {
  // 'core' is a special case and does not need a selector
  var selector = selectorStr === 'core' ? null : new Selector(selectorStr);

  var i = this.length++; // new context means new index
  this[i] = {
    selector: selector,
    properties: [],
    mappedProperties: [],
    index: i
  };

  return this; // chaining
};

// add one or many css rules to the current context
styfn.css = function () {
  var self = this;
  var args = arguments;

  switch (args.length) {
    case 1:
      var map = args[0];

      for (var i = 0; i < self.properties.length; i++) {
        var prop = self.properties[i];
        var mapVal = map[prop.name];

        if (mapVal === undefined) {
          mapVal = map[util.dash2camel(prop.name)];
        }

        if (mapVal !== undefined) {
          this.cssRule(prop.name, mapVal);
        }
      }

      break;

    case 2:
      this.cssRule(args[0], args[1]);
      break;

    default:
      break; // do nothing if args are invalid
  }

  return this; // chaining
};
styfn.style = styfn.css;

// add a single css rule to the current context
styfn.cssRule = function (name, value) {
  // name-value pair
  var property = this.parse(name, value);

  // add property to current context if valid
  if (property) {
    var i = this.length - 1;
    this[i].properties.push(property);
    this[i].properties[property.name] = property; // allow access by name as well

    if (property.name.match(/pie-(\d+)-background-size/) && property.value) {
      this._private.hasPie = true;
    }

    if (property.mapped) {
      this[i].mappedProperties.push(property);
    }

    // add to core style if necessary
    var currentSelectorIsCore = !this[i].selector;
    if (currentSelectorIsCore) {
      this._private.coreStyle[property.name] = property;
    }
  }

  return this; // chaining
};

styfn.append = function (style) {
  if (is.stylesheet(style)) {
    style.appendToStyle(this);
  } else if (is.array(style)) {
    this.appendFromJson(style);
  } else if (is.string(style)) {
    this.appendFromString(style);
  } // you probably wouldn't want to append a Style, since you'd duplicate the default parts

  return this;
};

// static function
Style.fromJson = function (cy, json) {
  var style = new Style(cy);

  style.fromJson(json);

  return style;
};

Style.fromString = function (cy, string) {
  return new Style(cy).fromString(string);
};

[__webpack_require__(123), __webpack_require__(124), __webpack_require__(125), __webpack_require__(126), __webpack_require__(127), __webpack_require__(130), __webpack_require__(129), __webpack_require__(128)].forEach(function (props) {
  util.extend(styfn, props);
});

Style.types = styfn.types;
Style.properties = styfn.properties;

module.exports = Style;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function memoize(fn, keyFn) {
  if (!keyFn) {
    keyFn = function keyFn() {
      if (arguments.length === 1) {
        return arguments[0];
      } else if (arguments.length === 0) {
        return 'undefined';
      }

      var args = [];

      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }

      return args.join('$');
    };
  }

  var memoizedFn = function memoizedFn() {
    var self = this;
    var args = arguments;
    var ret = void 0;
    var k = keyFn.apply(self, args);
    var cache = memoizedFn.cache;

    if (!(ret = cache[k])) {
      ret = cache[k] = fn.apply(self, args);
    }

    return ret;
  };

  memoizedFn.cache = {};

  return memoizedFn;
};

/***/ }),
/* 20 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var define = __webpack_require__(3);
var Collection = __webpack_require__(7);
var Core = __webpack_require__(12);
var incExts = __webpack_require__(76);
var is = __webpack_require__(0);
var Emitter = __webpack_require__(10);

// registered extensions to cytoscape, indexed by name
var extensions = {};

// registered modules for extensions, indexed by name
var modules = {};

function setExtension(type, name, registrant) {

  var ext = registrant;

  var overrideErr = function overrideErr(field) {
    util.error('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');
  };

  if (type === 'core') {
    if (Core.prototype[name]) {
      return overrideErr(name);
    } else {
      Core.prototype[name] = registrant;
    }
  } else if (type === 'collection') {
    if (Collection.prototype[name]) {
      return overrideErr(name);
    } else {
      Collection.prototype[name] = registrant;
    }
  } else if (type === 'layout') {
    // fill in missing layout functions in the prototype

    var Layout = function Layout(options) {
      this.options = options;

      registrant.call(this, options);

      // make sure layout has _private for use w/ std apis like .on()
      if (!is.plainObject(this._private)) {
        this._private = {};
      }

      this._private.cy = options.cy;
      this._private.listeners = [];

      this.createEmitter();
    };

    var layoutProto = Layout.prototype = Object.create(registrant.prototype);

    var optLayoutFns = [];

    for (var i = 0; i < optLayoutFns.length; i++) {
      var fnName = optLayoutFns[i];

      layoutProto[fnName] = layoutProto[fnName] || function () {
        return this;
      };
    }

    // either .start() or .run() is defined, so autogen the other
    if (layoutProto.start && !layoutProto.run) {
      layoutProto.run = function () {
        this.start();return this;
      };
    } else if (!layoutProto.start && layoutProto.run) {
      layoutProto.start = function () {
        this.run();return this;
      };
    }

    var regStop = registrant.prototype.stop;
    layoutProto.stop = function () {
      var opts = this.options;

      if (opts && opts.animate) {
        var anis = this.animations;

        if (anis) {
          for (var _i = 0; _i < anis.length; _i++) {
            anis[_i].stop();
          }
        }
      }

      if (regStop) {
        regStop.call(this);
      } else {
        this.emit('layoutstop');
      }

      return this;
    };

    if (!layoutProto.destroy) {
      layoutProto.destroy = function () {
        return this;
      };
    }

    layoutProto.cy = function () {
      return this._private.cy;
    };

    var getCy = function getCy(layout) {
      return layout._private.cy;
    };

    util.assign(layoutProto, {
      createEmitter: function createEmitter() {
        this._private.emitter = new Emitter({
          eventFields: function eventFields(layout) {
            return {
              layout: layout,
              cy: getCy(layout),
              target: layout
            };
          },
          bubble: function bubble() {
            return true;
          },
          parent: function parent(layout) {
            return getCy(layout);
          },
          context: this
        });

        return this;
      },
      emitter: function emitter() {
        return this._private.emitter;
      },
      on: function on(evt, cb) {
        this.emitter().on(evt, cb);return this;
      },
      one: function one(evt, cb) {
        this.emitter().one(evt, cb);return this;
      },
      once: function once(evt, cb) {
        this.emitter().one(evt, cb);return this;
      },
      removeListener: function removeListener(evt, cb) {
        this.emitter().removeListener(evt, cb);return this;
      },
      emit: function emit(evt, params) {
        this.emitter().emit(evt, params);return this;
      }
    });

    define.eventAliasesOn(layoutProto);

    ext = Layout; // replace with our wrapped layout
  } else if (type === 'renderer' && name !== 'null' && name !== 'base') {
    // user registered renderers inherit from base

    var BaseRenderer = getExtension('renderer', 'base');
    var bProto = BaseRenderer.prototype;
    var RegistrantRenderer = registrant;
    var rProto = registrant.prototype;

    var Renderer = function Renderer() {
      BaseRenderer.apply(this, arguments);
      RegistrantRenderer.apply(this, arguments);
    };

    var proto = Renderer.prototype;

    for (var pName in bProto) {
      var pVal = bProto[pName];
      var existsInR = rProto[pName] != null;

      if (existsInR) {
        return overrideErr(pName);
      }

      proto[pName] = pVal; // take impl from base
    }

    for (var _pName in rProto) {
      proto[_pName] = rProto[_pName]; // take impl from registrant
    }

    bProto.clientFunctions.forEach(function (name) {
      proto[name] = proto[name] || function () {
        util.error('Renderer does not implement `renderer.' + name + '()` on its prototype');
      };
    });

    ext = Renderer;
  }

  return util.setMap({
    map: extensions,
    keys: [type, name],
    value: ext
  });
}

function getExtension(type, name) {
  return util.getMap({
    map: extensions,
    keys: [type, name]
  });
}

function setModule(type, name, moduleType, moduleName, registrant) {
  return util.setMap({
    map: modules,
    keys: [type, name, moduleType, moduleName],
    value: registrant
  });
}

function getModule(type, name, moduleType, moduleName) {
  return util.getMap({
    map: modules,
    keys: [type, name, moduleType, moduleName]
  });
}

var extension = function extension() {
  // e.g. extension('renderer', 'svg')
  if (arguments.length === 2) {
    return getExtension.apply(null, arguments);
  }

  // e.g. extension('renderer', 'svg', { ... })
  else if (arguments.length === 3) {
      return setExtension.apply(null, arguments);
    }

    // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')
    else if (arguments.length === 4) {
        return getModule.apply(null, arguments);
      }

      // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
      else if (arguments.length === 5) {
          return setModule.apply(null, arguments);
        } else {
          util.error('Invalid extension access syntax');
        }
};

// allows a core instance to access extensions internally
Core.prototype.extension = extension;

// included extensions
incExts.forEach(function (group) {
  group.extensions.forEach(function (ext) {
    setExtension(group.type, ext.name, ext.impl);
  });
});

module.exports = extension;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);
var Style = __webpack_require__(18);

// a dummy stylesheet object that doesn't need a reference to the core
// (useful for init)
var Stylesheet = function Stylesheet() {
  if (!(this instanceof Stylesheet)) {
    return new Stylesheet();
  }

  this.length = 0;
};

var sheetfn = Stylesheet.prototype;

sheetfn.instanceString = function () {
  return 'stylesheet';
};

// just store the selector to be parsed later
sheetfn.selector = function (selector) {
  var i = this.length++;

  this[i] = {
    selector: selector,
    properties: []
  };

  return this; // chaining
};

// just store the property to be parsed later
sheetfn.css = function (name, value) {
  var i = this.length - 1;

  if (is.string(name)) {
    this[i].properties.push({
      name: name,
      value: value
    });
  } else if (is.plainObject(name)) {
    var map = name;

    for (var j = 0; j < Style.properties.length; j++) {
      var prop = Style.properties[j];
      var mapVal = map[prop.name];

      if (mapVal === undefined) {
        // also try camel case name
        mapVal = map[util.dash2camel(prop.name)];
      }

      if (mapVal !== undefined) {
        var _name = prop.name;
        var _value = mapVal;

        this[i].properties.push({
          name: _name,
          value: _value
        });
      }
    }
  }

  return this; // chaining
};

sheetfn.style = sheetfn.css;

// generate a real style object from the dummy stylesheet
sheetfn.generateStyle = function (cy) {
  var style = new Style(cy);

  return this.appendToStyle(style);
};

// append a dummy stylesheet object on a real style object
sheetfn.appendToStyle = function (style) {
  for (var i = 0; i < this.length; i++) {
    var context = this[i];
    var selector = context.selector;
    var props = context.properties;

    style.selector(selector); // apply selector

    for (var j = 0; j < props.length; j++) {
      var prop = props[j];

      style.css(prop.name, prop.value); // apply property
    }
  }

  return style;
};

module.exports = Stylesheet;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = "3.2.8";

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);
var Promise = __webpack_require__(5);

var Animation = function Animation(target, opts, opts2) {
  var _p = this._private = util.extend({
    duration: 1000
  }, opts, opts2);

  _p.target = target;
  _p.style = _p.style || _p.css;
  _p.started = false;
  _p.playing = false;
  _p.hooked = false;
  _p.applying = false;
  _p.progress = 0;
  _p.completes = [];
  _p.frames = [];

  if (_p.complete && is.fn(_p.complete)) {
    _p.completes.push(_p.complete);
  }

  // for future timeline/animations impl
  this.length = 1;
  this[0] = this;
};

var anifn = Animation.prototype;

util.extend(anifn, {

  instanceString: function instanceString() {
    return 'animation';
  },

  hook: function hook() {
    var _p = this._private;

    if (!_p.hooked) {
      // add to target's animation queue
      var q = void 0;
      var tAni = _p.target._private.animation;
      if (_p.queue) {
        q = tAni.queue;
      } else {
        q = tAni.current;
      }
      q.push(this);

      // add to the animation loop pool
      if (is.elementOrCollection(_p.target)) {
        _p.target.cy().addToAnimationPool(_p.target);
      }

      _p.hooked = true;
    }

    return this;
  },

  play: function play() {
    var _p = this._private;

    // autorewind
    if (_p.progress === 1) {
      _p.progress = 0;
    }

    _p.playing = true;
    _p.started = false; // needs to be started by animation loop
    _p.stopped = false;

    this.hook();

    // the animation loop will start the animation...

    return this;
  },

  playing: function playing() {
    return this._private.playing;
  },

  apply: function apply() {
    var _p = this._private;

    _p.applying = true;
    _p.started = false; // needs to be started by animation loop
    _p.stopped = false;

    this.hook();

    // the animation loop will apply the animation at this progress

    return this;
  },

  applying: function applying() {
    return this._private.applying;
  },

  pause: function pause() {
    var _p = this._private;

    _p.playing = false;
    _p.started = false;

    return this;
  },

  stop: function stop() {
    var _p = this._private;

    _p.playing = false;
    _p.started = false;
    _p.stopped = true; // to be removed from animation queues

    return this;
  },

  rewind: function rewind() {
    return this.progress(0);
  },

  fastforward: function fastforward() {
    return this.progress(1);
  },

  time: function time(t) {
    var _p = this._private;

    if (t === undefined) {
      return _p.progress * _p.duration;
    } else {
      return this.progress(t / _p.duration);
    }
  },

  progress: function progress(p) {
    var _p = this._private;
    var wasPlaying = _p.playing;

    if (p === undefined) {
      return _p.progress;
    } else {
      if (wasPlaying) {
        this.pause();
      }

      _p.progress = p;
      _p.started = false;

      if (wasPlaying) {
        this.play();
      }
    }

    return this;
  },

  completed: function completed() {
    return this._private.progress === 1;
  },

  reverse: function reverse() {
    var _p = this._private;
    var wasPlaying = _p.playing;

    if (wasPlaying) {
      this.pause();
    }

    _p.progress = 1 - _p.progress;
    _p.started = false;

    var swap = function swap(a, b) {
      var _pa = _p[a];

      if (_pa == null) {
        return;
      }

      _p[a] = _p[b];
      _p[b] = _pa;
    };

    swap('zoom', 'startZoom');
    swap('pan', 'startPan');
    swap('position', 'startPosition');

    // swap styles
    if (_p.style) {
      for (var i = 0; i < _p.style.length; i++) {
        var prop = _p.style[i];
        var name = prop.name;
        var startStyleProp = _p.startStyle[name];

        _p.startStyle[name] = prop;
        _p.style[i] = startStyleProp;
      }
    }

    if (wasPlaying) {
      this.play();
    }

    return this;
  },

  promise: function promise(type) {
    var _p = this._private;

    var arr = void 0;

    switch (type) {
      case 'frame':
        arr = _p.frames;
        break;
      default:
      case 'complete':
      case 'completed':
        arr = _p.completes;
    }

    return new Promise(function (resolve, reject) {
      arr.push(function () {
        resolve();
      });
    });
  }

});

anifn.complete = anifn.completed;

module.exports = Animation;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

var elesfn = {

  // Implemented from pseudocode from wikipedia
  aStar: function aStar(options) {
    var eles = this;

    options = options || {};

    // Reconstructs the path from Start to End, acumulating the result in pathAcum
    var reconstructPath = function reconstructPath(start, end, cameFromMap, pathAcum) {
      // Base case
      if (start == end) {
        pathAcum.unshift(cy.getElementById(end));
        return pathAcum;
      }

      if (end in cameFromMap) {
        // We know which node is before the last one
        var previous = cameFromMap[end];
        var previousEdge = cameFromEdge[end];

        pathAcum.unshift(cy.getElementById(previousEdge));
        pathAcum.unshift(cy.getElementById(end));

        return reconstructPath(start, previous, cameFromMap, pathAcum);
      }

      // We should not reach here!
      return undefined;
    };

    // Returns the index of the element in openSet which has minimum fScore
    var findMin = function findMin(openSet, fScore) {
      if (openSet.length === 0) {
        // Should never be the case
        return undefined;
      }
      var minPos = 0;
      var tempScore = fScore[openSet[0]];
      for (var i = 1; i < openSet.length; i++) {
        var s = fScore[openSet[i]];
        if (s < tempScore) {
          tempScore = s;
          minPos = i;
        }
      }
      return minPos;
    };

    var cy = this._private.cy;

    // root - mandatory!
    if (options != null && options.root != null) {
      var source = is.string(options.root) ?
      // use it as a selector, e.g. "#rootID
      this.filter(options.root)[0] : options.root[0];
    } else {
      return undefined;
    }

    // goal - mandatory!
    if (options.goal != null) {
      var target = is.string(options.goal) ?
      // use it as a selector, e.g. "#goalID
      this.filter(options.goal)[0] : options.goal[0];
    } else {
      return undefined;
    }

    // Heuristic function - optional
    if (options.heuristic != null && is.fn(options.heuristic)) {
      var heuristic = options.heuristic;
    } else {
      var heuristic = function heuristic() {
        return 0;
      }; // use constant if unspecified
    }

    // Weight function - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function weightFn(e) {
        return 1;
      };
    }

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var sid = source.id();
    var tid = target.id();

    var closedSet = [];
    var openSet = [sid];
    var cameFrom = {};
    var cameFromEdge = {};
    var gScore = {};
    var fScore = {};

    gScore[sid] = 0;
    fScore[sid] = heuristic(source);

    // Counter
    var steps = 0;

    // Main loop
    while (openSet.length > 0) {
      var minPos = findMin(openSet, fScore);
      var cMin = cy.getElementById(openSet[minPos]);
      var cMinId = cMin.id();
      steps++;

      // If we've found our goal, then we are done
      if (cMinId == tid) {
        var rPath = reconstructPath(sid, tid, cameFrom, []);

        return {
          found: true,
          distance: gScore[cMinId],
          path: eles.spawn(rPath),
          steps: steps
        };
      }

      // Add cMin to processed nodes
      closedSet.push(cMinId);
      // Remove cMin from boundary nodes
      openSet.splice(minPos, 1);

      // Update scores for neighbors of cMin
      // Take into account if graph is directed or not
      var vwEdges = cMin._private.edges;

      for (var i = 0; i < vwEdges.length; i++) {
        var e = vwEdges[i];

        // edge must be in set of calling eles
        if (!this.hasElementWithId(e.id())) {
          continue;
        }

        // cMin must be the source of edge if directed
        if (directed && e.data('source') !== cMinId) {
          continue;
        }

        var wSrc = e.source();
        var wTgt = e.target();

        var w = wSrc.id() !== cMinId ? wSrc : wTgt;
        var wid = w.id();

        // node must be in set of calling eles
        if (!this.hasElementWithId(wid)) {
          continue;
        }

        // if node is in closedSet, ignore it
        if (closedSet.indexOf(wid) != -1) {
          continue;
        }

        // New tentative score for node w
        var tempScore = gScore[cMinId] + weightFn(e);

        // Update gScore for node w if:
        //   w not present in openSet
        // OR
        //   tentative gScore is less than previous value

        // w not in openSet
        if (openSet.indexOf(wid) == -1) {
          gScore[wid] = tempScore;
          fScore[wid] = tempScore + heuristic(w);
          openSet.push(wid); // Add node to openSet
          cameFrom[wid] = cMinId;
          cameFromEdge[wid] = e.id();
          continue;
        }
        // w already in openSet, but with greater gScore
        if (tempScore < gScore[wid]) {
          gScore[wid] = tempScore;
          fScore[wid] = tempScore + heuristic(w);
          cameFrom[wid] = cMinId;
        }
      } // End of neighbors update
    } // End of main loop

    // If we've reached here, then we've not reached our goal
    return {
      found: false,
      distance: undefined,
      path: undefined,
      steps: steps
    };
  }

}; // elesfn


module.exports = elesfn;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);

var elesfn = {

  // Implemented from pseudocode from wikipedia
  bellmanFord: function bellmanFord(options) {
    var eles = this;

    options = options || {};

    // Weight function - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function weightFn(e) {
        return 1;
      };
    }

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    // root - mandatory!
    if (options.root != null) {
      if (is.string(options.root)) {
        // use it as a selector, e.g. "#rootID
        var source = this.filter(options.root)[0];
      } else {
        var source = options.root[0];
      }
    } else {
      return undefined;
    }

    var cy = this._private.cy;
    var edges = this.edges().stdFilter(function (e) {
      return !e.isLoop();
    });
    var nodes = this.nodes();
    var numNodes = nodes.length;

    // mapping: node id -> position in nodes array
    var id2position = {};
    for (var i = 0; i < numNodes; i++) {
      id2position[nodes[i].id()] = i;
    }

    // Initializations
    var cost = [];
    var predecessor = [];
    var predEdge = [];

    for (var i = 0; i < numNodes; i++) {
      if (nodes[i].id() === source.id()) {
        cost[i] = 0;
      } else {
        cost[i] = Infinity;
      }
      predecessor[i] = undefined;
    }

    // Edges relaxation
    var flag = false;
    for (var i = 1; i < numNodes; i++) {
      flag = false;
      for (var e = 0; e < edges.length; e++) {
        var sourceIndex = id2position[edges[e].source().id()];
        var targetIndex = id2position[edges[e].target().id()];
        var weight = weightFn(edges[e]);

        var temp = cost[sourceIndex] + weight;
        if (temp < cost[targetIndex]) {
          cost[targetIndex] = temp;
          predecessor[targetIndex] = sourceIndex;
          predEdge[targetIndex] = edges[e];
          flag = true;
        }

        // If undirected graph, we need to take into account the 'reverse' edge
        if (!directed) {
          var temp = cost[targetIndex] + weight;
          if (temp < cost[sourceIndex]) {
            cost[sourceIndex] = temp;
            predecessor[sourceIndex] = targetIndex;
            predEdge[sourceIndex] = edges[e];
            flag = true;
          }
        }
      }

      if (!flag) {
        break;
      }
    }

    if (flag) {
      // Check for negative weight cycles
      for (var e = 0; e < edges.length; e++) {
        var sourceIndex = id2position[edges[e].source().id()];
        var targetIndex = id2position[edges[e].target().id()];
        var weight = weightFn(edges[e]);

        if (cost[sourceIndex] + weight < cost[targetIndex]) {
          util.error('Graph contains a negative weight cycle for Bellman-Ford');
          return { pathTo: undefined,
            distanceTo: undefined,
            hasNegativeWeightCycle: true };
        }
      }
    }

    // Build result object
    var position2id = [];
    for (var i = 0; i < numNodes; i++) {
      position2id.push(nodes[i].id());
    }

    var res = {
      distanceTo: function distanceTo(to) {
        if (is.string(to)) {
          // to is a selector string
          var toId = cy.filter(to)[0].id();
        } else {
          // to is a node
          var toId = to.id();
        }

        return cost[id2position[toId]];
      },

      pathTo: function pathTo(to) {

        var reconstructPathAux = function reconstructPathAux(predecessor, fromPos, toPos, position2id, acumPath, predEdge) {
          for (;;) {
            // Add toId to path
            acumPath.push(cy.getElementById(position2id[toPos]));
            acumPath.push(predEdge[toPos]);

            if (fromPos === toPos) {
              // reached starting node
              return acumPath;
            }

            // If no path exists, discart acumulated path and return undefined
            var predPos = predecessor[toPos];
            if (typeof predPos === 'undefined') {
              return undefined;
            }

            toPos = predPos;
          }
        };

        if (is.string(to)) {
          // to is a selector string
          var toId = cy.filter(to)[0].id();
        } else {
          // to is a node
          var toId = to.id();
        }
        var path = [];

        // This returns a reversed path
        var res = reconstructPathAux(predecessor, id2position[source.id()], id2position[toId], position2id, path, predEdge);

        // Get it in the correct order and return it
        if (res != null) {
          res.reverse();
        }

        return eles.spawn(res);
      },

      hasNegativeWeightCycle: false
    };

    return res;
  } // bellmanFord

}; // elesfn

module.exports = elesfn;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var Heap = __webpack_require__(8);

var elesfn = {

  // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
  betweennessCentrality: function betweennessCentrality(options) {
    options = options || {};

    // Weight - optional
    var weighted, weightFn;
    if (is.fn(options.weight)) {
      weightFn = options.weight;
      weighted = true;
    } else {
      weighted = false;
    }

    // Directed - default false
    var directed = options.directed != null ? options.directed : false;

    var cy = this._private.cy;

    // starting
    var V = this.nodes();
    var A = {};
    var _C = {};
    var max = 0;
    var C = {
      set: function set(key, val) {
        _C[key] = val;

        if (val > max) {
          max = val;
        }
      },

      get: function get(key) {
        return _C[key];
      }
    };

    // A contains the neighborhoods of every node
    for (var i = 0; i < V.length; i++) {
      var v = V[i];
      var vid = v.id();

      if (directed) {
        A[vid] = v.outgoers().nodes(); // get outgoers of every node
      } else {
        A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node
      }

      C.set(vid, 0);
    }

    for (var s = 0; s < V.length; s++) {
      var sid = V[s].id();
      var S = []; // stack
      var P = {};
      var g = {};
      var d = {};
      var Q = new Heap(function (a, b) {
        return d[a] - d[b];
      }); // queue

      // init dictionaries
      for (var i = 0; i < V.length; i++) {
        var vid = V[i].id();

        P[vid] = [];
        g[vid] = 0;
        d[vid] = Infinity;
      }

      g[sid] = 1; // sigma
      d[sid] = 0; // distance to s

      Q.push(sid);

      while (!Q.empty()) {
        var v = Q.pop();

        S.push(v);

        if (weighted) {
          for (var j = 0; j < A[v].length; j++) {
            var w = A[v][j];
            var vEle = cy.getElementById(v);

            var edge;
            if (vEle.edgesTo(w).length > 0) {
              edge = vEle.edgesTo(w)[0];
            } else {
              edge = w.edgesTo(vEle)[0];
            }

            var edgeWeight = weightFn(edge);

            w = w.id();

            if (d[w] > d[v] + edgeWeight) {
              d[w] = d[v] + edgeWeight;

              if (Q.nodes.indexOf(w) < 0) {
                //if w is not in Q
                Q.push(w);
              } else {
                // update position if w is in Q
                Q.updateItem(w);
              }

              g[w] = 0;
              P[w] = [];
            }

            if (d[w] == d[v] + edgeWeight) {
              g[w] = g[w] + g[v];
              P[w].push(v);
            }
          }
        } else {
          for (var j = 0; j < A[v].length; j++) {
            var w = A[v][j].id();

            if (d[w] == Infinity) {
              Q.push(w);

              d[w] = d[v] + 1;
            }

            if (d[w] == d[v] + 1) {
              g[w] = g[w] + g[v];
              P[w].push(v);
            }
          }
        }
      }

      var e = {};
      for (var i = 0; i < V.length; i++) {
        e[V[i].id()] = 0;
      }

      while (S.length > 0) {
        var w = S.pop();

        for (var j = 0; j < P[w].length; j++) {
          var v = P[w][j];

          e[v] = e[v] + g[v] / g[w] * (1 + e[w]);

          if (w != V[s].id()) {
            C.set(w, C.get(w) + e[w]);
          }
        }
      }
    }

    var ret = {
      betweenness: function betweenness(node) {
        if (is.string(node)) {
          var node = cy.filter(node).id();
        } else {
          var node = node.id();
        }

        return C.get(node);
      },

      betweennessNormalized: function betweennessNormalized(node) {
        if (max == 0) return 0;

        if (is.string(node)) {
          var node = cy.filter(node).id();
        } else {
          var node = node.id();
        }

        return C.get(node) / max;
      }
    };

    // alias
    ret.betweennessNormalised = ret.betweennessNormalized;

    return ret;
  } // betweennessCentrality

}; // elesfn

// nice, short mathemathical alias
elesfn.bc = elesfn.betweennessCentrality;

module.exports = elesfn;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

var defineSearch = function defineSearch(params) {
  params = {
    bfs: params.bfs || !params.dfs,
    dfs: params.dfs || !params.bfs
  };

  // from pseudocode on wikipedia
  return function searchFn(roots, fn, directed) {
    var options;
    if (is.plainObject(roots) && !is.elementOrCollection(roots)) {
      options = roots;
      roots = options.roots || options.root;
      fn = options.visit;
      directed = options.directed;
    }

    directed = arguments.length === 2 && !is.fn(fn) ? fn : directed;
    fn = is.fn(fn) ? fn : function () {};

    var cy = this._private.cy;
    var v = roots = is.string(roots) ? this.filter(roots) : roots;
    var Q = [];
    var connectedNodes = [];
    var connectedBy = {};
    var id2depth = {};
    var V = {};
    var j = 0;
    var found;
    var nodes = this.nodes();
    var edges = this.edges();

    // enqueue v
    for (var i = 0; i < v.length; i++) {
      if (v[i].isNode()) {
        Q.unshift(v[i]);

        if (params.bfs) {
          V[v[i].id()] = true;

          connectedNodes.push(v[i]);
        }

        id2depth[v[i].id()] = 0;
      }
    }

    while (Q.length !== 0) {
      var v = params.bfs ? Q.shift() : Q.pop();

      if (params.dfs) {
        if (V[v.id()]) {
          continue;
        }

        V[v.id()] = true;

        connectedNodes.push(v);
      }

      var depth = id2depth[v.id()];
      var prevEdge = connectedBy[v.id()];
      var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not(v)[0];
      var ret;

      ret = fn(v, prevEdge, prevNode, j++, depth);

      if (ret === true) {
        found = v;
        break;
      }

      if (ret === false) {
        break;
      }

      var vwEdges = v.connectedEdges(directed ? function (ele) {
        return ele.data('source') === v.id();
      } : undefined).intersect(edges);
      for (var i = 0; i < vwEdges.length; i++) {
        var e = vwEdges[i];
        var w = e.connectedNodes(function (n) {
          return n.id() !== v.id();
        }).intersect(nodes);

        if (w.length !== 0 && !V[w.id()]) {
          w = w[0];

          Q.push(w);

          if (params.bfs) {
            V[w.id()] = true;

            connectedNodes.push(w);
          }

          connectedBy[w.id()] = e;

          id2depth[w.id()] = id2depth[v.id()] + 1;
        }
      }
    }

    var connectedEles = [];

    for (var i = 0; i < connectedNodes.length; i++) {
      var node = connectedNodes[i];
      var edge = connectedBy[node.id()];

      if (edge) {
        connectedEles.push(edge);
      }

      connectedEles.push(node);
    }

    return {
      path: cy.collection(connectedEles, { unique: true }),
      found: cy.collection(found)
    };
  };
};

// search, spanning trees, etc
var elesfn = {
  breadthFirstSearch: defineSearch({ bfs: true }),
  depthFirstSearch: defineSearch({ dfs: true })
};

// nice, short mathemathical alias
elesfn.bfs = elesfn.breadthFirstSearch;
elesfn.dfs = elesfn.depthFirstSearch;

module.exports = elesfn;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

var elesfn = {

  closenessCentralityNormalized: function closenessCentralityNormalized(options) {
    options = options || {};

    var cy = this.cy();

    var harmonic = options.harmonic;
    if (harmonic === undefined) {
      harmonic = true;
    }

    var closenesses = {};
    var maxCloseness = 0;
    var nodes = this.nodes();
    var fw = this.floydWarshall({ weight: options.weight, directed: options.directed });

    // Compute closeness for every node and find the maximum closeness
    for (var i = 0; i < nodes.length; i++) {
      var currCloseness = 0;
      for (var j = 0; j < nodes.length; j++) {
        if (i != j) {
          var d = fw.distance(nodes[i], nodes[j]);

          if (harmonic) {
            currCloseness += 1 / d;
          } else {
            currCloseness += d;
          }
        }
      }

      if (!harmonic) {
        currCloseness = 1 / currCloseness;
      }

      if (maxCloseness < currCloseness) {
        maxCloseness = currCloseness;
      }

      closenesses[nodes[i].id()] = currCloseness;
    }

    return {
      closeness: function closeness(node) {
        if (maxCloseness == 0) {
          return 0;
        }

        if (is.string(node)) {
          // from is a selector string
          var node = cy.filter(node)[0].id();
        } else {
          // from is a node
          var node = node.id();
        }

        return closenesses[node] / maxCloseness;
      }
    };
  },

  // Implemented from pseudocode from wikipedia
  closenessCentrality: function closenessCentrality(options) {
    options = options || {};

    // root - mandatory!
    if (options.root != null) {
      if (is.string(options.root)) {
        // use it as a selector, e.g. "#rootID
        var root = this.filter(options.root)[0];
      } else {
        var root = options.root[0];
      }
    } else {
      return undefined;
    }

    // weight - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weight = options.weight;
    } else {
      var weight = function weight() {
        return 1;
      };
    }

    // directed - optional
    if (options.directed != null && is.bool(options.directed)) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var harmonic = options.harmonic;
    if (harmonic === undefined) {
      harmonic = true;
    }

    // we need distance from this node to every other node
    var dijkstra = this.dijkstra({
      root: root,
      weight: weight,
      directed: directed
    });
    var totalDistance = 0;

    var nodes = this.nodes();
    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i].id() != root.id()) {
        var d = dijkstra.distanceTo(nodes[i]);

        if (harmonic) {
          totalDistance += 1 / d;
        } else {
          totalDistance += d;
        }
      }
    }

    return harmonic ? totalDistance : 1 / totalDistance;
  } // closenessCentrality

}; // elesfn

// nice, short mathemathical alias
elesfn.cc = elesfn.closenessCentrality;
elesfn.ccn = elesfn.closenessCentralityNormalised = elesfn.closenessCentralityNormalized;

module.exports = elesfn;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);

var elesfn = {

  degreeCentralityNormalized: function degreeCentralityNormalized(options) {
    options = options || {};

    var cy = this.cy();

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var nodes = this.nodes();
    var numNodes = nodes.length;

    if (!directed) {
      var degrees = {};
      var maxDegree = 0;

      for (var i = 0; i < numNodes; i++) {
        var node = nodes[i];
        // add current node to the current options object and call degreeCentrality
        var currDegree = this.degreeCentrality(util.extend({}, options, { root: node }));
        if (maxDegree < currDegree.degree) maxDegree = currDegree.degree;

        degrees[node.id()] = currDegree.degree;
      }

      return {
        degree: function degree(node) {
          if (maxDegree == 0) return 0;

          if (is.string(node)) {
            // from is a selector string
            var node = cy.filter(node)[0].id();
          } else {
            // from is a node
            var node = node.id();
          }

          return degrees[node] / maxDegree;
        }
      };
    } else {
      var indegrees = {};
      var outdegrees = {};
      var maxIndegree = 0;
      var maxOutdegree = 0;

      for (var i = 0; i < numNodes; i++) {
        var node = nodes[i];
        // add current node to the current options object and call degreeCentrality
        var currDegree = this.degreeCentrality(util.extend({}, options, { root: node }));

        if (maxIndegree < currDegree.indegree) maxIndegree = currDegree.indegree;

        if (maxOutdegree < currDegree.outdegree) maxOutdegree = currDegree.outdegree;

        indegrees[node.id()] = currDegree.indegree;
        outdegrees[node.id()] = currDegree.outdegree;
      }

      return {
        indegree: function indegree(node) {
          if (maxIndegree == 0) return 0;

          if (is.string(node)) {
            // from is a selector string
            var node = cy.filter(node)[0].id();
          } else {
            // from is a node
            var node = node.id();
          }

          return indegrees[node] / maxIndegree;
        },
        outdegree: function outdegree(node) {
          if (maxOutdegree == 0) return 0;

          if (is.string(node)) {
            // from is a selector string
            var node = cy.filter(node)[0].id();
          } else {
            // from is a node
            var node = node.id();
          }

          return outdegrees[node] / maxOutdegree;
        }

      };
    }
  }, // degreeCentralityNormalized

  // Implemented from the algorithm in Opsahl's paper
  // "Node centrality in weighted networks: Generalizing degree and shortest paths"
  // check the heading 2 "Degree"
  degreeCentrality: function degreeCentrality(options) {
    options = options || {};

    var callingEles = this;

    // root - mandatory!
    if (options != null && options.root != null) {
      var root = is.string(options.root) ? this.filter(options.root)[0] : options.root[0];
    } else {
      return undefined;
    }

    // weight - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function weightFn(e) {
        return 1;
      };
    }

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    // alpha - optional
    if (options.alpha != null && is.number(options.alpha)) {
      var alpha = options.alpha;
    } else {
      alpha = 0;
    }

    if (!directed) {
      var connEdges = root.connectedEdges().intersection(callingEles);
      var k = connEdges.length;
      var s = 0;

      // Now, sum edge weights
      for (var i = 0; i < connEdges.length; i++) {
        var edge = connEdges[i];
        s += weightFn(edge);
      }

      return {
        degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
      };
    } else {
      var incoming = root.connectedEdges('edge[target = "' + root.id() + '"]').intersection(callingEles);
      var outgoing = root.connectedEdges('edge[source = "' + root.id() + '"]').intersection(callingEles);
      var k_in = incoming.length;
      var k_out = outgoing.length;
      var s_in = 0;
      var s_out = 0;

      // Now, sum incoming edge weights
      for (var i = 0; i < incoming.length; i++) {
        var edge = incoming[i];
        s_in += weightFn(edge);
      }

      // Now, sum outgoing edge weights
      for (var i = 0; i < outgoing.length; i++) {
        var edge = outgoing[i];
        s_out += weightFn(edge);
      }

      return {
        indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
        outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
      };
    }
  } // degreeCentrality

}; // elesfn

// nice, short mathemathical alias
elesfn.dc = elesfn.degreeCentrality;
elesfn.dcn = elesfn.degreeCentralityNormalised = elesfn.degreeCentralityNormalized;

module.exports = elesfn;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var Heap = __webpack_require__(8);

var elesfn = {

  dijkstra: function dijkstra(root, weightFn, directed) {
    var options;
    if (is.plainObject(root) && !is.elementOrCollection(root)) {
      options = root;
      root = options.root;
      weightFn = options.weight;
      directed = options.directed;
    }

    var cy = this._private.cy;
    weightFn = is.fn(weightFn) ? weightFn : function () {
      return 1;
    }; // if not specified, assume each edge has equal weight (1)

    var source = is.string(root) ? this.filter(root)[0] : root[0];
    var dist = {};
    var prev = {};
    var knownDist = {};

    var edges = this.edges().filter(function (ele) {
      return !ele.isLoop();
    });
    var nodes = this.nodes();

    var getDist = function getDist(node) {
      return dist[node.id()];
    };

    var setDist = function setDist(node, d) {
      dist[node.id()] = d;

      Q.updateItem(node);
    };

    var Q = new Heap(function (a, b) {
      return getDist(a) - getDist(b);
    });

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];

      dist[node.id()] = node.same(source) ? 0 : Infinity;
      Q.push(node);
    }

    var distBetween = function distBetween(u, v) {
      var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);
      var smallestDistance = Infinity;
      var smallestEdge;

      for (var i = 0; i < uvs.length; i++) {
        var edge = uvs[i];
        var weight = weightFn(edge);

        if (weight < smallestDistance || !smallestEdge) {
          smallestDistance = weight;
          smallestEdge = edge;
        }
      }

      return {
        edge: smallestEdge,
        dist: smallestDistance
      };
    };

    while (Q.size() > 0) {
      var u = Q.pop();
      var smalletsDist = getDist(u);
      var uid = u.id();

      knownDist[uid] = smalletsDist;

      if (smalletsDist === Infinity) {
        continue;
      }

      var neighbors = u.neighborhood().intersect(nodes);
      for (var i = 0; i < neighbors.length; i++) {
        var v = neighbors[i];
        var vid = v.id();
        var vDist = distBetween(u, v);

        var alt = smalletsDist + vDist.dist;

        if (alt < getDist(v)) {
          setDist(v, alt);

          prev[vid] = {
            node: u,
            edge: vDist.edge
          };
        }
      } // for
    } // while

    return {
      distanceTo: function distanceTo(node) {
        var target = is.string(node) ? nodes.filter(node)[0] : node[0];

        return knownDist[target.id()];
      },

      pathTo: function pathTo(node) {
        var target = is.string(node) ? nodes.filter(node)[0] : node[0];
        var S = [];
        var u = target;

        if (target.length > 0) {
          S.unshift(target);

          while (prev[u.id()]) {
            var p = prev[u.id()];

            S.unshift(p.edge);
            S.unshift(p.node);

            u = p.node;
          }
        }

        return cy.collection(S);
      }
    };
  }
};

module.exports = elesfn;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

var elesfn = {

  // Implemented from pseudocode from wikipedia
  floydWarshall: function floydWarshall(options) {
    options = options || {};

    var cy = this.cy();

    // Weight function - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function weightFn(e) {
        return 1;
      };
    }

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var edges = this.edges().stdFilter(function (e) {
      return !e.isLoop();
    });
    var nodes = this.nodes();
    var numNodes = nodes.length;

    // mapping: node id -> position in nodes array
    var id2position = {};
    for (var i = 0; i < numNodes; i++) {
      id2position[nodes[i].id()] = i;
    }

    // Initialize distance matrix
    var dist = [];
    for (var i = 0; i < numNodes; i++) {
      var newRow = new Array(numNodes);
      for (var j = 0; j < numNodes; j++) {
        if (i == j) {
          newRow[j] = 0;
        } else {
          newRow[j] = Infinity;
        }
      }
      dist.push(newRow);
    }

    // Initialize matrix used for path reconstruction
    // Initialize distance matrix
    var next = [];
    var edgeNext = [];

    var initMatrix = function initMatrix(next) {
      for (var i = 0; i < numNodes; i++) {
        var newRow = new Array(numNodes);
        for (var j = 0; j < numNodes; j++) {
          newRow[j] = undefined;
        }
        next.push(newRow);
      }
    };

    initMatrix(next);
    initMatrix(edgeNext);

    // Process edges
    for (var i = 0; i < edges.length; i++) {
      var sourceIndex = id2position[edges[i].source().id()];
      var targetIndex = id2position[edges[i].target().id()];
      var weight = weightFn(edges[i]);

      // Check if already process another edge between same 2 nodes
      if (dist[sourceIndex][targetIndex] > weight) {
        dist[sourceIndex][targetIndex] = weight;
        next[sourceIndex][targetIndex] = targetIndex;
        edgeNext[sourceIndex][targetIndex] = edges[i];
      }
    }

    // If undirected graph, process 'reversed' edges
    if (!directed) {
      for (var i = 0; i < edges.length; i++) {
        var sourceIndex = id2position[edges[i].target().id()];
        var targetIndex = id2position[edges[i].source().id()];
        var weight = weightFn(edges[i]);

        // Check if already process another edge between same 2 nodes
        if (dist[sourceIndex][targetIndex] > weight) {
          dist[sourceIndex][targetIndex] = weight;
          next[sourceIndex][targetIndex] = targetIndex;
          edgeNext[sourceIndex][targetIndex] = edges[i];
        }
      }
    }

    // Main loop
    for (var k = 0; k < numNodes; k++) {
      for (var i = 0; i < numNodes; i++) {
        for (var j = 0; j < numNodes; j++) {
          if (dist[i][k] + dist[k][j] < dist[i][j]) {
            dist[i][j] = dist[i][k] + dist[k][j];
            next[i][j] = next[i][k];
          }
        }
      }
    }

    // Build result object
    var position2id = [];
    for (var i = 0; i < numNodes; i++) {
      position2id.push(nodes[i].id());
    }

    var res = {
      distance: function distance(from, to) {
        if (is.string(from)) {
          // from is a selector string
          var fromId = cy.filter(from)[0].id();
        } else {
          // from is a node
          var fromId = from.id();
        }

        if (is.string(to)) {
          // to is a selector string
          var toId = cy.filter(to)[0].id();
        } else {
          // to is a node
          var toId = to.id();
        }

        return dist[id2position[fromId]][id2position[toId]];
      },

      path: function path(from, to) {
        var reconstructPathAux = function reconstructPathAux(from, to, next, position2id, edgeNext) {
          if (from === to) {
            return cy.getElementById(position2id[from]);
          }
          if (next[from][to] === undefined) {
            return undefined;
          }

          var path = [cy.getElementById(position2id[from])];
          var prev = from;
          while (from !== to) {
            prev = from;
            from = next[from][to];

            var edge = edgeNext[prev][from];
            path.push(edge);

            path.push(cy.getElementById(position2id[from]));
          }
          return path;
        };

        if (is.string(from)) {
          // from is a selector string
          var fromId = cy.filter(from)[0].id();
        } else {
          // from is a node
          var fromId = from.id();
        }

        if (is.string(to)) {
          // to is a selector string
          var toId = cy.filter(to)[0].id();
        } else {
          // to is a node
          var toId = to.id();
        }

        var pathArr = reconstructPathAux(id2position[fromId], id2position[toId], next, position2id, edgeNext);

        return cy.collection(pathArr);
      }
    };

    return res;
  } // floydWarshall

}; // elesfn

module.exports = elesfn;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

var elesfn = {};

[__webpack_require__(28), __webpack_require__(31), __webpack_require__(35), __webpack_require__(25), __webpack_require__(32), __webpack_require__(26), __webpack_require__(34), __webpack_require__(36), __webpack_require__(30), __webpack_require__(29), __webpack_require__(27)].forEach(function (props) {
  util.extend(elesfn, props);
});

module.exports = elesfn;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

var elesfn = {

  // Computes the minimum cut of an undirected graph
  // Returns the correct answer with high probability
  kargerStein: function kargerStein(options) {
    var eles = this;

    options = options || {};

    // Function which colapses 2 (meta) nodes into one
    // Updates the remaining edge lists
    // Receives as a paramater the edge which causes the collapse
    var colapse = function colapse(edgeIndex, nodeMap, remainingEdges) {
      var edgeInfo = remainingEdges[edgeIndex];
      var sourceIn = edgeInfo[1];
      var targetIn = edgeInfo[2];
      var partition1 = nodeMap[sourceIn];
      var partition2 = nodeMap[targetIn];

      // Delete all edges between partition1 and partition2
      var newEdges = remainingEdges.filter(function (edge) {
        if (nodeMap[edge[1]] === partition1 && nodeMap[edge[2]] === partition2) {
          return false;
        }
        if (nodeMap[edge[1]] === partition2 && nodeMap[edge[2]] === partition1) {
          return false;
        }
        return true;
      });

      // All edges pointing to partition2 should now point to partition1
      for (var i = 0; i < newEdges.length; i++) {
        var edge = newEdges[i];
        if (edge[1] === partition2) {
          // Check source
          newEdges[i] = edge.slice(0);
          newEdges[i][1] = partition1;
        } else if (edge[2] === partition2) {
          // Check target
          newEdges[i] = edge.slice(0);
          newEdges[i][2] = partition1;
        }
      }

      // Move all nodes from partition2 to partition1
      for (var i = 0; i < nodeMap.length; i++) {
        if (nodeMap[i] === partition2) {
          nodeMap[i] = partition1;
        }
      }

      return newEdges;
    };

    // Contracts a graph until we reach a certain number of meta nodes
    var contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {
      // Stop condition
      if (size <= sizeLimit) {
        return remainingEdges;
      }

      // Choose an edge randomly
      var edgeIndex = Math.floor(Math.random() * remainingEdges.length);

      // Colapse graph based on edge
      var newEdges = colapse(edgeIndex, metaNodeMap, remainingEdges);

      return contractUntil(metaNodeMap, newEdges, size - 1, sizeLimit);
    };

    var cy = this._private.cy;
    var edges = this.edges().stdFilter(function (e) {
      return !e.isLoop();
    });
    var nodes = this.nodes();
    var numNodes = nodes.length;
    var numEdges = edges.length;
    var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
    var stopSize = Math.floor(numNodes / Math.sqrt(2));

    if (numNodes < 2) {
      util.error('At least 2 nodes are required for Karger-Stein algorithm');
      return undefined;
    }

    // Create numerical identifiers for each node
    // mapping: node id -> position in nodes array
    // for reverse mapping, simply use nodes array
    var id2position = {};
    for (var i = 0; i < numNodes; i++) {
      id2position[nodes[i].id()] = i;
    }

    // Now store edge destination as indexes
    // Format for each edge (edge index, source node index, target node index)
    var edgeIndexes = [];
    for (var i = 0; i < numEdges; i++) {
      var e = edges[i];
      edgeIndexes.push([i, id2position[e.source().id()], id2position[e.target().id()]]);
    }

    // We will store the best cut found here
    var minCutSize = Infinity;
    var minCut;

    // Initial meta node partition
    var originalMetaNode = [];
    for (var i = 0; i < numNodes; i++) {
      originalMetaNode.push(i);
    }

    // Main loop
    for (var iter = 0; iter <= numIter; iter++) {
      // Create new meta node partition
      var metaNodeMap = originalMetaNode.slice(0);

      // Contract until stop point (stopSize nodes)
      var edgesState = contractUntil(metaNodeMap, edgeIndexes, numNodes, stopSize);

      // Create a copy of the colapsed nodes state
      var metaNodeMap2 = metaNodeMap.slice(0);

      // Run 2 iterations starting in the stop state
      var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
      var res2 = contractUntil(metaNodeMap2, edgesState, stopSize, 2);

      // Is any of the 2 results the best cut so far?
      if (res1.length <= res2.length && res1.length < minCutSize) {
        minCutSize = res1.length;
        minCut = [res1, metaNodeMap];
      } else if (res2.length <= res1.length && res2.length < minCutSize) {
        minCutSize = res2.length;
        minCut = [res2, metaNodeMap2];
      }
    } // end of main loop


    // Construct result
    var resEdges = minCut[0].map(function (e) {
      return edges[e[0]];
    });
    var partition1 = [];
    var partition2 = [];

    // traverse metaNodeMap for best cut
    var witnessNodePartition = minCut[1][0];
    for (var i = 0; i < minCut[1].length; i++) {
      var partitionId = minCut[1][i];
      if (partitionId === witnessNodePartition) {
        partition1.push(nodes[i]);
      } else {
        partition2.push(nodes[i]);
      }
    }

    var ret = {
      cut: eles.spawn(cy, resEdges),
      partition1: eles.spawn(partition1),
      partition2: eles.spawn(partition2)
    };

    return ret;
  }
}; // elesfn


module.exports = elesfn;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

// search, spanning trees, etc
var elesfn = {

  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
  // implemented from pseudocode from wikipedia
  kruskal: function kruskal(weightFn) {
    var cy = this.cy();

    weightFn = is.fn(weightFn) ? weightFn : function () {
      return 1;
    }; // if not specified, assume each edge has equal weight (1)

    function findSet(ele) {
      for (var i = 0; i < forest.length; i++) {
        var eles = forest[i];

        if (eles.anySame(ele)) {
          return {
            eles: eles,
            index: i
          };
        }
      }
    }

    var A = cy.collection(cy, []);
    var forest = [];
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      forest.push(nodes[i].collection());
    }

    var edges = this.edges();
    var S = edges.toArray().sort(function (a, b) {
      var weightA = weightFn(a);
      var weightB = weightFn(b);

      return weightA - weightB;
    });

    for (var i = 0; i < S.length; i++) {
      var edge = S[i];
      var u = edge.source()[0];
      var v = edge.target()[0];
      var setU = findSet(u);
      var setV = findSet(v);

      if (setU.index !== setV.index) {
        A = A.add(edge);

        // combine forests for u and v
        forest[setU.index] = setU.eles.add(setV.eles);
        forest.splice(setV.index, 1);
      }
    }

    return nodes.add(A);
  }
};

module.exports = elesfn;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

var elesfn = {

  pageRank: function pageRank(options) {
    options = options || {};

    var normalizeVector = function normalizeVector(vector) {
      var length = vector.length;

      // First, get sum of all elements
      var total = 0;
      for (var i = 0; i < length; i++) {
        total += vector[i];
      }

      // Now, divide each by the sum of all elements
      for (var i = 0; i < length; i++) {
        vector[i] = vector[i] / total;
      }
    };

    // dampingFactor - optional
    if (options != null && options.dampingFactor != null) {
      var dampingFactor = options.dampingFactor;
    } else {
      var dampingFactor = 0.8; // Default damping factor
    }

    // desired precision - optional
    if (options != null && options.precision != null) {
      var epsilon = options.precision;
    } else {
      var epsilon = 0.000001; // Default precision
    }

    // Max number of iterations - optional
    if (options != null && options.iterations != null) {
      var numIter = options.iterations;
    } else {
      var numIter = 200; // Default number of iterations
    }

    // Weight function - optional
    if (options != null && options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function weightFn(e) {
        return 1;
      };
    }

    var cy = this._private.cy;
    var edges = this.edges().stdFilter(function (e) {
      return !e.isLoop();
    });
    var nodes = this.nodes();
    var numNodes = nodes.length;
    var numEdges = edges.length;

    // Create numerical identifiers for each node
    // mapping: node id -> position in nodes array
    // for reverse mapping, simply use nodes array
    var id2position = {};
    for (var i = 0; i < numNodes; i++) {
      id2position[nodes[i].id()] = i;
    }

    // Construct transposed adjacency matrix
    // First lets have a zeroed matrix of the right size
    // We'll also keep track of the sum of each column
    var matrix = [];
    var columnSum = [];
    var additionalProb = (1 - dampingFactor) / numNodes;

    // Create null matric
    for (var i = 0; i < numNodes; i++) {
      var newRow = [];
      for (var j = 0; j < numNodes; j++) {
        newRow.push(0.0);
      }
      matrix.push(newRow);
      columnSum.push(0.0);
    }

    // Now, process edges
    for (var i = 0; i < numEdges; i++) {
      var edge = edges[i];
      var s = id2position[edge.source().id()];
      var t = id2position[edge.target().id()];
      var w = weightFn(edge);

      // Update matrix
      matrix[t][s] += w;

      // Update column sum
      columnSum[s] += w;
    }

    // Add additional probability based on damping factor
    // Also, take into account columns that have sum = 0
    var p = 1.0 / numNodes + additionalProb; // Shorthand
    // Traverse matrix, column by column
    for (var j = 0; j < numNodes; j++) {
      if (columnSum[j] === 0) {
        // No 'links' out from node jth, assume equal probability for each possible node
        for (var i = 0; i < numNodes; i++) {
          matrix[i][j] = p;
        }
      } else {
        // Node jth has outgoing link, compute normalized probabilities
        for (var i = 0; i < numNodes; i++) {
          matrix[i][j] = matrix[i][j] / columnSum[j] + additionalProb;
        }
      }
    }

    // Compute dominant eigenvector using power method
    var eigenvector = [];
    var nullVector = [];
    var previous;

    // Start with a vector of all 1's
    // Also, initialize a null vector which will be used as shorthand
    for (var i = 0; i < numNodes; i++) {
      eigenvector.push(1.0);
      nullVector.push(0.0);
    }

    for (var iter = 0; iter < numIter; iter++) {
      // New array with all 0's
      var temp = nullVector.slice(0);

      // Multiply matrix with previous result
      for (var i = 0; i < numNodes; i++) {
        for (var j = 0; j < numNodes; j++) {
          temp[i] += matrix[i][j] * eigenvector[j];
        }
      }

      normalizeVector(temp);
      previous = eigenvector;
      eigenvector = temp;

      var diff = 0;
      // Compute difference (squared module) of both vectors
      for (var i = 0; i < numNodes; i++) {
        diff += Math.pow(previous[i] - eigenvector[i], 2);
      }

      // If difference is less than the desired threshold, stop iterating
      if (diff < epsilon) {
        break;
      }
    }

    // Construct result
    var res = {
      rank: function rank(node) {
        if (is.string(node)) {
          // is a selector string
          var nodeId = cy.filter(node)[0].id();
        } else {
          // is a node object
          var nodeId = node.id();
        }
        return eigenvector[id2position[nodeId]];
      }
    };

    return res;
  } // pageRank

}; // elesfn

module.exports = elesfn;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(3);

var elesfn = {
  animate: define.animate(),
  animation: define.animation(),
  animated: define.animated(),
  clearQueue: define.clearQueue(),
  delay: define.delay(),
  delayAnimation: define.delayAnimation(),
  stop: define.stop()
};

module.exports = elesfn;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Set = __webpack_require__(9);

var elesfn = {
  classes: function classes(_classes) {
    _classes = (_classes || '').match(/\S+/g) || [];
    var self = this;
    var changed = [];
    var classesMap = new Set(_classes);

    // check and update each ele

    var _loop = function _loop(j) {
      var ele = self[j];
      var _p = ele._private;
      var eleClasses = _p.classes;
      var changedEle = false;

      // check if ele has all of the passed classes
      classesMap.forEach(function (cls) {
        var eleHasClass = eleClasses.has(cls);

        if (!eleHasClass) {
          changedEle = true;
        }
      });

      // check if ele has classes outside of those passed
      if (!changedEle) {
        eleClasses.forEach(function (eleCls) {
          var specdClass = classesMap.has(eleCls);

          if (!specdClass) {
            changedEle = true;
          }
        });
      }

      if (changedEle) {
        _p.classes = new Set(classesMap);

        changed.push(ele);
      }
    };

    for (var j = 0; j < self.length; j++) {
      _loop(j);
    }

    // trigger update style on those eles that had class changes
    if (changed.length > 0) {
      this.spawn(changed).updateStyle().emit('class');
    }

    return self;
  },

  addClass: function addClass(classes) {
    return this.toggleClass(classes, true);
  },

  hasClass: function hasClass(className) {
    var ele = this[0];
    return ele != null && ele._private.classes.has(className);
  },

  toggleClass: function toggleClass(classesStr, toggle) {
    var classes = classesStr.match(/\S+/g) || [];
    var self = this;
    var changed = []; // eles who had classes changed

    for (var i = 0, il = self.length; i < il; i++) {
      var _ele = self[i];
      var _changedEle = false;

      for (var j = 0; j < classes.length; j++) {
        var cls = classes[j];
        var _eleClasses = _ele._private.classes;
        var hasClass = _eleClasses.has(cls);
        var shouldAdd = toggle || toggle === undefined && !hasClass;

        if (shouldAdd) {
          _eleClasses.add(cls);

          if (!hasClass && !_changedEle) {
            changed.push(_ele);
            _changedEle = true;
          }
        } else {
          // then remove
          _eleClasses.delete(cls);

          if (hasClass && !_changedEle) {
            changed.push(_ele);
            _changedEle = true;
          }
        }
      } // for j classes
    } // for i eles

    // trigger update style on those eles that had class changes
    if (changed.length > 0) {
      this.spawn(changed).updateStyle().emit('class');
    }

    return self;
  },

  removeClass: function removeClass(classes) {
    return this.toggleClass(classes, false);
  },

  flashClass: function flashClass(classes, duration) {
    var self = this;

    if (duration == null) {
      duration = 250;
    } else if (duration === 0) {
      return self; // nothing to do really
    }

    self.addClass(classes);
    setTimeout(function () {
      self.removeClass(classes);
    }, duration);

    return self;
  }
};

module.exports = elesfn;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var Selector = __webpack_require__(6);

var elesfn = {
  allAre: function allAre(selector) {
    var selObj = new Selector(selector);

    return this.every(function (ele) {
      return selObj.matches(ele);
    });
  },

  is: function is(selector) {
    var selObj = new Selector(selector);

    return this.some(function (ele) {
      return selObj.matches(ele);
    });
  },

  some: function some(fn, thisArg) {
    for (var i = 0; i < this.length; i++) {
      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);

      if (ret) {
        return true;
      }
    }

    return false;
  },

  every: function every(fn, thisArg) {
    for (var i = 0; i < this.length; i++) {
      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);

      if (!ret) {
        return false;
      }
    }

    return true;
  },

  same: function same(collection) {
    collection = this.cy().collection(collection);

    // cheap extra check
    if (this.length !== collection.length) {
      return false;
    }

    return this.every(function (ele) {
      return collection.hasElementWithId(ele.id());
    });
  },

  anySame: function anySame(collection) {
    collection = this.cy().collection(collection);

    return this.some(function (ele) {
      return collection.hasElementWithId(ele.id());
    });
  },

  allAreNeighbors: function allAreNeighbors(collection) {
    collection = this.cy().collection(collection);

    var nhood = this.neighborhood();

    return collection.every(function (ele) {
      return nhood.hasElementWithId(ele.id());
    });
  },

  contains: function contains(collection) {
    collection = this.cy().collection(collection);

    var self = this;

    return collection.every(function (ele) {
      return self.hasElementWithId(ele.id());
    });
  }
};

elesfn.allAreNeighbours = elesfn.allAreNeighbors;
elesfn.has = elesfn.contains;

module.exports = elesfn;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Set = __webpack_require__(9);

var elesfn = {
  parent: function parent(selector) {
    var parents = [];

    // optimisation for single ele call
    if (this.length === 1) {
      var parent = this[0]._private.parent;

      if (parent) {
        return parent;
      }
    }

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var _parent = ele._private.parent;

      if (_parent) {
        parents.push(_parent);
      }
    }

    return this.spawn(parents, { unique: true }).filter(selector);
  },

  parents: function parents(selector) {
    var parents = [];

    var eles = this.parent();
    while (eles.nonempty()) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        parents.push(ele);
      }

      eles = eles.parent();
    }

    return this.spawn(parents, { unique: true }).filter(selector);
  },

  commonAncestors: function commonAncestors(selector) {
    var ancestors = void 0;

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var parents = ele.parents();

      ancestors = ancestors || parents;

      ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set
    }

    return ancestors.filter(selector);
  },

  orphans: function orphans(selector) {
    return this.stdFilter(function (ele) {
      return ele.isOrphan();
    }).filter(selector);
  },

  nonorphans: function nonorphans(selector) {
    return this.stdFilter(function (ele) {
      return ele.isChild();
    }).filter(selector);
  },

  children: function children(selector) {
    var children = [];

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      children = children.concat(ele._private.children);
    }

    return this.spawn(children, { unique: true }).filter(selector);
  },

  siblings: function siblings(selector) {
    return this.parent().children().not(this).filter(selector);
  },

  isParent: function isParent() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.children.length !== 0;
    }
  },

  isChildless: function isChildless() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.children.length === 0;
    }
  },

  isChild: function isChild() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.parent != null;
    }
  },

  isOrphan: function isOrphan() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.parent == null;
    }
  },

  descendants: function descendants(selector) {
    var elements = [];

    function add(eles) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];

        elements.push(ele);

        if (ele.children().nonempty()) {
          add(ele.children());
        }
      }
    }

    add(this.children());

    return this.spawn(elements, { unique: true }).filter(selector);
  }
};

function forEachCompound(eles, fn, includeSelf, recursiveStep) {
  var q = [];
  var did = new Set();
  var cy = eles.cy();
  var hasCompounds = cy.hasCompoundNodes();

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (includeSelf) {
      q.push(ele);
    } else if (hasCompounds) {
      recursiveStep(q, did, ele);
    }
  }

  while (q.length > 0) {
    var _ele = q.shift();

    fn(_ele);

    did.add(_ele.id());

    if (hasCompounds) {
      recursiveStep(q, did, _ele);
    }
  }

  return eles;
}

function addChildren(q, did, ele) {
  if (ele.isParent()) {
    var children = ele._private.children;

    for (var i = 0; i < children.length; i++) {
      var child = children[i];

      if (!did.has(child.id())) {
        q.push(child);
      }
    }
  }
}

// very efficient version of eles.add( eles.descendants() ).forEach()
// for internal use
elesfn.forEachDown = function (fn) {
  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  return forEachCompound(this, fn, includeSelf, addChildren);
};

function addParent(q, did, ele) {
  if (ele.isChild()) {
    var parent = ele._private.parent;

    if (!did.has(parent.id())) {
      q.push(parent);
    }
  }
}

elesfn.forEachUp = function (fn) {
  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  return forEachCompound(this, fn, includeSelf, addParent);
};

function addParentAndChildren(q, did, ele) {
  addParent(q, did, ele);
  addChildren(q, did, ele);
}

elesfn.forEachUpAndDown = function (fn) {
  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  return forEachCompound(this, fn, includeSelf, addParentAndChildren);
};

// aliases
elesfn.ancestors = elesfn.parents;

module.exports = elesfn;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(3);
var fn = void 0,
    elesfn = void 0;

fn = elesfn = {

  data: define.data({
    field: 'data',
    bindingEvent: 'data',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'data',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  }),

  removeData: define.removeData({
    field: 'data',
    event: 'data',
    triggerFnName: 'trigger',
    triggerEvent: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  }),

  scratch: define.data({
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    updateStyle: true
  }),

  removeScratch: define.removeData({
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true,
    updateStyle: true
  }),

  rscratch: define.data({
    field: 'rscratch',
    allowBinding: false,
    allowSetting: true,
    settingTriggersEvent: false,
    allowGetting: true
  }),

  removeRscratch: define.removeData({
    field: 'rscratch',
    triggerEvent: false
  }),

  id: function id() {
    var ele = this[0];

    if (ele) {
      return ele._private.data.id;
    }
  }

};

// aliases
fn.attr = fn.data;
fn.removeAttr = fn.removeData;

module.exports = elesfn;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

var elesfn = {};

function defineDegreeFunction(callback) {
  return function (includeLoops) {
    var self = this;

    if (includeLoops === undefined) {
      includeLoops = true;
    }

    if (self.length === 0) {
      return;
    }

    if (self.isNode() && !self.removed()) {
      var degree = 0;
      var node = self[0];
      var connectedEdges = node._private.edges;

      for (var i = 0; i < connectedEdges.length; i++) {
        var edge = connectedEdges[i];

        if (!includeLoops && edge.isLoop()) {
          continue;
        }

        degree += callback(node, edge);
      }

      return degree;
    } else {
      return;
    }
  };
}

util.extend(elesfn, {
  degree: defineDegreeFunction(function (node, edge) {
    if (edge.source().same(edge.target())) {
      return 2;
    } else {
      return 1;
    }
  }),

  indegree: defineDegreeFunction(function (node, edge) {
    if (edge.target().same(node)) {
      return 1;
    } else {
      return 0;
    }
  }),

  outdegree: defineDegreeFunction(function (node, edge) {
    if (edge.source().same(node)) {
      return 1;
    } else {
      return 0;
    }
  })
});

function defineDegreeBoundsFunction(degreeFn, callback) {
  return function (includeLoops) {
    var ret = void 0;
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      var ele = nodes[i];
      var degree = ele[degreeFn](includeLoops);
      if (degree !== undefined && (ret === undefined || callback(degree, ret))) {
        ret = degree;
      }
    }

    return ret;
  };
}

util.extend(elesfn, {
  minDegree: defineDegreeBoundsFunction('degree', function (degree, min) {
    return degree < min;
  }),

  maxDegree: defineDegreeBoundsFunction('degree', function (degree, max) {
    return degree > max;
  }),

  minIndegree: defineDegreeBoundsFunction('indegree', function (degree, min) {
    return degree < min;
  }),

  maxIndegree: defineDegreeBoundsFunction('indegree', function (degree, max) {
    return degree > max;
  }),

  minOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, min) {
    return degree < min;
  }),

  maxOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, max) {
    return degree > max;
  })
});

util.extend(elesfn, {
  totalDegree: function totalDegree(includeLoops) {
    var total = 0;
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      total += nodes[i].degree(includeLoops);
    }

    return total;
  }
});

module.exports = elesfn;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);
var math = __webpack_require__(2);
var fn = void 0,
    elesfn = void 0;

fn = elesfn = {};

elesfn.renderedBoundingBox = function (options) {
  var bb = this.boundingBox(options);
  var cy = this.cy();
  var zoom = cy.zoom();
  var pan = cy.pan();

  var x1 = bb.x1 * zoom + pan.x;
  var x2 = bb.x2 * zoom + pan.x;
  var y1 = bb.y1 * zoom + pan.y;
  var y2 = bb.y2 * zoom + pan.y;

  return {
    x1: x1,
    x2: x2,
    y1: y1,
    y2: y2,
    w: x2 - x1,
    h: y2 - y1
  };
};

elesfn.dirtyCompoundBoundsCache = function () {
  var cy = this.cy();

  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
    return this;
  }

  this.forEachUp(function (ele) {
    ele._private.compoundBoundsClean = false;

    if (ele.isParent()) {
      ele.emit('bounds');
    }
  });

  return this;
};

elesfn.updateCompoundBounds = function () {
  var cy = this.cy();

  // save cycles for non compound graphs or when style disabled
  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
    return this;
  }

  // save cycles when batching -- but bounds will be stale (or not exist yet)
  if (cy.batching()) {
    return this;
  }

  var updated = [];

  function update(parent) {
    if (!parent.isParent()) {
      return;
    }

    var _p = parent._private;
    var children = parent.children();
    var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';

    var min = {
      width: {
        val: parent.pstyle('min-width').pfValue,
        left: parent.pstyle('min-width-bias-left'),
        right: parent.pstyle('min-width-bias-right')
      },
      height: {
        val: parent.pstyle('min-height').pfValue,
        top: parent.pstyle('min-height-bias-top'),
        bottom: parent.pstyle('min-height-bias-bottom')
      }
    };

    var bb = children.boundingBox({
      includeLabels: includeLabels,
      includeOverlays: false,

      // updating the compound bounds happens outside of the regular
      // cache cycle (i.e. before fired events)
      useCache: false
    });
    var pos = _p.position;

    // if children take up zero area then keep position and fall back on stylesheet w/h
    if (bb.w === 0 || bb.h === 0) {
      bb = {
        w: parent.pstyle('width').pfValue,
        h: parent.pstyle('height').pfValue
      };

      bb.x1 = pos.x - bb.w / 2;
      bb.x2 = pos.x + bb.w / 2;
      bb.y1 = pos.y - bb.h / 2;
      bb.y2 = pos.y + bb.h / 2;
    }

    function computeBiasValues(propDiff, propBias, propBiasComplement) {
      var biasDiff = 0;
      var biasComplementDiff = 0;
      var biasTotal = propBias + propBiasComplement;

      if (propDiff > 0 && biasTotal > 0) {
        biasDiff = propBias / biasTotal * propDiff;
        biasComplementDiff = propBiasComplement / biasTotal * propDiff;
      }
      return {
        biasDiff: biasDiff,
        biasComplementDiff: biasComplementDiff
      };
    }

    function computePaddingValues(width, height, paddingObject, relativeTo) {
      // Assuming percentage is number from 0 to 1
      if (paddingObject.units === '%') {
        switch (relativeTo) {
          case 'width':
            return width > 0 ? paddingObject.pfValue * width : 0;
          case 'height':
            return height > 0 ? paddingObject.pfValue * height : 0;
          case 'average':
            return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;
          case 'min':
            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;
          case 'max':
            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;
          default:
            return 0;
        }
      } else if (paddingObject.units === 'px') {
        return paddingObject.pfValue;
      } else {
        return 0;
      }
    }

    var leftVal = min.width.left.value;
    if (min.width.left.units === 'px' && min.width.val > 0) {
      leftVal = leftVal * 100 / min.width.val;
    }
    var rightVal = min.width.right.value;
    if (min.width.right.units === 'px' && min.width.val > 0) {
      rightVal = rightVal * 100 / min.width.val;
    }

    var topVal = min.height.top.value;
    if (min.height.top.units === 'px' && min.height.val > 0) {
      topVal = topVal * 100 / min.height.val;
    }

    var bottomVal = min.height.bottom.value;
    if (min.height.bottom.units === 'px' && min.height.val > 0) {
      bottomVal = bottomVal * 100 / min.height.val;
    }

    var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);
    var diffLeft = widthBiasDiffs.biasDiff;
    var diffRight = widthBiasDiffs.biasComplementDiff;

    var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);
    var diffTop = heightBiasDiffs.biasDiff;
    var diffBottom = heightBiasDiffs.biasComplementDiff;

    _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);

    _p.autoWidth = Math.max(bb.w, min.width.val);
    pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;

    _p.autoHeight = Math.max(bb.h, min.height.val);
    pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;

    updated.push(parent);
  }

  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var _p = ele._private;

    if (!_p.compoundBoundsClean) {
      update(ele);

      if (!cy._private.batchingStyle) {
        _p.compoundBoundsClean = true;
      }
    }
  }

  return this;
};

var noninf = function noninf(x) {
  if (x === Infinity || x === -Infinity) {
    return 0;
  }

  return x;
};

var updateBounds = function updateBounds(b, x1, y1, x2, y2) {
  // don't update with zero area boxes
  if (x2 - x1 === 0 || y2 - y1 === 0) {
    return;
  }

  // don't update with null dim
  if (x1 == null || y1 == null || x2 == null || y2 == null) {
    return;
  }

  b.x1 = x1 < b.x1 ? x1 : b.x1;
  b.x2 = x2 > b.x2 ? x2 : b.x2;
  b.y1 = y1 < b.y1 ? y1 : b.y1;
  b.y2 = y2 > b.y2 ? y2 : b.y2;
};

var updateBoundsFromBox = function updateBoundsFromBox(b, b2) {
  return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);
};

var prefixedProperty = function prefixedProperty(obj, field, prefix) {
  return util.getPrefixedProperty(obj, field, prefix);
};

var updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {
  if (ele.cy().headless()) {
    return;
  }

  var _p = ele._private;
  var rstyle = _p.rstyle;
  var halfArW = rstyle.arrowWidth / 2;
  var arrowType = ele.pstyle(prefix + '-arrow-shape').value;
  var x = void 0;
  var y = void 0;

  if (arrowType !== 'none') {
    if (prefix === 'source') {
      x = rstyle.srcX;
      y = rstyle.srcY;
    } else if (prefix === 'target') {
      x = rstyle.tgtX;
      y = rstyle.tgtY;
    } else {
      x = rstyle.midX;
      y = rstyle.midY;
    }

    updateBounds(bounds, x - halfArW, y - halfArW, x + halfArW, y + halfArW);
  }
};

var updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {
  if (ele.cy().headless()) {
    return;
  }

  var prefixDash = void 0;

  if (prefix) {
    prefixDash = prefix + '-';
  } else {
    prefixDash = '';
  }

  var _p = ele._private;
  var rstyle = _p.rstyle;
  var label = ele.pstyle(prefixDash + 'label').strValue;

  if (label) {
    var halign = ele.pstyle('text-halign');
    var valign = ele.pstyle('text-valign');
    var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);
    var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);
    var labelX = prefixedProperty(rstyle, 'labelX', prefix);
    var labelY = prefixedProperty(rstyle, 'labelY', prefix);
    var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;
    var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;
    var isEdge = ele.isEdge();
    var rotation = ele.pstyle(prefixDash + 'text-rotation');
    var outlineWidth = ele.pstyle('text-outline-width').pfValue;
    var borderWidth = ele.pstyle('text-border-width').pfValue;
    var halfBorderWidth = borderWidth / 2;
    var padding = ele.pstyle('text-background-padding').pfValue;

    var lh = labelHeight + 2 * padding;
    var lw = labelWidth + 2 * padding;
    var lw_2 = lw / 2;
    var lh_2 = lh / 2;
    var lx1 = void 0,
        lx2 = void 0,
        ly1 = void 0,
        ly2 = void 0;

    if (isEdge) {
      lx1 = labelX - lw_2;
      lx2 = labelX + lw_2;
      ly1 = labelY - lh_2;
      ly2 = labelY + lh_2;
    } else {
      switch (halign.value) {
        case 'left':
          lx1 = labelX - lw;
          lx2 = labelX;
          break;

        case 'center':
          lx1 = labelX - lw_2;
          lx2 = labelX + lw_2;
          break;

        case 'right':
          lx1 = labelX;
          lx2 = labelX + lw;
          break;
      }

      switch (valign.value) {
        case 'top':
          ly1 = labelY - lh;
          ly2 = labelY;
          break;

        case 'center':
          ly1 = labelY - lh_2;
          ly2 = labelY + lh_2;
          break;

        case 'bottom':
          ly1 = labelY;
          ly2 = labelY + lh;
          break;
      }
    }

    var isAutorotate = isEdge && rotation.strValue === 'autorotate';
    var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;

    if (isAutorotate || isPfValue) {
      var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;
      var cos = Math.cos(theta);
      var sin = Math.sin(theta);

      var rotate = function rotate(x, y) {
        x = x - labelX;
        y = y - labelY;

        return {
          x: x * cos - y * sin + labelX,
          y: x * sin + y * cos + labelY
        };
      };

      var px1y1 = rotate(lx1, ly1);
      var px1y2 = rotate(lx1, ly2);
      var px2y1 = rotate(lx2, ly1);
      var px2y2 = rotate(lx2, ly2);

      lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
      lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
      ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
      ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
    }

    lx1 += marginX - Math.max(outlineWidth, halfBorderWidth);
    lx2 += marginX + Math.max(outlineWidth, halfBorderWidth);
    ly1 += marginY - Math.max(outlineWidth, halfBorderWidth);
    ly2 += marginY + Math.max(outlineWidth, halfBorderWidth);

    updateBounds(bounds, lx1, ly1, lx2, ly2);
  }

  return bounds;
};

// get the bounding box of the elements (in raw model position)
var boundingBoxImpl = function boundingBoxImpl(ele, options) {
  var cy = ele._private.cy;
  var styleEnabled = cy.styleEnabled();
  var headless = cy.headless();

  var bounds = {
    x1: Infinity,
    y1: Infinity,
    x2: -Infinity,
    y2: -Infinity
  };

  var _p = ele._private;
  var display = styleEnabled ? ele.pstyle('display').value : 'element';
  var isNode = ele.isNode();
  var isEdge = ele.isEdge();
  var ex1 = void 0,
      ex2 = void 0,
      ey1 = void 0,
      ey2 = void 0; // extrema of body / lines
  var x = void 0,
      y = void 0; // node pos
  var displayed = display !== 'none';

  if (displayed) {
    var overlayOpacity = 0;
    var overlayPadding = 0;

    if (styleEnabled && options.includeOverlays) {
      overlayOpacity = ele.pstyle('overlay-opacity').value;

      if (overlayOpacity !== 0) {
        overlayPadding = ele.pstyle('overlay-padding').value;
      }
    }

    var w = 0;
    var wHalf = 0;

    if (styleEnabled) {
      w = ele.pstyle('width').pfValue;
      wHalf = w / 2;
    }

    if (isNode && options.includeNodes) {
      var pos = ele.position();
      x = pos.x;
      y = pos.y;
      var _w = ele.outerWidth();
      var halfW = _w / 2;
      var h = ele.outerHeight();
      var halfH = h / 2;

      // handle node dimensions
      /////////////////////////

      ex1 = x - halfW - overlayPadding;
      ex2 = x + halfW + overlayPadding;
      ey1 = y - halfH - overlayPadding;
      ey2 = y + halfH + overlayPadding;

      updateBounds(bounds, ex1, ey1, ex2, ey2);
    } else if (isEdge && options.includeEdges) {
      var rstyle = _p.rstyle || {};

      // handle edge dimensions (rough box estimate)
      //////////////////////////////////////////////
      if (styleEnabled && !headless) {
        ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);
        ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);
        ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);
        ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY);

        // take into account edge width
        ex1 -= wHalf;
        ex2 += wHalf;
        ey1 -= wHalf;
        ey2 += wHalf;

        updateBounds(bounds, ex1, ey1, ex2, ey2);
      }

      // precise haystacks
      ////////////////////
      if (styleEnabled && !headless && ele.pstyle('curve-style').strValue === 'haystack') {
        var hpts = rstyle.haystackPts || [];

        ex1 = hpts[0].x;
        ey1 = hpts[0].y;
        ex2 = hpts[1].x;
        ey2 = hpts[1].y;

        if (ex1 > ex2) {
          var temp = ex1;
          ex1 = ex2;
          ex2 = temp;
        }

        if (ey1 > ey2) {
          var _temp = ey1;
          ey1 = ey2;
          ey2 = _temp;
        }

        updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);

        // handle points along edge
        ///////////////////////////
      } else {
        var pts = rstyle.bezierPts || rstyle.linePts || [];

        for (var j = 0; j < pts.length; j++) {
          var pt = pts[j];

          ex1 = pt.x - wHalf;
          ex2 = pt.x + wHalf;
          ey1 = pt.y - wHalf;
          ey2 = pt.y + wHalf;

          updateBounds(bounds, ex1, ey1, ex2, ey2);
        }

        // fallback on source and target positions
        //////////////////////////////////////////
        if (pts.length === 0) {
          var n1 = ele.source();
          var n1pos = n1.position();

          var n2 = ele.target();
          var n2pos = n2.position();

          ex1 = n1pos.x;
          ex2 = n2pos.x;
          ey1 = n1pos.y;
          ey2 = n2pos.y;

          if (ex1 > ex2) {
            var _temp2 = ex1;
            ex1 = ex2;
            ex2 = _temp2;
          }

          if (ey1 > ey2) {
            var _temp3 = ey1;
            ey1 = ey2;
            ey2 = _temp3;
          }

          // take into account edge width
          ex1 -= wHalf;
          ex2 += wHalf;
          ey1 -= wHalf;
          ey2 += wHalf;

          updateBounds(bounds, ex1, ey1, ex2, ey2);
        }
      }
    } // edges


    // handle edge arrow size
    /////////////////////////

    if (styleEnabled && options.includeEdges && isEdge) {
      updateBoundsFromArrow(bounds, ele, 'mid-source', options);
      updateBoundsFromArrow(bounds, ele, 'mid-target', options);
      updateBoundsFromArrow(bounds, ele, 'source', options);
      updateBoundsFromArrow(bounds, ele, 'target', options);
    }

    // ghost
    ////////

    if (styleEnabled) {
      var ghost = ele.pstyle('ghost').value === 'yes';

      if (ghost) {
        var gx = ele.pstyle('ghost-offset-x').pfValue;
        var gy = ele.pstyle('ghost-offset-y').pfValue;

        updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);
      }
    }

    // overlay
    //////////

    if (styleEnabled) {

      ex1 = bounds.x1;
      ex2 = bounds.x2;
      ey1 = bounds.y1;
      ey2 = bounds.y2;

      updateBounds(bounds, ex1 - overlayPadding, ey1 - overlayPadding, ex2 + overlayPadding, ey2 + overlayPadding);
    }

    // handle label dimensions
    //////////////////////////

    if (styleEnabled && options.includeLabels) {
      updateBoundsFromLabel(bounds, ele, null, options);

      if (isEdge) {
        updateBoundsFromLabel(bounds, ele, 'source', options);
        updateBoundsFromLabel(bounds, ele, 'target', options);
      }
    } // style enabled for labels
  } // if displayed

  bounds.x1 = noninf(bounds.x1);
  bounds.y1 = noninf(bounds.y1);
  bounds.x2 = noninf(bounds.x2);
  bounds.y2 = noninf(bounds.y2);
  bounds.w = noninf(bounds.x2 - bounds.x1);
  bounds.h = noninf(bounds.y2 - bounds.y1);

  // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides
  if (bounds.w > 0 && bounds.h > 0 && displayed) {
    math.expandBoundingBox(bounds, 1);
  }

  return bounds;
};

var tf = function tf(val) {
  if (val) {
    return 't';
  } else {
    return 'f';
  }
};

var getKey = function getKey(opts) {
  var key = '';

  key += tf(opts.incudeNodes);
  key += tf(opts.includeEdges);
  key += tf(opts.includeLabels);
  key += tf(opts.includeOverlays);

  return key;
};

var cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {
  var _p = ele._private;
  var bb = void 0;
  var headless = ele.cy().headless();
  var key = opts === defBbOpts ? defBbOptsKey : getKey(opts);

  if (!opts.useCache || headless || !_p.bbCache || !_p.bbCache[key]) {
    bb = boundingBoxImpl(ele, opts);

    if (!headless) {
      _p.bbCache = _p.bbCache || {};
      _p.bbCache[key] = bb;
    }
  } else {
    bb = _p.bbCache[key];
  }

  return bb;
};

var defBbOpts = {
  includeNodes: true,
  includeEdges: true,
  includeLabels: true,
  includeOverlays: true,
  useCache: true
};

var defBbOptsKey = getKey(defBbOpts);

function filledBbOpts(options) {
  return {
    includeNodes: util.default(options.includeNodes, defBbOpts.includeNodes),
    includeEdges: util.default(options.includeEdges, defBbOpts.includeEdges),
    includeLabels: util.default(options.includeLabels, defBbOpts.includeLabels),
    includeOverlays: util.default(options.includeOverlays, defBbOpts.includeOverlays),
    useCache: util.default(options.useCache, defBbOpts.useCache)
  };
}

elesfn.boundingBox = function (options) {
  // the main usecase is ele.boundingBox() for a single element with no/def options
  // specified s.t. the cache is used, so check for this case to make it faster by
  // avoiding the overhead of the rest of the function
  if (this.length === 1 && this[0]._private.bbCache && (options === undefined || options.useCache === undefined || options.useCache === true)) {
    if (options === undefined) {
      options = defBbOpts;
    } else {
      options = filledBbOpts(options);
    }

    return cachedBoundingBoxImpl(this[0], options);
  }

  var bounds = {
    x1: Infinity,
    y1: Infinity,
    x2: -Infinity,
    y2: -Infinity
  };

  options = options || util.staticEmptyObject();

  var opts = filledBbOpts(options);

  var eles = this;
  var cy = eles.cy();
  var styleEnabled = cy.styleEnabled();

  if (styleEnabled) {
    this.recalculateRenderedStyle(opts.useCache);
  }

  this.updateCompoundBounds();

  var updatedEdge = {}; // use to avoid duplicated edge updates

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (styleEnabled && ele.isEdge() && ele.pstyle('curve-style').strValue === 'bezier' && !updatedEdge[ele.id()]) {
      var edges = ele.parallelEdges();

      for (var j = 0; j < edges.length; j++) {
        // make all as updated
        updatedEdge[edges[j].id()] = true;
      }

      edges.recalculateRenderedStyle(opts.useCache); // n.b. ele.parallelEdges() single is cached
    }

    updateBoundsFromBox(bounds, cachedBoundingBoxImpl(ele, opts));
  }

  bounds.x1 = noninf(bounds.x1);
  bounds.y1 = noninf(bounds.y1);
  bounds.x2 = noninf(bounds.x2);
  bounds.y2 = noninf(bounds.y2);
  bounds.w = noninf(bounds.x2 - bounds.x1);
  bounds.h = noninf(bounds.y2 - bounds.y1);

  return bounds;
};

// private helper to get bounding box for custom node positions
// - good for perf in certain cases but currently requires dirtying the rendered style
// - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...
// - try to use for only things like discrete layouts where the node position would change anyway
elesfn.boundingBoxAt = function (fn) {
  var nodes = this.nodes();

  if (is.plainObject(fn)) {
    var obj = fn;

    fn = function fn() {
      return obj;
    };
  }

  // save the current position and set the new one, per node
  for (var i = 0; i < nodes.length; i++) {
    var n = nodes[i];
    var _p = n._private;
    var pos = _p.position;
    var newPos = fn.call(n, n, i);

    _p.bbAtOldPos = { x: pos.x, y: pos.y };

    if (newPos) {
      pos.x = newPos.x;
      pos.y = newPos.y;
    }
  }

  this.emit('dirty'); // let the renderer know we've manually dirtied rendered dim calcs

  nodes.dirtyCompoundBoundsCache().updateCompoundBounds();

  var bb = this.boundingBox({ useCache: false });

  // restore the original position, per node
  for (var _i = 0; _i < nodes.length; _i++) {
    var _n = nodes[_i];
    var _p2 = _n._private;
    var _pos = _n._private.position;
    var old = _p2.bbAtOldPos;

    _pos.x = old.x;
    _pos.y = old.y;
  }

  nodes.dirtyCompoundBoundsCache();

  this.emit('dirty'); // let the renderer know we've manually dirtied rendered dim calcs

  return bb;
};

fn.boundingbox = fn.boundingBox;
fn.renderedBoundingbox = fn.renderedBoundingBox;

module.exports = elesfn;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ifEdge = function ifEdge(self, then) {
  if (self.isEdge()) {
    return then(self.renderer());
  }
};

module.exports = {
  controlPoints: function controlPoints() {
    var _this = this;

    return ifEdge(this, function (renderer) {
      return renderer.getControlPoints(_this);
    });
  },
  segmentPoints: function segmentPoints() {
    var _this2 = this;

    return ifEdge(this, function (renderer) {
      return renderer.getSegmentPoints(_this2);
    });
  },
  sourceEndpoint: function sourceEndpoint() {
    var _this3 = this;

    return ifEdge(this, function (renderer) {
      return renderer.getSourceEndpoint(_this3);
    });
  },
  targetEndpoint: function targetEndpoint() {
    var _this4 = this;

    return ifEdge(this, function (renderer) {
      return renderer.getTargetEndpoint(_this4);
    });
  },
  midpoint: function midpoint() {
    var _this5 = this;

    return ifEdge(this, function (renderer) {
      return renderer.getEdgeMidpoint(_this5);
    });
  }
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var position = __webpack_require__(46);
var bounds = __webpack_require__(43);
var widthHeight = __webpack_require__(47);
var edgePoints = __webpack_require__(44);

module.exports = util.assign({}, position, bounds, widthHeight, edgePoints);

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(3);
var is = __webpack_require__(0);
var math = __webpack_require__(2);
var fn = void 0,
    elesfn = void 0;

var beforePositionSet = function beforePositionSet(eles, newPos) {
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (ele.isParent() && !ele.locked()) {
      var oldPos = ele._private.position;
      var delta = {
        x: newPos.x - oldPos.x,
        y: newPos.y - oldPos.y
      };

      eles.children().shift(delta);
    }
  }
};

fn = elesfn = {

  position: define.data({
    field: 'position',
    bindingEvent: 'position',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'position',
    settingTriggersEvent: true,
    triggerFnName: 'emitAndNotify',
    allowGetting: true,
    validKeys: ['x', 'y'],
    beforeGet: function beforeGet(ele) {
      ele.updateCompoundBounds();
    },
    beforeSet: beforePositionSet,
    onSet: function onSet(eles) {
      eles.dirtyCompoundBoundsCache();
    },
    canSet: function canSet(ele) {
      return !ele.locked();
    }
  }),

  // position but no notification to renderer
  silentPosition: define.data({
    field: 'position',
    bindingEvent: 'position',
    allowBinding: false,
    allowSetting: true,
    settingEvent: 'position',
    settingTriggersEvent: false,
    triggerFnName: 'trigger',
    allowGetting: false,
    validKeys: ['x', 'y'],
    beforeSet: beforePositionSet,
    onSet: function onSet(eles) {
      eles.dirtyCompoundBoundsCache();
    },
    canSet: function canSet(ele) {
      return !ele.locked();
    }
  }),

  positions: function positions(pos, silent) {
    if (is.plainObject(pos)) {
      if (silent) {
        this.silentPosition(pos);
      } else {
        this.position(pos);
      }
    } else if (is.fn(pos)) {
      var _fn = pos;
      var cy = this.cy();

      cy.startBatch();

      for (var i = 0; i < this.length; i++) {
        var ele = this[i];
        var _pos = void 0;

        if (_pos = _fn(ele, i)) {
          if (silent) {
            ele.silentPosition(_pos);
          } else {
            ele.position(_pos);
          }
        }
      }

      cy.endBatch();
    }

    return this; // chaining
  },

  silentPositions: function silentPositions(pos) {
    return this.positions(pos, true);
  },

  shift: function shift(dim, val) {
    var delta = void 0;

    if (is.plainObject(dim)) {
      delta = dim;
    } else if (is.string(dim) && is.number(val)) {
      delta = { x: 0, y: 0 };

      delta[dim] = val;
    }

    if (delta != null) {
      for (var i = 0; i < this.length; i++) {
        var ele = this[i];
        var pos = ele.position();

        ele.position({
          x: pos.x + delta.x,
          y: pos.y + delta.y
        });
      }
    }

    return this;
  },

  // get/set the rendered (i.e. on screen) positon of the element
  renderedPosition: function renderedPosition(dim, val) {
    var ele = this[0];
    var cy = this.cy();
    var zoom = cy.zoom();
    var pan = cy.pan();
    var rpos = is.plainObject(dim) ? dim : undefined;
    var setting = rpos !== undefined || val !== undefined && is.string(dim);

    if (ele && ele.isNode()) {
      // must have an element and must be a node to return position
      if (setting) {
        for (var i = 0; i < this.length; i++) {
          var _ele = this[i];

          if (val !== undefined) {
            // set one dimension
            _ele.position(dim, (val - pan[dim]) / zoom);
          } else if (rpos !== undefined) {
            // set whole position
            _ele.position(math.renderedToModelPosition(rpos, zoom, pan));
          }
        }
      } else {
        // getting
        var pos = ele.position();
        rpos = math.modelToRenderedPosition(pos, zoom, pan);

        if (dim === undefined) {
          // then return the whole rendered position
          return rpos;
        } else {
          // then return the specified dimension
          return rpos[dim];
        }
      }
    } else if (!setting) {
      return undefined; // for empty collection case
    }

    return this; // chaining
  },

  // get/set the position relative to the parent
  relativePosition: function relativePosition(dim, val) {
    var ele = this[0];
    var cy = this.cy();
    var ppos = is.plainObject(dim) ? dim : undefined;
    var setting = ppos !== undefined || val !== undefined && is.string(dim);
    var hasCompoundNodes = cy.hasCompoundNodes();

    if (ele && ele.isNode()) {
      // must have an element and must be a node to return position
      if (setting) {
        for (var i = 0; i < this.length; i++) {
          var _ele2 = this[i];
          var parent = hasCompoundNodes ? _ele2.parent() : null;
          var hasParent = parent && parent.length > 0;
          var relativeToParent = hasParent;

          if (hasParent) {
            parent = parent[0];
          }

          var origin = relativeToParent ? parent.position() : { x: 0, y: 0 };

          if (val !== undefined) {
            // set one dimension
            _ele2.position(dim, val + origin[dim]);
          } else if (ppos !== undefined) {
            // set whole position
            _ele2.position({
              x: ppos.x + origin.x,
              y: ppos.y + origin.y
            });
          }
        }
      } else {
        // getting
        var pos = ele.position();
        var _parent = hasCompoundNodes ? ele.parent() : null;
        var _hasParent = _parent && _parent.length > 0;
        var _relativeToParent = _hasParent;

        if (_hasParent) {
          _parent = _parent[0];
        }

        var _origin = _relativeToParent ? _parent.position() : { x: 0, y: 0 };

        ppos = {
          x: pos.x - _origin.x,
          y: pos.y - _origin.y
        };

        if (dim === undefined) {
          // then return the whole rendered position
          return ppos;
        } else {
          // then return the specified dimension
          return ppos[dim];
        }
      }
    } else if (!setting) {
      return undefined; // for empty collection case
    }

    return this; // chaining
  }
};

// aliases
fn.modelPosition = fn.point = fn.position;
fn.modelPositions = fn.points = fn.positions;
fn.renderedPoint = fn.renderedPosition;
fn.relativePoint = fn.relativePosition;

module.exports = elesfn;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var fn = void 0,
    elesfn = void 0;

fn = elesfn = {};

var defineDimFns = function defineDimFns(opts) {
  opts.uppercaseName = util.capitalize(opts.name);
  opts.autoName = 'auto' + opts.uppercaseName;
  opts.labelName = 'label' + opts.uppercaseName;
  opts.outerName = 'outer' + opts.uppercaseName;
  opts.uppercaseOuterName = util.capitalize(opts.outerName);

  fn[opts.name] = function dimImpl() {
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if (ele) {
      if (styleEnabled) {
        if (ele.isParent()) {
          ele.updateCompoundBounds();

          return _p[opts.autoName] || 0;
        }

        var d = ele.pstyle(opts.name);

        switch (d.strValue) {
          case 'label':
            ele.recalculateRenderedStyle();

            return _p.rstyle[opts.labelName] || 0;

          default:
            return d.pfValue;
        }
      } else {
        return 1;
      }
    }
  };

  fn['outer' + opts.uppercaseName] = function outerDimImpl() {
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if (ele) {
      if (styleEnabled) {
        var dim = ele[opts.name]();
        var border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side
        var padding = 2 * ele.padding();

        return dim + border + padding;
      } else {
        return 1;
      }
    }
  };

  fn['rendered' + opts.uppercaseName] = function renderedDimImpl() {
    var ele = this[0];

    if (ele) {
      var d = ele[opts.name]();
      return d * this.cy().zoom();
    }
  };

  fn['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {
    var ele = this[0];

    if (ele) {
      var od = ele[opts.outerName]();
      return od * this.cy().zoom();
    }
  };
};

defineDimFns({
  name: 'width'
});

defineDimFns({
  name: 'height'
});

elesfn.padding = function () {
  var ele = this[0];
  var _p = ele._private;
  if (ele.isParent()) {
    ele.updateCompoundBounds();

    if (_p.autoPadding !== undefined) {
      return _p.autoPadding;
    } else {
      return ele.pstyle('padding').pfValue;
    }
  } else {
    return ele.pstyle('padding').pfValue;
  }
};

module.exports = elesfn;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Emitter = __webpack_require__(10);
var define = __webpack_require__(3);
var is = __webpack_require__(0);
var util = __webpack_require__(1);
var Selector = __webpack_require__(6);

var emitterOptions = {
  qualifierCompare: function qualifierCompare(selector1, selector2) {
    if (selector1 == null || selector2 == null) {
      return selector1 == null && selector2 == null;
    } else {
      return selector1.sameText(selector2);
    }
  },
  eventMatches: function eventMatches(ele, listener, eventObj) {
    var selector = listener.qualifier;

    if (selector != null) {
      return ele !== eventObj.target && is.element(eventObj.target) && selector.matches(eventObj.target);
    }

    return true;
  },
  eventFields: function eventFields(ele) {
    return {
      cy: ele.cy(),
      target: ele
    };
  },
  callbackContext: function callbackContext(ele, listener, eventObj) {
    return listener.qualifier != null ? eventObj.target : ele;
  },
  beforeEmit: function beforeEmit(context, listener /*, eventObj*/) {
    if (listener.conf && listener.conf.once) {
      listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);
    }
  },
  bubble: function bubble() {
    return true;
  },
  parent: function parent(ele) {
    return ele.isChild() ? ele.parent() : ele.cy();
  }
};

var argSelector = function argSelector(arg) {
  if (is.string(arg)) {
    return new Selector(arg);
  } else {
    return arg;
  }
};

var elesfn = {
  createEmitter: function createEmitter() {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var _p = ele._private;

      if (!_p.emitter) {
        _p.emitter = new Emitter(util.assign({
          context: ele
        }, emitterOptions));
      }
    }

    return this;
  },

  emitter: function emitter() {
    return this._private.emitter;
  },

  on: function on(events, selector, callback) {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];

      ele.emitter().on(events, argSelector(selector), callback);
    }

    return this;
  },

  removeListener: function removeListener(events, selector, callback) {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];

      ele.emitter().removeListener(events, argSelector(selector), callback);
    }

    return this;
  },

  one: function one(events, selector, callback) {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];

      ele.emitter().one(events, argSelector(selector), callback);
    }

    return this;
  },

  once: function once(events, selector, callback) {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];

      ele.emitter().on(events, argSelector(selector), callback, {
        once: true,
        onceCollection: this
      });
    }
  },

  emit: function emit(events, extraParams) {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];

      ele.emitter().emit(events, extraParams);
    }

    return this;
  },

  emitAndNotify: function emitAndNotify(event, extraParams) {
    // for internal use only
    if (this.length === 0) {
      return;
    } // empty collections don't need to notify anything

    // notify renderer
    this.cy().notify({
      type: event,
      eles: this
    });

    this.emit(event, extraParams);

    return this;
  }
};

define.eventAliasesOn(elesfn);

module.exports = elesfn;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var Selector = __webpack_require__(6);

var elesfn = {
  nodes: function nodes(selector) {
    return this.filter(function (ele) {
      return ele.isNode();
    }).filter(selector);
  },

  edges: function edges(selector) {
    return this.filter(function (ele) {
      return ele.isEdge();
    }).filter(selector);
  },

  filter: function filter(_filter, thisArg) {
    if (_filter === undefined) {
      // check this first b/c it's the most common/performant case
      return this;
    } else if (is.string(_filter) || is.elementOrCollection(_filter)) {
      return new Selector(_filter).filter(this);
    } else if (is.fn(_filter)) {
      var filterEles = this.spawn();
      var eles = this;

      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);

        if (include) {
          filterEles.merge(ele);
        }
      }

      return filterEles;
    }

    return this.spawn(); // if not handled by above, give 'em an empty collection
  },

  not: function not(toRemove) {
    if (!toRemove) {
      return this;
    } else {

      if (is.string(toRemove)) {
        toRemove = this.filter(toRemove);
      }

      var elements = [];
      var rMap = toRemove._private.map;

      for (var i = 0; i < this.length; i++) {
        var element = this[i];

        var remove = rMap.has(element.id());
        if (!remove) {
          elements.push(element);
        }
      }

      return this.spawn(elements);
    }
  },

  absoluteComplement: function absoluteComplement() {
    var cy = this.cy();

    return cy.mutableElements().not(this);
  },

  intersect: function intersect(other) {
    // if a selector is specified, then filter by it instead
    if (is.string(other)) {
      var selector = other;
      return this.filter(selector);
    }

    var elements = [];
    var col1 = this;
    var col2 = other;
    var col1Smaller = this.length < other.length;
    var map2 = col1Smaller ? col2._private.map : col1._private.map;
    var col = col1Smaller ? col1 : col2;

    for (var i = 0; i < col.length; i++) {
      var id = col[i]._private.data.id;
      var entry = map2.get(id);

      if (entry) {
        elements.push(entry.ele);
      }
    }

    return this.spawn(elements);
  },

  xor: function xor(other) {
    var cy = this._private.cy;

    if (is.string(other)) {
      other = cy.$(other);
    }

    var elements = [];
    var col1 = this;
    var col2 = other;

    var add = function add(col, other) {
      for (var i = 0; i < col.length; i++) {
        var ele = col[i];
        var id = ele._private.data.id;
        var inOther = other.hasElementWithId(id);

        if (!inOther) {
          elements.push(ele);
        }
      }
    };

    add(col1, col2);
    add(col2, col1);

    return this.spawn(elements);
  },

  diff: function diff(other) {
    var cy = this._private.cy;

    if (is.string(other)) {
      other = cy.$(other);
    }

    var left = [];
    var right = [];
    var both = [];
    var col1 = this;
    var col2 = other;

    var add = function add(col, other, retEles) {

      for (var i = 0; i < col.length; i++) {
        var ele = col[i];
        var id = ele._private.data.id;
        var inOther = other.hasElementWithId(id);

        if (inOther) {
          both.push(ele);
        } else {
          retEles.push(ele);
        }
      }
    };

    add(col1, col2, left);
    add(col2, col1, right);

    return {
      left: this.spawn(left, { unique: true }),
      right: this.spawn(right, { unique: true }),
      both: this.spawn(both, { unique: true })
    };
  },

  add: function add(toAdd) {
    var cy = this._private.cy;

    if (!toAdd) {
      return this;
    }

    if (is.string(toAdd)) {
      var selector = toAdd;
      toAdd = cy.mutableElements().filter(selector);
    }

    var elements = [];

    for (var i = 0; i < this.length; i++) {
      elements.push(this[i]);
    }

    var map = this._private.map;

    for (var _i = 0; _i < toAdd.length; _i++) {

      var add = !map.has(toAdd[_i].id());
      if (add) {
        elements.push(toAdd[_i]);
      }
    }

    return this.spawn(elements);
  },

  // in place merge on calling collection
  merge: function merge(toAdd) {
    var _p = this._private;
    var cy = _p.cy;

    if (!toAdd) {
      return this;
    }

    if (toAdd && is.string(toAdd)) {
      var selector = toAdd;
      toAdd = cy.mutableElements().filter(selector);
    }

    var map = _p.map;

    for (var i = 0; i < toAdd.length; i++) {
      var toAddEle = toAdd[i];
      var id = toAddEle._private.data.id;
      var add = !map.has(id);

      if (add) {
        var index = this.length++;

        this[index] = toAddEle;

        map.set(id, { ele: toAddEle, index: index });
      } else {
        // replace
        var _index = map.get(id).index;

        this[_index] = toAddEle;
        map.set(id, { ele: toAddEle, index: _index });
      }
    }

    return this; // chaining
  },

  // remove single ele in place in calling collection
  unmergeOne: function unmergeOne(ele) {
    ele = ele[0];

    var _p = this._private;
    var id = ele._private.data.id;
    var map = _p.map;
    var entry = map.get(id);

    if (!entry) {
      return this; // no need to remove
    }

    var i = entry.index;

    // remove ele
    this[i] = undefined;
    map.delete(id);

    var unmergedLastEle = i === this.length - 1;

    // replace empty spot with last ele in collection
    if (this.length > 1 && !unmergedLastEle) {
      var lastEleI = this.length - 1;
      var lastEle = this[lastEleI];
      var lastEleId = lastEle._private.data.id;

      this[lastEleI] = undefined;
      this[i] = lastEle;
      map.set(lastEleId, { ele: lastEle, index: i });
    }

    // the collection is now 1 ele smaller
    this.length--;

    return this;
  },

  // remove eles in place on calling collection
  unmerge: function unmerge(toRemove) {
    var cy = this._private.cy;

    if (!toRemove) {
      return this;
    }

    if (toRemove && is.string(toRemove)) {
      var selector = toRemove;
      toRemove = cy.mutableElements().filter(selector);
    }

    for (var i = 0; i < toRemove.length; i++) {
      this.unmergeOne(toRemove[i]);
    }

    return this; // chaining
  },

  map: function map(mapFn, thisArg) {
    var arr = [];
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);

      arr.push(ret);
    }

    return arr;
  },

  reduce: function reduce(fn, initialValue) {
    var val = initialValue;
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      val = fn(val, eles[i], i, eles);
    }

    return val;
  },

  max: function max(valFn, thisArg) {
    var max = -Infinity;
    var maxEle = void 0;
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);

      if (val > max) {
        max = val;
        maxEle = ele;
      }
    }

    return {
      value: max,
      ele: maxEle
    };
  },

  min: function min(valFn, thisArg) {
    var min = Infinity;
    var minEle = void 0;
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);

      if (val < min) {
        min = val;
        minEle = ele;
      }
    }

    return {
      value: min,
      ele: minEle
    };
  }
};

// aliases
var fn = elesfn;
fn['u'] = fn['|'] = fn['+'] = fn.union = fn.or = fn.add;
fn['\\'] = fn['!'] = fn['-'] = fn.difference = fn.relativeComplement = fn.subtract = fn.not;
fn['n'] = fn['&'] = fn['.'] = fn.and = fn.intersection = fn.intersect;
fn['^'] = fn['(+)'] = fn['(-)'] = fn.symmetricDifference = fn.symdiff = fn.xor;
fn.fnFilter = fn.filterFn = fn.stdFilter = fn.filter;
fn.complement = fn.abscomp = fn.absoluteComplement;

module.exports = elesfn;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elesfn = {
  isNode: function isNode() {
    return this.group() === 'nodes';
  },

  isEdge: function isEdge() {
    return this.group() === 'edges';
  },

  isLoop: function isLoop() {
    return this.isEdge() && this.source().id() === this.target().id();
  },

  isSimple: function isSimple() {
    return this.isEdge() && this.source().id() !== this.target().id();
  },

  group: function group() {
    var ele = this[0];

    if (ele) {
      return ele._private.group;
    }
  }
};

module.exports = elesfn;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var zIndexSort = __webpack_require__(14);
var util = __webpack_require__(1);

var elesfn = {
  forEach: function forEach(fn, thisArg) {
    if (is.fn(fn)) {

      for (var i = 0; i < this.length; i++) {
        var ele = this[i];
        var ret = thisArg ? fn.apply(thisArg, [ele, i, this]) : fn(ele, i, this);

        if (ret === false) {
          break;
        } // exit each early on return false
      }
    }

    return this;
  },

  toArray: function toArray() {
    var array = [];

    for (var i = 0; i < this.length; i++) {
      array.push(this[i]);
    }

    return array;
  },

  slice: function slice(start, end) {
    var array = [];
    var thisSize = this.length;

    if (end == null) {
      end = thisSize;
    }

    if (start == null) {
      start = 0;
    }

    if (start < 0) {
      start = thisSize + start;
    }

    if (end < 0) {
      end = thisSize + end;
    }

    for (var i = start; i >= 0 && i < end && i < thisSize; i++) {
      array.push(this[i]);
    }

    return this.spawn(array);
  },

  size: function size() {
    return this.length;
  },

  eq: function eq(i) {
    return this[i] || this.spawn();
  },

  first: function first() {
    return this[0] || this.spawn();
  },

  last: function last() {
    return this[this.length - 1] || this.spawn();
  },

  empty: function empty() {
    return this.length === 0;
  },

  nonempty: function nonempty() {
    return !this.empty();
  },

  sort: function sort(sortFn) {
    if (!is.fn(sortFn)) {
      return this;
    }

    var sorted = this.toArray().sort(sortFn);

    return this.spawn(sorted);
  },

  sortByZIndex: function sortByZIndex() {
    return this.sort(zIndexSort);
  },

  zDepth: function zDepth() {
    var ele = this[0];
    if (!ele) {
      return undefined;
    }

    // let cy = ele.cy();
    var _p = ele._private;
    var group = _p.group;

    if (group === 'nodes') {
      var depth = _p.data.parent ? ele.parents().size() : 0;

      if (!ele.isParent()) {
        return util.MAX_INT - 1; // childless nodes always on top
      }

      return depth;
    } else {
      var src = _p.source;
      var tgt = _p.target;
      var srcDepth = src.zDepth();
      var tgtDepth = tgt.zDepth();

      return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent
    }
  }
};

elesfn.each = elesfn.forEach;

module.exports = elesfn;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);
var Promise = __webpack_require__(5);
var math = __webpack_require__(2);

var elesfn = {
  // Calculates and returns node dimensions { x, y } based on options given
  layoutDimensions: function layoutDimensions(options) {
    options = util.assign({
      nodeDimensionsIncludeLabels: true
    }, options);

    if (options.nodeDimensionsIncludeLabels) {
      var bbDim = this.boundingBox();
      return {
        w: bbDim.w,
        h: bbDim.h
      };
    } else {
      return {
        w: this.outerWidth(),
        h: this.outerHeight()
      };
    }
  },

  // using standard layout options, apply position function (w/ or w/o animation)
  layoutPositions: function layoutPositions(layout, options, fn) {
    var nodes = this.nodes();
    var cy = this.cy();
    var layoutEles = options.eles; // nodes & edges
    var getMemoizeKey = function getMemoizeKey(node, i) {
      return node.id() + '$' + i;
    };
    var fnMem = util.memoize(fn, getMemoizeKey); // memoized version of position function

    layout.emit({ type: 'layoutstart', layout: layout });

    layout.animations = [];

    var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {
      var center = {
        x: nodesBb.x1 + nodesBb.w / 2,
        y: nodesBb.y1 + nodesBb.h / 2
      };

      var spacingVector = { // scale from center of bounding box (not necessarily 0,0)
        x: (pos.x - center.x) * spacing,
        y: (pos.y - center.y) * spacing
      };

      return {
        x: center.x + spacingVector.x,
        y: center.y + spacingVector.y
      };
    };

    var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;

    var spacingBb = function spacingBb() {
      if (!useSpacingFactor) {
        return null;
      }

      var bb = math.makeBoundingBox();

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var pos = fnMem(node, i);

        math.expandBoundingBoxByPoint(bb, pos.x, pos.y);
      }

      return bb;
    };

    var bb = spacingBb();

    var getFinalPos = util.memoize(function (node, i) {
      var newPos = fnMem(node, i);
      var pos = node.position();

      if (!is.number(pos.x) || !is.number(pos.y)) {
        node.silentPosition({ x: 0, y: 0 });
      }

      if (useSpacingFactor) {
        var spacing = Math.abs(options.spacingFactor);

        newPos = calculateSpacing(spacing, bb, newPos);
      }

      if (options.transform != null) {
        newPos = options.transform(node, newPos);
      }

      return newPos;
    }, getMemoizeKey);

    if (options.animate) {
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var newPos = getFinalPos(node, i);
        var animateNode = options.animateFilter == null || options.animateFilter(node, i);

        if (animateNode) {
          var ani = node.animation({
            position: newPos,
            duration: options.animationDuration,
            easing: options.animationEasing
          });

          layout.animations.push(ani);

          ani.play();
        } else {
          node.position(newPos);
        }
      }

      if (options.fit) {
        var fitAni = cy.animation({
          fit: {
            boundingBox: layoutEles.boundingBoxAt(getFinalPos),
            padding: options.padding
          },
          duration: options.animationDuration,
          easing: options.animationEasing
        });

        layout.animations.push(fitAni);

        fitAni.play();
      } else if (options.zoom !== undefined && options.pan !== undefined) {
        var zoomPanAni = cy.animation({
          zoom: options.zoom,
          pan: options.pan,
          duration: options.animationDuration,
          easing: options.animationEasing
        });

        layout.animations.push(zoomPanAni);

        zoomPanAni.play();
      }

      layout.one('layoutready', options.ready);
      layout.emit({ type: 'layoutready', layout: layout });

      Promise.all(layout.animations.map(function (ani) {
        return ani.promise();
      })).then(function () {
        layout.one('layoutstop', options.stop);
        layout.emit({ type: 'layoutstop', layout: layout });
      });
    } else {

      nodes.positions(getFinalPos);

      if (options.fit) {
        cy.fit(options.eles, options.padding);
      }

      if (options.zoom != null) {
        cy.zoom(options.zoom);
      }

      if (options.pan) {
        cy.pan(options.pan);
      }

      layout.one('layoutready', options.ready);
      layout.emit({ type: 'layoutready', layout: layout });

      layout.one('layoutstop', options.stop);
      layout.emit({ type: 'layoutstop', layout: layout });
    }

    return this; // chaining
  },

  layout: function layout(options) {
    var cy = this.cy();

    return cy.makeLayout(util.extend({}, options, {
      eles: this
    }));
  }

};

// aliases:
elesfn.createLayout = elesfn.makeLayout = elesfn.layout;

module.exports = elesfn;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

function styleCache(key, fn, ele) {
  var _p = ele._private;
  var cache = _p.styleCache = _p.styleCache || {};
  var val;

  if ((val = cache[key]) != null) {
    return val;
  } else {
    val = cache[key] = fn(ele);

    return val;
  }
}

function cacheStyleFunction(key, fn) {
  return function cachedStyleFunction(ele) {
    return styleCache(key, fn, ele);
  };
}

function cachePrototypeStyleFunction(key, fn) {
  var selfFn = function selfFn(ele) {
    return fn.call(ele);
  };

  return function cachedPrototypeStyleFunction() {
    var ele = this[0];

    if (ele) {
      return styleCache(key, selfFn, ele);
    }
  };
}

var elesfn = {

  recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {
    var cy = this.cy();
    var renderer = cy.renderer();
    var styleEnabled = cy.styleEnabled();

    if (renderer && styleEnabled) {
      renderer.recalculateRenderedStyle(this, useCache);
    }

    return this;
  },

  dirtyStyleCache: function dirtyStyleCache() {
    var cy = this.cy();
    var dirty = function dirty(ele) {
      return ele._private.styleCache = {};
    };

    if (cy.hasCompoundNodes()) {
      var eles = void 0;

      eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());

      eles.merge(eles.connectedEdges());

      eles.forEach(dirty);
    } else {
      this.forEach(function (ele) {
        dirty(ele);

        ele.connectedEdges().forEach(dirty);
      });
    }

    return this;
  },

  // fully updates (recalculates) the style for the elements
  updateStyle: function updateStyle(notifyRenderer) {
    var cy = this._private.cy;

    if (!cy.styleEnabled()) {
      return this;
    }

    if (cy._private.batchingStyle) {
      var bEles = cy._private.batchStyleEles;

      bEles.merge(this);

      return this; // chaining and exit early when batching
    }

    var hasCompounds = cy.hasCompoundNodes();
    var style = cy.style();
    var updatedEles = this;

    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    if (hasCompounds) {
      // then add everything up and down for compound selector checks
      updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
    }

    var changedEles = style.apply(updatedEles);

    changedEles.dirtyStyleCache();
    changedEles.dirtyCompoundBoundsCache();

    if (notifyRenderer) {
      changedEles.emitAndNotify('style'); // let renderer know we changed style
    } else {
      changedEles.emit('style'); // just fire the event
    }

    return this; // chaining
  },

  // just update the mappers in the elements' styles; cheaper than eles.updateStyle()
  updateMappers: function updateMappers(notifyRenderer) {
    var cy = this._private.cy;
    var style = cy.style();
    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    if (!cy.styleEnabled()) {
      return this;
    }

    var changedEles = style.updateMappers(this);

    changedEles.dirtyStyleCache();
    changedEles.dirtyCompoundBoundsCache();

    if (notifyRenderer) {
      changedEles.emitAndNotify('style'); // let renderer know we changed style
    } else {
      changedEles.emit('style'); // just fire the event
    }
    return this; // chaining
  },

  // get the internal parsed style object for the specified property
  parsedStyle: function parsedStyle(property) {
    var ele = this[0];
    var cy = ele.cy();

    if (!cy.styleEnabled()) {
      return;
    }

    if (ele) {
      return ele._private.style[property] || cy.style().getDefaultProperty(property);
    }
  },

  numericStyle: function numericStyle(property) {
    var ele = this[0];

    if (!ele.cy().styleEnabled()) {
      return;
    }

    if (ele) {
      var pstyle = ele.pstyle(property);

      return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;
    }
  },

  numericStyleUnits: function numericStyleUnits(property) {
    var ele = this[0];

    if (!ele.cy().styleEnabled()) {
      return;
    }

    if (ele) {
      return ele.pstyle(property).units;
    }
  },

  // get the specified css property as a rendered value (i.e. on-screen value)
  // or get the whole rendered style if no property specified (NB doesn't allow setting)
  renderedStyle: function renderedStyle(property) {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return this;
    }

    var ele = this[0];

    if (ele) {
      return cy.style().getRenderedStyle(ele, property);
    }
  },

  // read the calculated css style of the element or override the style (via a bypass)
  style: function style(name, value) {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return this;
    }

    var updateTransitions = false;
    var style = cy.style();

    if (is.plainObject(name)) {
      // then extend the bypass
      var props = name;
      style.applyBypass(this, props, updateTransitions);

      this.dirtyStyleCache();
      this.dirtyCompoundBoundsCache();

      this.emitAndNotify('style'); // let the renderer know we've updated style
    } else if (is.string(name)) {

      if (value === undefined) {
        // then get the property from the style
        var ele = this[0];

        if (ele) {
          return style.getStylePropertyValue(ele, name);
        } else {
          // empty collection => can't get any value
          return;
        }
      } else {
        // then set the bypass with the property value
        style.applyBypass(this, name, value, updateTransitions);

        this.dirtyStyleCache();
        this.dirtyCompoundBoundsCache();

        this.emitAndNotify('style'); // let the renderer know we've updated style
      }
    } else if (name === undefined) {
      var _ele = this[0];

      if (_ele) {
        return style.getRawStyle(_ele);
      } else {
        // empty collection => can't get any value
        return;
      }
    }

    return this; // chaining
  },

  removeStyle: function removeStyle(names) {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return this;
    }

    var updateTransitions = false;
    var style = cy.style();
    var eles = this;

    if (names === undefined) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];

        style.removeAllBypasses(ele, updateTransitions);
      }
    } else {
      names = names.split(/\s+/);

      for (var _i = 0; _i < eles.length; _i++) {
        var _ele2 = eles[_i];

        style.removeBypasses(_ele2, names, updateTransitions);
      }
    }

    this.dirtyStyleCache();
    this.dirtyCompoundBoundsCache();

    this.emitAndNotify('style'); // let the renderer know we've updated style

    return this; // chaining
  },

  show: function show() {
    this.css('display', 'element');
    return this; // chaining
  },

  hide: function hide() {
    this.css('display', 'none');
    return this; // chaining
  },

  effectiveOpacity: function effectiveOpacity() {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return 1;
    }

    var hasCompoundNodes = cy.hasCompoundNodes();
    var ele = this[0];

    if (ele) {
      var _p = ele._private;
      var parentOpacity = ele.pstyle('opacity').value;

      if (!hasCompoundNodes) {
        return parentOpacity;
      }

      var parents = !_p.data.parent ? null : ele.parents();

      if (parents) {
        for (var i = 0; i < parents.length; i++) {
          var parent = parents[i];
          var opacity = parent.pstyle('opacity').value;

          parentOpacity = opacity * parentOpacity;
        }
      }

      return parentOpacity;
    }
  },

  transparent: function transparent() {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return false;
    }

    var ele = this[0];
    var hasCompoundNodes = ele.cy().hasCompoundNodes();

    if (ele) {
      if (!hasCompoundNodes) {
        return ele.pstyle('opacity').value === 0;
      } else {
        return ele.effectiveOpacity() === 0;
      }
    }
  },

  backgrounding: function backgrounding() {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return false;
    }

    var ele = this[0];

    return ele._private.backgrounding ? true : false;
  }

};

function checkCompound(ele, parentOk) {
  var _p = ele._private;
  var parents = _p.data.parent ? ele.parents() : null;

  if (parents) {
    for (var i = 0; i < parents.length; i++) {
      var parent = parents[i];

      if (!parentOk(parent)) {
        return false;
      }
    }
  }

  return true;
}

function defineDerivedStateFunction(specs) {
  var ok = specs.ok;
  var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;
  var parentOk = specs.parentOk || specs.ok;

  return function () {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return true;
    }

    var ele = this[0];
    var hasCompoundNodes = cy.hasCompoundNodes();

    if (ele) {
      var _p = ele._private;

      if (!ok(ele)) {
        return false;
      }

      if (ele.isNode()) {
        return !hasCompoundNodes || checkCompound(ele, parentOk);
      } else {
        var src = _p.source;
        var tgt = _p.target;

        return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));
      }
    }
  };
}

var eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {
  return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);
});

elesfn.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({
  ok: eleTakesUpSpace
}));

var eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {
  return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);
});

var parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {
  return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);
});

elesfn.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({
  ok: eleInteractive,
  parentOk: parentInteractive,
  edgeOkViaNode: eleTakesUpSpace
}));

elesfn.noninteractive = function () {
  var ele = this[0];

  if (ele) {
    return !ele.interactive();
  }
};

var eleVisible = cacheStyleFunction('eleVisible', function (ele) {
  return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);
});

var edgeVisibleViaNode = eleTakesUpSpace;

elesfn.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({
  ok: eleVisible,
  edgeOkViaNode: edgeVisibleViaNode
}));

elesfn.hidden = function () {
  var ele = this[0];

  if (ele) {
    return !ele.visible();
  }
};

elesfn.bypass = elesfn.css = elesfn.style;
elesfn.renderedCss = elesfn.renderedStyle;
elesfn.removeBypass = elesfn.removeCss = elesfn.removeStyle;
elesfn.pstyle = elesfn.parsedStyle;

module.exports = elesfn;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elesfn = {};

function defineSwitchFunction(params) {
  return function () {
    var args = arguments;
    var changedEles = [];

    // e.g. cy.nodes().select( data, handler )
    if (args.length === 2) {
      var data = args[0];
      var handler = args[1];
      this.on(params.event, data, handler);
    }

    // e.g. cy.nodes().select( handler )
    else if (args.length === 1) {
        var _handler = args[0];
        this.on(params.event, _handler);
      }

      // e.g. cy.nodes().select()
      else if (args.length === 0) {
          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
            var able = !params.ableField || ele._private[params.ableField];
            var changed = ele._private[params.field] != params.value;

            if (params.overrideAble) {
              var overrideAble = params.overrideAble(ele);

              if (overrideAble !== undefined) {
                able = overrideAble;

                if (!overrideAble) {
                  return this;
                } // to save cycles assume not able for all on override
              }
            }

            if (able) {
              ele._private[params.field] = params.value;

              if (changed) {
                changedEles.push(ele);
              }
            }
          }

          var changedColl = this.spawn(changedEles);
          changedColl.updateStyle(); // change of state => possible change of style
          changedColl.emit(params.event);
        }

    return this;
  };
}

function defineSwitchSet(params) {
  elesfn[params.field] = function () {
    var ele = this[0];

    if (ele) {
      if (params.overrideField) {
        var val = params.overrideField(ele);

        if (val !== undefined) {
          return val;
        }
      }

      return ele._private[params.field];
    }
  };

  elesfn[params.on] = defineSwitchFunction({
    event: params.on,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: true
  });

  elesfn[params.off] = defineSwitchFunction({
    event: params.off,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: false
  });
}

defineSwitchSet({
  field: 'locked',
  overrideField: function overrideField(ele) {
    return ele.cy().autolock() ? true : undefined;
  },
  on: 'lock',
  off: 'unlock'
});

defineSwitchSet({
  field: 'grabbable',
  overrideField: function overrideField(ele) {
    return ele.cy().autoungrabify() ? false : undefined;
  },
  on: 'grabify',
  off: 'ungrabify'
});

defineSwitchSet({
  field: 'selected',
  ableField: 'selectable',
  overrideAble: function overrideAble(ele) {
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'select',
  off: 'unselect'
});

defineSwitchSet({
  field: 'selectable',
  overrideField: function overrideField(ele) {
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'selectify',
  off: 'unselectify'
});

elesfn.deselect = elesfn.unselect;

elesfn.grabbed = function () {
  var ele = this[0];
  if (ele) {
    return ele._private.grabbed;
  }
};

defineSwitchSet({
  field: 'active',
  on: 'activate',
  off: 'unactivate'
});

elesfn.inactive = function () {
  var ele = this[0];
  if (ele) {
    return !ele._private.active;
  }
};

module.exports = elesfn;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);

var elesfn = {};

var cache = function cache(fn, name) {
  return function traversalCache(arg1, arg2, arg3, arg4) {
    var selectorOrEles = arg1;
    var eles = this;
    var key = void 0;

    if (selectorOrEles == null) {
      key = 'null';
    } else if (is.elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {
      key = '#' + selectorOrEles.id();
    }

    if (eles.length === 1 && key) {
      var _p = eles[0]._private;
      var tch = _p.traversalCache = _p.traversalCache || {};
      var ch = tch[name] = tch[name] || {};
      var cacheHit = ch[key];

      if (cacheHit) {
        return cacheHit;
      } else {
        return ch[key] = fn.call(eles, arg1, arg2, arg3, arg4);
      }
    } else {
      return fn.call(eles, arg1, arg2, arg3, arg4);
    }
  };
};

// DAG functions
////////////////

var defineDagExtremity = function defineDagExtremity(params) {
  return function dagExtremityImpl(selector) {
    var eles = this;
    var ret = [];

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      if (!ele.isNode()) {
        continue;
      }

      var disqualified = false;
      var edges = ele.connectedEdges();

      for (var j = 0; j < edges.length; j++) {
        var edge = edges[j];
        var src = edge.source();
        var tgt = edge.target();

        if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {
          disqualified = true;
          break;
        }
      }

      if (!disqualified) {
        ret.push(ele);
      }
    }

    return this.spawn(ret, { unique: true }).filter(selector);
  };
};

var defineDagOneHop = function defineDagOneHop(params) {
  return function (selector) {
    var eles = this;
    var oEles = [];

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];

      if (!ele.isNode()) {
        continue;
      }

      var edges = ele.connectedEdges();
      for (var j = 0; j < edges.length; j++) {
        var edge = edges[j];
        var src = edge.source();
        var tgt = edge.target();

        if (params.outgoing && src === ele) {
          oEles.push(edge);
          oEles.push(tgt);
        } else if (params.incoming && tgt === ele) {
          oEles.push(edge);
          oEles.push(src);
        }
      }
    }

    return this.spawn(oEles, { unique: true }).filter(selector);
  };
};

var defineDagAllHops = function defineDagAllHops(params) {
  return function (selector) {
    var eles = this;
    var sEles = [];
    var sElesIds = {};

    for (;;) {
      var next = params.outgoing ? eles.outgoers() : eles.incomers();

      if (next.length === 0) {
        break;
      } // done if none left

      var newNext = false;
      for (var i = 0; i < next.length; i++) {
        var n = next[i];
        var nid = n.id();

        if (!sElesIds[nid]) {
          sElesIds[nid] = true;
          sEles.push(n);
          newNext = true;
        }
      }

      if (!newNext) {
        break;
      } // done if touched all outgoers already

      eles = next;
    }

    return this.spawn(sEles, { unique: true }).filter(selector);
  };
};

elesfn.clearTraversalCache = function () {
  for (var i = 0; i < this.length; i++) {
    this[i]._private.traversalCache = null;
  }
};

util.extend(elesfn, {
  // get the root nodes in the DAG
  roots: defineDagExtremity({ noIncomingEdges: true }),

  // get the leaf nodes in the DAG
  leaves: defineDagExtremity({ noOutgoingEdges: true }),

  // normally called children in graph theory
  // these nodes =edges=> outgoing nodes
  outgoers: cache(defineDagOneHop({ outgoing: true }), 'outgoers'),

  // aka DAG descendants
  successors: defineDagAllHops({ outgoing: true }),

  // normally called parents in graph theory
  // these nodes <=edges= incoming nodes
  incomers: cache(defineDagOneHop({ incoming: true }), 'incomers'),

  // aka DAG ancestors
  predecessors: defineDagAllHops({ incoming: true })
});

// Neighbourhood functions
//////////////////////////

util.extend(elesfn, {
  neighborhood: cache(function (selector) {
    var elements = [];
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      // for all nodes
      var node = nodes[i];
      var connectedEdges = node.connectedEdges();

      // for each connected edge, add the edge and the other node
      for (var j = 0; j < connectedEdges.length; j++) {
        var edge = connectedEdges[j];
        var src = edge.source();
        var tgt = edge.target();
        var otherNode = node === src ? tgt : src;

        // need check in case of loop
        if (otherNode.length > 0) {
          elements.push(otherNode[0]); // add node 1 hop away
        }

        // add connected edge
        elements.push(edge[0]);
      }
    }

    return this.spawn(elements, { unique: true }).filter(selector);
  }, 'neighborhood'),

  closedNeighborhood: function closedNeighborhood(selector) {
    return this.neighborhood().add(this).filter(selector);
  },

  openNeighborhood: function openNeighborhood(selector) {
    return this.neighborhood(selector);
  }
});

// aliases
elesfn.neighbourhood = elesfn.neighborhood;
elesfn.closedNeighbourhood = elesfn.closedNeighborhood;
elesfn.openNeighbourhood = elesfn.openNeighborhood;

// Edge functions
/////////////////

util.extend(elesfn, {
  source: cache(function sourceImpl(selector) {
    var ele = this[0];
    var src = void 0;

    if (ele) {
      src = ele._private.source || ele.cy().collection();
    }

    return src && selector ? src.filter(selector) : src;
  }, 'source'),

  target: cache(function targetImpl(selector) {
    var ele = this[0];
    var tgt = void 0;

    if (ele) {
      tgt = ele._private.target || ele.cy().collection();
    }

    return tgt && selector ? tgt.filter(selector) : tgt;
  }, 'target'),

  sources: defineSourceFunction({
    attr: 'source'
  }),

  targets: defineSourceFunction({
    attr: 'target'
  })
});

function defineSourceFunction(params) {
  return function sourceImpl(selector) {
    var sources = [];

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var src = ele._private[params.attr];

      if (src) {
        sources.push(src);
      }
    }

    return this.spawn(sources, { unique: true }).filter(selector);
  };
}

util.extend(elesfn, {
  edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),

  edgesTo: cache(defineEdgesWithFunction({
    thisIsSrc: true
  }), 'edgesTo')
});

function defineEdgesWithFunction(params) {

  return function edgesWithImpl(otherNodes) {
    var elements = [];
    var cy = this._private.cy;
    var p = params || {};

    // get elements if a selector is specified
    if (is.string(otherNodes)) {
      otherNodes = cy.$(otherNodes);
    }

    for (var h = 0; h < otherNodes.length; h++) {
      var edges = otherNodes[h]._private.edges;

      for (var i = 0; i < edges.length; i++) {
        var edge = edges[i];
        var edgeData = edge._private.data;
        var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);
        var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);
        var edgeConnectsThisAndOther = thisToOther || otherToThis;

        if (!edgeConnectsThisAndOther) {
          continue;
        }

        if (p.thisIsSrc || p.thisIsTgt) {
          if (p.thisIsSrc && !thisToOther) {
            continue;
          }

          if (p.thisIsTgt && !otherToThis) {
            continue;
          }
        }

        elements.push(edge);
      }
    }

    return this.spawn(elements, { unique: true });
  };
}

util.extend(elesfn, {
  connectedEdges: cache(function (selector) {
    var retEles = [];

    var eles = this;
    for (var i = 0; i < eles.length; i++) {
      var node = eles[i];
      if (!node.isNode()) {
        continue;
      }

      var edges = node._private.edges;

      for (var j = 0; j < edges.length; j++) {
        var edge = edges[j];
        retEles.push(edge);
      }
    }

    return this.spawn(retEles, { unique: true }).filter(selector);
  }, 'connectedEdges'),

  connectedNodes: cache(function (selector) {
    var retEles = [];

    var eles = this;
    for (var i = 0; i < eles.length; i++) {
      var edge = eles[i];
      if (!edge.isEdge()) {
        continue;
      }

      retEles.push(edge.source()[0]);
      retEles.push(edge.target()[0]);
    }

    return this.spawn(retEles, { unique: true }).filter(selector);
  }, 'connectedNodes'),

  parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),

  codirectedEdges: cache(defineParallelEdgesFunction({
    codirected: true
  }), 'codirectedEdges')
});

function defineParallelEdgesFunction(params) {
  var defaults = {
    codirected: false
  };
  params = util.extend({}, defaults, params);

  return function parallelEdgesImpl(selector) {
    // micro-optimised for renderer
    var elements = [];
    var edges = this.edges();
    var p = params;

    // look at all the edges in the collection
    for (var i = 0; i < edges.length; i++) {
      var edge1 = edges[i];
      var edge1_p = edge1._private;
      var src1 = edge1_p.source;
      var srcid1 = src1._private.data.id;
      var tgtid1 = edge1_p.data.target;
      var srcEdges1 = src1._private.edges;

      // look at edges connected to the src node of this edge
      for (var j = 0; j < srcEdges1.length; j++) {
        var edge2 = srcEdges1[j];
        var edge2data = edge2._private.data;
        var tgtid2 = edge2data.target;
        var srcid2 = edge2data.source;

        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;

        if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {
          elements.push(edge2);
        }
      }
    }

    return this.spawn(elements, { unique: true }).filter(selector);
  };
}

// Misc functions
/////////////////

util.extend(elesfn, {
  components: function components() {
    var self = this;
    var cy = self.cy();
    var visited = self.spawn();
    var unvisited = self.nodes().spawnSelf();
    var components = [];

    var visitInComponent = function visitInComponent(node, component) {
      visited.merge(node);
      unvisited.unmerge(node);
      component.merge(node);
    };

    if (unvisited.empty()) {
      return self.spawn();
    }

    var _loop = function _loop() {
      var component = cy.collection();
      components.push(component);

      var root = unvisited[0];
      visitInComponent(root, component);

      self.bfs({
        directed: false,
        roots: root,
        visit: function visit(v, e, u, i, depth) {
          visitInComponent(v, component);
        }
      });
    };

    do {
      _loop();
    } while (unvisited.length > 0);

    return components.map(function (component) {
      var connectedEdges = component.connectedEdges().stdFilter(function (edge) {
        return component.anySame(edge.source()) && component.anySame(edge.target());
      });

      return component.union(connectedEdges);
    });
  }
});

module.exports = elesfn;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);
var Collection = __webpack_require__(7);
var Element = __webpack_require__(13);

var corefn = {
  add: function add(opts) {

    var elements = void 0;
    var cy = this;

    // add the elements
    if (is.elementOrCollection(opts)) {
      var eles = opts;

      if (eles._private.cy === cy) {
        // same instance => just restore
        elements = eles.restore();
      } else {
        // otherwise, copy from json
        var jsons = [];

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          jsons.push(ele.json());
        }

        elements = new Collection(cy, jsons);
      }
    }

    // specify an array of options
    else if (is.array(opts)) {
        var _jsons = opts;

        elements = new Collection(cy, _jsons);
      }

      // specify via opts.nodes and opts.edges
      else if (is.plainObject(opts) && (is.array(opts.nodes) || is.array(opts.edges))) {
          var elesByGroup = opts;
          var _jsons2 = [];

          var grs = ['nodes', 'edges'];
          for (var _i = 0, il = grs.length; _i < il; _i++) {
            var group = grs[_i];
            var elesArray = elesByGroup[group];

            if (is.array(elesArray)) {

              for (var j = 0, jl = elesArray.length; j < jl; j++) {
                var json = util.extend({ group: group }, elesArray[j]);

                _jsons2.push(json);
              }
            }
          }

          elements = new Collection(cy, _jsons2);
        }

        // specify options for one element
        else {
            var _json = opts;
            elements = new Element(cy, _json).collection();
          }

    return elements;
  },

  remove: function remove(collection) {
    if (is.elementOrCollection(collection)) {
      // already have right ref
    } else if (is.string(collection)) {
      var selector = collection;
      collection = this.$(selector);
    }

    return collection.remove();
  }
};

module.exports = corefn;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global Float32Array */

/*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */
function generateCubicBezier(mX1, mY1, mX2, mY2) {
  var NEWTON_ITERATIONS = 4,
      NEWTON_MIN_SLOPE = 0.001,
      SUBDIVISION_PRECISION = 0.0000001,
      SUBDIVISION_MAX_ITERATIONS = 10,
      kSplineTableSize = 11,
      kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),
      float32ArraySupported = typeof Float32Array !== 'undefined';

  /* Must contain four arguments. */
  if (arguments.length !== 4) {
    return false;
  }

  /* Arguments must be numbers. */
  for (var i = 0; i < 4; ++i) {
    if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
      return false;
    }
  }

  /* X values must be in the [0, 1] range. */
  mX1 = Math.min(mX1, 1);
  mX2 = Math.min(mX2, 1);
  mX1 = Math.max(mX1, 0);
  mX2 = Math.max(mX2, 0);

  var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  }

  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function newtonRaphsonIterate(aX, aGuessT) {
    for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  function calcSampleValues() {
    for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {
      mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);
    }
  }

  function binarySubdivide(aX, aA, aB) {
    var currentX = void 0,
        currentT = void 0,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

    return currentT;
  }

  function getTForX(aX) {
    var intervalStart = 0.0,
        currentSample = 1,
        lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }

    --currentSample;

    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),
        guessForT = intervalStart + dist * kSampleStepSize,
        initialSlope = getSlope(guessForT, mX1, mX2);

    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
    }
  }

  var _precomputed = false;

  function precompute() {
    _precomputed = true;
    if (mX1 !== mY1 || mX2 !== mY2) {
      calcSampleValues();
    }
  }

  var f = function f(aX) {
    if (!_precomputed) {
      precompute();
    }
    if (mX1 === mY1 && mX2 === mY2) {
      return aX;
    }
    if (aX === 0) {
      return 0;
    }
    if (aX === 1) {
      return 1;
    }

    return calcBezier(getTForX(aX), mY1, mY2);
  };

  f.getControlPoints = function () {
    return [{
      x: mX1,
      y: mY1
    }, {
      x: mX2,
      y: mY2
    }];
  };

  var str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")";
  f.toString = function () {
    return str;
  };

  return f;
}

module.exports = generateCubicBezier;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

function getEasedValue(type, start, end, percent, easingFn) {
  if (percent === 1) {
    return end;
  }

  var val = easingFn(start, end, percent);

  if (type == null) {
    return val;
  }

  if (type.roundValue || type.color) {
    val = Math.round(val);
  }

  if (type.min !== undefined) {
    val = Math.max(val, type.min);
  }

  if (type.max !== undefined) {
    val = Math.min(val, type.max);
  }

  return val;
}

function ease(startProp, endProp, percent, easingFn, propSpec) {
  var type = propSpec != null ? propSpec.type : null;

  if (percent < 0) {
    percent = 0;
  } else if (percent > 1) {
    percent = 1;
  }

  var start = void 0,
      end = void 0;

  if (startProp.pfValue != null || startProp.value != null) {
    start = startProp.pfValue != null ? startProp.pfValue : startProp.value;
  } else {
    start = startProp;
  }

  if (endProp.pfValue != null || endProp.value != null) {
    end = endProp.pfValue != null ? endProp.pfValue : endProp.value;
  } else {
    end = endProp;
  }

  if (is.number(start) && is.number(end)) {
    return getEasedValue(type, start, end, percent, easingFn);
  } else if (is.array(start) && is.array(end)) {
    var easedArr = [];

    for (var i = 0; i < end.length; i++) {
      var si = start[i];
      var ei = end[i];

      if (si != null && ei != null) {
        var val = getEasedValue(type, si, ei, percent, easingFn);

        easedArr.push(val);
      } else {
        easedArr.push(ei);
      }
    }

    return easedArr;
  }

  return undefined;
}

module.exports = ease;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var generateCubicBezier = __webpack_require__(57);
var generateSpringRK4 = __webpack_require__(61);

var cubicBezier = function cubicBezier(t1, p1, t2, p2) {
  var bezier = generateCubicBezier(t1, p1, t2, p2);

  return function (start, end, percent) {
    return start + (end - start) * bezier(percent);
  };
};

var easings = {
  'linear': function linear(start, end, percent) {
    return start + (end - start) * percent;
  },

  // default easings
  'ease': cubicBezier(0.25, 0.1, 0.25, 1),
  'ease-in': cubicBezier(0.42, 0, 1, 1),
  'ease-out': cubicBezier(0, 0, 0.58, 1),
  'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),

  // sine
  'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),
  'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),
  'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),

  // quad
  'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),
  'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),
  'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),

  // cubic
  'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),
  'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),
  'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),

  // quart
  'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),
  'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),
  'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),

  // quint
  'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),
  'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),
  'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),

  // expo
  'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),
  'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),
  'ease-in-out-expo': cubicBezier(1, 0, 0, 1),

  // circ
  'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),
  'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),
  'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),

  // user param easings...

  'spring': function spring(tension, friction, duration) {
    if (duration === 0) {
      // can't get a spring w/ duration 0
      return easings.linear; // duration 0 => jump to end so impl doesn't matter
    }

    var spring = generateSpringRK4(tension, friction, duration);

    return function (start, end, percent) {
      return start + (end - start) * spring(percent);
    };
  },

  'cubic-bezier': cubicBezier
};

module.exports = easings;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(3);
var util = __webpack_require__(1);
var stepAll = __webpack_require__(63);

var corefn = {

  // pull in animation functions
  animate: define.animate(),
  animation: define.animation(),
  animated: define.animated(),
  clearQueue: define.clearQueue(),
  delay: define.delay(),
  delayAnimation: define.delayAnimation(),
  stop: define.stop(),

  addToAnimationPool: function addToAnimationPool(eles) {
    var cy = this;

    if (!cy.styleEnabled()) {
      return;
    } // save cycles when no style used

    cy._private.aniEles.merge(eles);
  },

  stopAnimationLoop: function stopAnimationLoop() {
    this._private.animationsRunning = false;
  },

  startAnimationLoop: function startAnimationLoop() {
    var cy = this;

    cy._private.animationsRunning = true;

    if (!cy.styleEnabled()) {
      return;
    } // save cycles when no style used

    // NB the animation loop will exec in headless environments if style enabled
    // and explicit cy.destroy() is necessary to stop the loop

    function headlessStep() {
      if (!cy._private.animationsRunning) {
        return;
      }

      util.requestAnimationFrame(function animationStep(now) {
        stepAll(now, cy);
        headlessStep();
      });
    }

    var renderer = cy.renderer();

    if (renderer && renderer.beforeRender) {
      // let the renderer schedule animations
      renderer.beforeRender(function rendererAnimationStep(willDraw, now) {
        stepAll(now, cy);
      }, renderer.beforeRenderPriorities.animations);
    } else {
      // manage the animation loop ourselves
      headlessStep(); // first call
    }
  }

};

module.exports = corefn;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
/* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
   then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
var generateSpringRK4 = function () {
  function springAccelerationForState(state) {
    return -state.tension * state.x - state.friction * state.v;
  }

  function springEvaluateStateWithDerivative(initialState, dt, derivative) {
    var state = {
      x: initialState.x + derivative.dx * dt,
      v: initialState.v + derivative.dv * dt,
      tension: initialState.tension,
      friction: initialState.friction
    };

    return { dx: state.v, dv: springAccelerationForState(state) };
  }

  function springIntegrateState(state, dt) {
    var a = {
      dx: state.v,
      dv: springAccelerationForState(state)
    },
        b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
        c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
        d = springEvaluateStateWithDerivative(state, dt, c),
        dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
        dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);

    state.x = state.x + dxdt * dt;
    state.v = state.v + dvdt * dt;

    return state;
  }

  return function springRK4Factory(tension, friction, duration) {

    var initState = {
      x: -1,
      v: 0,
      tension: null,
      friction: null
    },
        path = [0],
        time_lapsed = 0,
        tolerance = 1 / 10000,
        DT = 16 / 1000,
        have_duration = void 0,
        dt = void 0,
        last_state = void 0;

    tension = parseFloat(tension) || 500;
    friction = parseFloat(friction) || 20;
    duration = duration || null;

    initState.tension = tension;
    initState.friction = friction;

    have_duration = duration !== null;

    /* Calculate the actual time it takes for this animation to complete with the provided conditions. */
    if (have_duration) {
      /* Run the simulation without a duration. */
      time_lapsed = springRK4Factory(tension, friction);
      /* Compute the adjusted time delta. */
      dt = time_lapsed / duration * DT;
    } else {
      dt = DT;
    }

    for (;;) {
      /* Next/step function .*/
      last_state = springIntegrateState(last_state || initState, dt);
      /* Store the position. */
      path.push(1 + last_state.x);
      time_lapsed += 16;
      /* If the change threshold is reached, break. */
      if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
        break;
      }
    }

    /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
       computed path and returns a snapshot of the position according to a given percentComplete. */
    return !have_duration ? time_lapsed : function (percentComplete) {
      return path[percentComplete * (path.length - 1) | 0];
    };
  };
}();

module.exports = generateSpringRK4;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function startAnimation(self, ani, now, isCore) {
  var isEles = !isCore;
  var ele = self;
  var ani_p = ani._private;
  var cy = isCore ? self : self.cy();
  var style = cy.style();

  if (isEles) {
    var pos = ele.position();

    ani_p.startPosition = ani_p.startPosition || {
      x: pos.x,
      y: pos.y
    };

    ani_p.startStyle = ani_p.startStyle || style.getAnimationStartStyle(ele, ani_p.style);
  }

  if (isCore) {
    var pan = cy._private.pan;

    ani_p.startPan = ani_p.startPan || {
      x: pan.x,
      y: pan.y
    };

    ani_p.startZoom = ani_p.startZoom != null ? ani_p.startZoom : cy._private.zoom;
  }

  ani_p.started = true;
  ani_p.startTime = now - ani_p.progress * ani_p.duration;
}

module.exports = startAnimation;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var step = __webpack_require__(64);
var startAnimation = __webpack_require__(62);

function stepAll(now, cy) {
  var eles = cy._private.aniEles;
  var doneEles = [];

  function stepOne(ele, isCore) {
    var _p = ele._private;
    var current = _p.animation.current;
    var queue = _p.animation.queue;
    var ranAnis = false;

    // cancel all animations on display:none ele
    if (!isCore && ele.pstyle('display').value === 'none') {
      // put all current and queue animations in this tick's current list
      // and empty the lists for the element
      current = current.splice(0, current.length).concat(queue.splice(0, queue.length));

      // stop all animations
      for (var i = 0; i < current.length; i++) {
        current[i].stop();
      }
    }

    // if nothing currently animating, get something from the queue
    if (current.length === 0) {
      var next = queue.shift();

      if (next) {
        current.push(next);
      }
    }

    var callbacks = function callbacks(_callbacks) {
      for (var j = _callbacks.length - 1; j >= 0; j--) {
        var cb = _callbacks[j];

        cb();
      }

      _callbacks.splice(0, _callbacks.length);
    };

    // step and remove if done
    for (var _i = current.length - 1; _i >= 0; _i--) {
      var ani = current[_i];
      var ani_p = ani._private;

      if (ani_p.stopped) {
        current.splice(_i, 1);

        ani_p.hooked = false;
        ani_p.playing = false;
        ani_p.started = false;

        callbacks(ani_p.frames);

        continue;
      }

      if (!ani_p.playing && !ani_p.applying) {
        continue;
      }

      // an apply() while playing shouldn't do anything
      if (ani_p.playing && ani_p.applying) {
        ani_p.applying = false;
      }

      if (!ani_p.started) {
        startAnimation(ele, ani, now, isCore);
      }

      step(ele, ani, now, isCore);

      if (ani_p.applying) {
        ani_p.applying = false;
      }

      callbacks(ani_p.frames);

      if (ani.completed()) {
        current.splice(_i, 1);

        ani_p.hooked = false;
        ani_p.playing = false;
        ani_p.started = false;

        callbacks(ani_p.completes);
      }

      ranAnis = true;
    }

    if (!isCore && current.length === 0 && queue.length === 0) {
      doneEles.push(ele);
    }

    return ranAnis;
  } // stepElement

  // handle all eles
  var ranEleAni = false;
  for (var e = 0; e < eles.length; e++) {
    var ele = eles[e];
    var handledThisEle = stepOne(ele);

    ranEleAni = ranEleAni || handledThisEle;
  } // each element

  var ranCoreAni = stepOne(cy, true);

  // notify renderer
  if (ranEleAni || ranCoreAni) {
    if (eles.length > 0) {
      eles.dirtyCompoundBoundsCache();

      cy.notify({
        type: 'draw',
        eles: eles
      });
    } else {
      cy.notify({
        type: 'draw'
      });
    }
  }

  // remove elements from list of currently animating if its queues are empty
  eles.unmerge(doneEles);

  cy.emit('step');
} // stepAll

module.exports = stepAll;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var easings = __webpack_require__(59);
var ease = __webpack_require__(58);
var is = __webpack_require__(0);

function step(self, ani, now, isCore) {
  var isEles = !isCore;
  var _p = self._private;
  var ani_p = ani._private;
  var pEasing = ani_p.easing;
  var startTime = ani_p.startTime;
  var cy = isCore ? self : self.cy();
  var style = cy.style();

  if (!ani_p.easingImpl) {

    if (pEasing == null) {
      // use default
      ani_p.easingImpl = easings['linear'];
    } else {
      // then define w/ name
      var easingVals = void 0;

      if (is.string(pEasing)) {
        var easingProp = style.parse('transition-timing-function', pEasing);

        easingVals = easingProp.value;
      } else {
        // then assume preparsed array
        easingVals = pEasing;
      }

      var name = void 0,
          args = void 0;

      if (is.string(easingVals)) {
        name = easingVals;
        args = [];
      } else {
        name = easingVals[1];
        args = easingVals.slice(2).map(function (n) {
          return +n;
        });
      }

      if (args.length > 0) {
        // create with args
        if (name === 'spring') {
          args.push(ani_p.duration); // need duration to generate spring
        }

        ani_p.easingImpl = easings[name].apply(null, args);
      } else {
        // static impl by name
        ani_p.easingImpl = easings[name];
      }
    }
  }

  var easing = ani_p.easingImpl;
  var percent = void 0;

  if (ani_p.duration === 0) {
    percent = 1;
  } else {
    percent = (now - startTime) / ani_p.duration;
  }

  if (ani_p.applying) {
    percent = ani_p.progress;
  }

  if (percent < 0) {
    percent = 0;
  } else if (percent > 1) {
    percent = 1;
  }

  if (ani_p.delay == null) {
    // then update

    var startPos = ani_p.startPosition;
    var endPos = ani_p.position;

    if (endPos && isEles && !self.locked()) {
      var pos = self.position();

      if (valid(startPos.x, endPos.x)) {
        pos.x = ease(startPos.x, endPos.x, percent, easing);
      }

      if (valid(startPos.y, endPos.y)) {
        pos.y = ease(startPos.y, endPos.y, percent, easing);
      }

      self.emit('position');
    }

    var startPan = ani_p.startPan;
    var endPan = ani_p.pan;
    var pan = _p.pan;
    var animatingPan = endPan != null && isCore;
    if (animatingPan) {
      if (valid(startPan.x, endPan.x)) {
        pan.x = ease(startPan.x, endPan.x, percent, easing);
      }

      if (valid(startPan.y, endPan.y)) {
        pan.y = ease(startPan.y, endPan.y, percent, easing);
      }

      self.emit('pan');
    }

    var startZoom = ani_p.startZoom;
    var endZoom = ani_p.zoom;
    var animatingZoom = endZoom != null && isCore;
    if (animatingZoom) {
      if (valid(startZoom, endZoom)) {
        _p.zoom = ease(startZoom, endZoom, percent, easing);
      }

      self.emit('zoom');
    }

    if (animatingPan || animatingZoom) {
      self.emit('viewport');
    }

    var props = ani_p.style;
    if (props && props.length > 0 && isEles) {
      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        var _name = prop.name;
        var end = prop;
        var start = ani_p.startStyle[_name];
        var propSpec = style.properties[start.name];
        var easedVal = ease(start, end, percent, easing, propSpec);

        style.overrideBypass(self, _name, easedVal);
      } // for props

      self.emit('style');
    } // if
  }

  ani_p.progress = percent;

  return percent;
}

function valid(start, end) {
  if (start == null || end == null) {
    return false;
  }

  if (is.number(start) && is.number(end)) {
    return true;
  } else if (start && end) {
    return true;
  }

  return false;
}

module.exports = step;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Emitter = __webpack_require__(10);
var define = __webpack_require__(3);
var is = __webpack_require__(0);
var util = __webpack_require__(1);
var Selector = __webpack_require__(6);

var emitterOptions = {
  qualifierCompare: function qualifierCompare(selector1, selector2) {
    if (selector1 == null || selector2 == null) {
      return selector1 == null && selector2 == null;
    } else {
      return selector1.sameText(selector2);
    }
  },
  eventMatches: function eventMatches(cy, listener, eventObj) {
    var selector = listener.qualifier;

    if (selector != null) {
      return cy !== eventObj.target && is.element(eventObj.target) && selector.matches(eventObj.target);
    }

    return true;
  },
  eventFields: function eventFields(cy) {
    return {
      cy: cy,
      target: cy
    };
  },
  callbackContext: function callbackContext(cy, listener, eventObj) {
    return listener.qualifier != null ? eventObj.target : cy;
  }
};

var argSelector = function argSelector(arg) {
  if (is.string(arg)) {
    return new Selector(arg);
  } else {
    return arg;
  }
};

var elesfn = {
  createEmitter: function createEmitter() {
    var _p = this._private;

    if (!_p.emitter) {
      _p.emitter = new Emitter(util.assign({
        context: this
      }, emitterOptions));
    }

    return this;
  },

  emitter: function emitter() {
    return this._private.emitter;
  },

  on: function on(events, selector, callback) {
    this.emitter().on(events, argSelector(selector), callback);

    return this;
  },

  removeListener: function removeListener(events, selector, callback) {
    this.emitter().removeListener(events, argSelector(selector), callback);

    return this;
  },

  one: function one(events, selector, callback) {
    this.emitter().one(events, argSelector(selector), callback);

    return this;
  },

  once: function once(events, selector, callback) {
    this.emitter().one(events, argSelector(selector), callback);

    return this;
  },

  emit: function emit(events, extraParams) {
    this.emitter().emit(events, extraParams);

    return this;
  }
};

define.eventAliasesOn(elesfn);

module.exports = elesfn;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var corefn = {

  png: function png(options) {
    var renderer = this._private.renderer;
    options = options || {};

    return renderer.png(options);
  },

  jpg: function jpg(options) {
    var renderer = this._private.renderer;
    options = options || {};

    options.bg = options.bg || '#fff';

    return renderer.jpg(options);
  }

};

corefn.jpeg = corefn.jpg;

module.exports = corefn;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);

var corefn = {

  layout: function layout(options) {
    var cy = this;

    if (options == null) {
      util.error('Layout options must be specified to make a layout');
      return;
    }

    if (options.name == null) {
      util.error('A `name` must be specified to make a layout');
      return;
    }

    var name = options.name;
    var Layout = cy.extension('layout', name);

    if (Layout == null) {
      util.error('Can not apply layout: No such layout `' + name + '` found; did you include its JS file?');
      return;
    }

    var eles = void 0;
    if (is.string(options.eles)) {
      eles = cy.$(options.eles);
    } else {
      eles = options.eles != null ? options.eles : cy.$();
    }

    var layout = new Layout(util.extend({}, options, {
      cy: cy,
      eles: eles
    }));

    return layout;
  }

};

corefn.createLayout = corefn.makeLayout = corefn.layout;

module.exports = corefn;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var corefn = {
  notify: function notify(params) {
    var _p = this._private;

    if (_p.batchingNotify) {
      var bEles = _p.batchNotifyEles;
      var bTypes = _p.batchNotifyTypes;

      if (params.eles) {
        bEles.merge(params.eles);
      }

      if (!bTypes.ids[params.type]) {
        bTypes.push(params.type);
        bTypes.ids[params.type] = true;
      }

      return; // notifications are disabled during batching
    }

    if (!_p.notificationsEnabled) {
      return;
    } // exit on disabled

    var renderer = this.renderer();

    // exit if destroy() called on core or renderer in between frames #1499 #1528
    if (this.isDestroyed() || !renderer) {
      return;
    }

    renderer.notify(params);
  },

  notifications: function notifications(bool) {
    var p = this._private;

    if (bool === undefined) {
      return p.notificationsEnabled;
    } else {
      p.notificationsEnabled = bool ? true : false;
    }
  },

  noNotifications: function noNotifications(callback) {
    this.notifications(false);
    callback();
    this.notifications(true);
  },

  batching: function batching() {
    return this._private.batchCount > 0;
  },

  startBatch: function startBatch() {
    var _p = this._private;

    if (_p.batchCount == null) {
      _p.batchCount = 0;
    }

    if (_p.batchCount === 0) {
      _p.batchingStyle = _p.batchingNotify = true;
      _p.batchStyleEles = this.collection();
      _p.batchNotifyEles = this.collection();
      _p.batchNotifyTypes = [];
      _p.batchNotifyTypes.ids = {};
    }

    _p.batchCount++;

    return this;
  },

  endBatch: function endBatch() {
    var _p = this._private;

    _p.batchCount--;

    if (_p.batchCount === 0) {
      // update style for dirty eles
      _p.batchingStyle = false;
      _p.batchStyleEles.updateStyle();

      // notify the renderer of queued eles and event types
      _p.batchingNotify = false;
      this.notify({
        type: _p.batchNotifyTypes,
        eles: _p.batchNotifyEles
      });
    }

    return this;
  },

  batch: function batch(callback) {
    this.startBatch();
    callback();
    this.endBatch();

    return this;
  },

  // for backwards compatibility
  batchData: function batchData(map) {
    var cy = this;

    return this.batch(function () {
      var ids = Object.keys(map);

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var data = map[id];
        var ele = cy.getElementById(id);

        ele.data(data);
      }
    });
  }
};

module.exports = corefn;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

var corefn = {

  renderTo: function renderTo(context, zoom, pan, pxRatio) {
    var r = this._private.renderer;

    r.renderTo(context, zoom, pan, pxRatio);
    return this;
  },

  renderer: function renderer() {
    return this._private.renderer;
  },

  forceRender: function forceRender() {
    this.notify({
      type: 'draw'
    });

    return this;
  },

  resize: function resize() {
    this.invalidateSize();

    this.notify({
      type: 'resize'
    });

    this.emit('resize');

    return this;
  },

  initRenderer: function initRenderer(options) {
    var cy = this;

    var RendererProto = cy.extension('renderer', options.name);
    if (RendererProto == null) {
      util.error('Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name);
      return;
    }

    cy._private.renderer = new RendererProto(util.extend({}, options, { cy: cy }));

    this.notify({ type: 'init' });
  },

  destroyRenderer: function destroyRenderer() {
    var cy = this;

    cy.notify({ type: 'destroy' }); // destroy the renderer

    var domEle = cy.container();
    if (domEle) {
      domEle._cyreg = null;

      while (domEle.childNodes.length > 0) {
        domEle.removeChild(domEle.childNodes[0]);
      }
    }

    cy._private.renderer = null; // to be extra safe, remove the ref
  },

  onRender: function onRender(fn) {
    return this.on('render', fn);
  },

  offRender: function offRender(fn) {
    return this.off('render', fn);
  }

};

corefn.invalidateDimensions = corefn.resize;

module.exports = corefn;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var Collection = __webpack_require__(7);

var corefn = {

  // get a collection
  // - empty collection on no args
  // - collection of elements in the graph on selector arg
  // - guarantee a returned collection when elements or collection specified
  collection: function collection(eles, opts) {

    if (is.string(eles)) {
      return this.$(eles);
    } else if (is.elementOrCollection(eles)) {
      return eles.collection();
    } else if (is.array(eles)) {
      return new Collection(this, eles, opts);
    }

    return new Collection(this);
  },

  nodes: function nodes(selector) {
    var nodes = this.$(function (ele) {
      return ele.isNode();
    });

    if (selector) {
      return nodes.filter(selector);
    }

    return nodes;
  },

  edges: function edges(selector) {
    var edges = this.$(function (ele) {
      return ele.isEdge();
    });

    if (selector) {
      return edges.filter(selector);
    }

    return edges;
  },

  // search the graph like jQuery
  $: function $(selector) {
    var eles = this._private.elements;

    if (selector) {
      return eles.filter(selector);
    } else {
      return eles.spawnSelf();
    }
  },

  mutableElements: function mutableElements() {
    return this._private.elements;
  }

};

// aliases
corefn.elements = corefn.filter = corefn.$;

module.exports = corefn;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var Style = __webpack_require__(18);

var corefn = {

  style: function style(newStyle) {
    if (newStyle) {
      var s = this.setStyle(newStyle);

      s.update();
    }

    return this._private.style;
  },

  setStyle: function setStyle(style) {
    var _p = this._private;

    if (is.stylesheet(style)) {
      _p.style = style.generateStyle(this);
    } else if (is.array(style)) {
      _p.style = Style.fromJson(this, style);
    } else if (is.string(style)) {
      _p.style = Style.fromString(this, style);
    } else {
      _p.style = Style(this);
    }

    return _p.style;
  }
};

module.exports = corefn;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var window = __webpack_require__(4);
var math = __webpack_require__(2);

var corefn = {

  autolock: function autolock(bool) {
    if (bool !== undefined) {
      this._private.autolock = bool ? true : false;
    } else {
      return this._private.autolock;
    }

    return this; // chaining
  },

  autoungrabify: function autoungrabify(bool) {
    if (bool !== undefined) {
      this._private.autoungrabify = bool ? true : false;
    } else {
      return this._private.autoungrabify;
    }

    return this; // chaining
  },

  autounselectify: function autounselectify(bool) {
    if (bool !== undefined) {
      this._private.autounselectify = bool ? true : false;
    } else {
      return this._private.autounselectify;
    }

    return this; // chaining
  },

  panningEnabled: function panningEnabled(bool) {
    if (bool !== undefined) {
      this._private.panningEnabled = bool ? true : false;
    } else {
      return this._private.panningEnabled;
    }

    return this; // chaining
  },

  userPanningEnabled: function userPanningEnabled(bool) {
    if (bool !== undefined) {
      this._private.userPanningEnabled = bool ? true : false;
    } else {
      return this._private.userPanningEnabled;
    }

    return this; // chaining
  },

  zoomingEnabled: function zoomingEnabled(bool) {
    if (bool !== undefined) {
      this._private.zoomingEnabled = bool ? true : false;
    } else {
      return this._private.zoomingEnabled;
    }

    return this; // chaining
  },

  userZoomingEnabled: function userZoomingEnabled(bool) {
    if (bool !== undefined) {
      this._private.userZoomingEnabled = bool ? true : false;
    } else {
      return this._private.userZoomingEnabled;
    }

    return this; // chaining
  },

  boxSelectionEnabled: function boxSelectionEnabled(bool) {
    if (bool !== undefined) {
      this._private.boxSelectionEnabled = bool ? true : false;
    } else {
      return this._private.boxSelectionEnabled;
    }

    return this; // chaining
  },

  pan: function pan() {
    var args = arguments;
    var pan = this._private.pan;
    var dim = void 0,
        val = void 0,
        dims = void 0,
        x = void 0,
        y = void 0;

    switch (args.length) {
      case 0:
        // .pan()
        return pan;

      case 1:

        if (is.string(args[0])) {
          // .pan('x')
          dim = args[0];
          return pan[dim];
        } else if (is.plainObject(args[0])) {
          // .pan({ x: 0, y: 100 })
          if (!this._private.panningEnabled) {
            return this;
          }

          dims = args[0];
          x = dims.x;
          y = dims.y;

          if (is.number(x)) {
            pan.x = x;
          }

          if (is.number(y)) {
            pan.y = y;
          }

          this.emit('pan viewport');
        }
        break;

      case 2:
        // .pan('x', 100)
        if (!this._private.panningEnabled) {
          return this;
        }

        dim = args[0];
        val = args[1];

        if ((dim === 'x' || dim === 'y') && is.number(val)) {
          pan[dim] = val;
        }

        this.emit('pan viewport');
        break;

      default:
        break; // invalid
    }

    this.notify({ // notify the renderer that the viewport changed
      type: 'viewport'
    });

    return this; // chaining
  },

  panBy: function panBy(arg0, arg1) {
    var args = arguments;
    var pan = this._private.pan;
    var dim = void 0,
        val = void 0,
        dims = void 0,
        x = void 0,
        y = void 0;

    if (!this._private.panningEnabled) {
      return this;
    }

    switch (args.length) {
      case 1:

        if (is.plainObject(arg0)) {
          // .panBy({ x: 0, y: 100 })
          dims = args[0];
          x = dims.x;
          y = dims.y;

          if (is.number(x)) {
            pan.x += x;
          }

          if (is.number(y)) {
            pan.y += y;
          }

          this.emit('pan viewport');
        }
        break;

      case 2:
        // .panBy('x', 100)
        dim = arg0;
        val = arg1;

        if ((dim === 'x' || dim === 'y') && is.number(val)) {
          pan[dim] += val;
        }

        this.emit('pan viewport');
        break;

      default:
        break; // invalid
    }

    this.notify({ // notify the renderer that the viewport changed
      type: 'viewport'
    });

    return this; // chaining
  },

  fit: function fit(elements, padding) {
    var viewportState = this.getFitViewport(elements, padding);

    if (viewportState) {
      var _p = this._private;
      _p.zoom = viewportState.zoom;
      _p.pan = viewportState.pan;

      this.emit('pan zoom viewport');

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });
    }

    return this; // chaining
  },

  getFitViewport: function getFitViewport(elements, padding) {
    if (is.number(elements) && padding === undefined) {
      // elements is optional
      padding = elements;
      elements = undefined;
    }

    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
      return;
    }

    var bb = void 0;

    if (is.string(elements)) {
      var sel = elements;
      elements = this.$(sel);
    } else if (is.boundingBox(elements)) {
      // assume bb
      var bbe = elements;
      bb = {
        x1: bbe.x1,
        y1: bbe.y1,
        x2: bbe.x2,
        y2: bbe.y2
      };

      bb.w = bb.x2 - bb.x1;
      bb.h = bb.y2 - bb.y1;
    } else if (!is.elementOrCollection(elements)) {
      elements = this.mutableElements();
    }

    if (is.elementOrCollection(elements) && elements.empty()) {
      return;
    } // can't fit to nothing

    bb = bb || elements.boundingBox();

    var w = this.width();
    var h = this.height();
    var zoom = void 0;
    padding = is.number(padding) ? padding : 0;

    if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {
      zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h);

      // crop zoom
      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

      var pan = { // now pan to middle
        x: (w - zoom * (bb.x1 + bb.x2)) / 2,
        y: (h - zoom * (bb.y1 + bb.y2)) / 2
      };

      return {
        zoom: zoom,
        pan: pan
      };
    }

    return;
  },

  minZoom: function minZoom(zoom) {
    if (zoom === undefined) {
      return this._private.minZoom;
    } else if (is.number(zoom)) {
      this._private.minZoom = zoom;
    }

    return this;
  },

  maxZoom: function maxZoom(zoom) {
    if (zoom === undefined) {
      return this._private.maxZoom;
    } else if (is.number(zoom)) {
      this._private.maxZoom = zoom;
    }

    return this;
  },

  getZoomedViewport: function getZoomedViewport(params) {
    var _p = this._private;
    var currentPan = _p.pan;
    var currentZoom = _p.zoom;
    var pos = void 0; // in rendered px
    var zoom = void 0;
    var bail = false;

    if (!_p.zoomingEnabled) {
      // zooming disabled
      bail = true;
    }

    if (is.number(params)) {
      // then set the zoom
      zoom = params;
    } else if (is.plainObject(params)) {
      // then zoom about a point
      zoom = params.level;

      if (params.position != null) {
        pos = math.modelToRenderedPosition(params.position, currentZoom, currentPan);
      } else if (params.renderedPosition != null) {
        pos = params.renderedPosition;
      }

      if (pos != null && !_p.panningEnabled) {
        // panning disabled
        bail = true;
      }
    }

    // crop zoom
    zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;
    zoom = zoom < _p.minZoom ? _p.minZoom : zoom;

    // can't zoom with invalid params
    if (bail || !is.number(zoom) || zoom === currentZoom || pos != null && (!is.number(pos.x) || !is.number(pos.y))) {
      return null;
    }

    if (pos != null) {
      // set zoom about position
      var pan1 = currentPan;
      var zoom1 = currentZoom;
      var zoom2 = zoom;

      var pan2 = {
        x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,
        y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y
      };

      return {
        zoomed: true,
        panned: true,
        zoom: zoom2,
        pan: pan2
      };
    } else {
      // just set the zoom
      return {
        zoomed: true,
        panned: false,
        zoom: zoom,
        pan: currentPan
      };
    }
  },

  zoom: function zoom(params) {
    if (params === undefined) {
      // get
      return this._private.zoom;
    } else {
      // set
      var vp = this.getZoomedViewport(params);
      var _p = this._private;

      if (vp == null || !vp.zoomed) {
        return this;
      }

      _p.zoom = vp.zoom;

      if (vp.panned) {
        _p.pan.x = vp.pan.x;
        _p.pan.y = vp.pan.y;
      }

      this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    }
  },

  viewport: function viewport(opts) {
    var _p = this._private;
    var zoomDefd = true;
    var panDefd = true;
    var events = []; // to trigger
    var zoomFailed = false;
    var panFailed = false;

    if (!opts) {
      return this;
    }
    if (!is.number(opts.zoom)) {
      zoomDefd = false;
    }
    if (!is.plainObject(opts.pan)) {
      panDefd = false;
    }
    if (!zoomDefd && !panDefd) {
      return this;
    }

    if (zoomDefd) {
      var z = opts.zoom;

      if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {
        zoomFailed = true;
      } else {
        _p.zoom = z;

        events.push('zoom');
      }
    }

    if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {
      var p = opts.pan;

      if (is.number(p.x)) {
        _p.pan.x = p.x;
        panFailed = false;
      }

      if (is.number(p.y)) {
        _p.pan.y = p.y;
        panFailed = false;
      }

      if (!panFailed) {
        events.push('pan');
      }
    }

    if (events.length > 0) {
      events.push('viewport');
      this.emit(events.join(' '));

      this.notify({
        type: 'viewport'
      });
    }

    return this; // chaining
  },

  center: function center(elements) {
    var pan = this.getCenterPan(elements);

    if (pan) {
      this._private.pan = pan;

      this.emit('pan viewport');

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });
    }

    return this; // chaining
  },

  getCenterPan: function getCenterPan(elements, zoom) {
    if (!this._private.panningEnabled) {
      return;
    }

    if (is.string(elements)) {
      var selector = elements;
      elements = this.mutableElements().filter(selector);
    } else if (!is.elementOrCollection(elements)) {
      elements = this.mutableElements();
    }

    if (elements.length === 0) {
      return;
    } // can't centre pan to nothing

    var bb = elements.boundingBox();
    var w = this.width();
    var h = this.height();
    zoom = zoom === undefined ? this._private.zoom : zoom;

    var pan = { // middle
      x: (w - zoom * (bb.x1 + bb.x2)) / 2,
      y: (h - zoom * (bb.y1 + bb.y2)) / 2
    };

    return pan;
  },

  reset: function reset() {
    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
      return this;
    }

    this.viewport({
      pan: { x: 0, y: 0 },
      zoom: 1
    });

    return this; // chaining
  },

  invalidateSize: function invalidateSize() {
    this._private.sizeCache = null;
  },

  size: function size() {
    var _p = this._private;
    var container = _p.container;

    return _p.sizeCache = _p.sizeCache || (container ? function () {
      var style = window.getComputedStyle(container);
      var val = function val(name) {
        return parseFloat(style.getPropertyValue(name));
      };

      return {
        width: container.clientWidth - val('padding-left') - val('padding-right'),
        height: container.clientHeight - val('padding-top') - val('padding-bottom')
      };
    }() : { // fallback if no container (not 0 b/c can be used for dividing etc)
      width: 1,
      height: 1
    });
  },

  width: function width() {
    return this.size().width;
  },

  height: function height() {
    return this.size().height;
  },

  extent: function extent() {
    var pan = this._private.pan;
    var zoom = this._private.zoom;
    var rb = this.renderedExtent();

    var b = {
      x1: (rb.x1 - pan.x) / zoom,
      x2: (rb.x2 - pan.x) / zoom,
      y1: (rb.y1 - pan.y) / zoom,
      y2: (rb.y2 - pan.y) / zoom
    };

    b.w = b.x2 - b.x1;
    b.h = b.y2 - b.y1;

    return b;
  },

  renderedExtent: function renderedExtent() {
    var width = this.width();
    var height = this.height();

    return {
      x1: 0,
      y1: 0,
      x2: width,
      y2: height,
      w: width,
      h: height
    };
  }
};

// aliases
corefn.centre = corefn.center;

// backwards compatibility
corefn.autolockNodes = corefn.autolock;
corefn.autoungrabifyNodes = corefn.autoungrabify;

module.exports = corefn;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var Animation = __webpack_require__(24);
var math = __webpack_require__(2);
var is = __webpack_require__(0);

var define = {

  animated: function animated() {
    return function animatedImpl() {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return false;
      }

      var ele = all[0];

      if (ele) {
        return ele._private.animation.current.length > 0;
      }
    };
  }, // animated

  clearQueue: function clearQueue() {
    return function clearQueueImpl() {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      for (var i = 0; i < all.length; i++) {
        var ele = all[i];
        ele._private.animation.queue = [];
      }

      return this;
    };
  }, // clearQueue

  delay: function delay() {
    return function delayImpl(time, complete) {
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      return this.animate({
        delay: time,
        duration: time,
        complete: complete
      });
    };
  }, // delay

  delayAnimation: function delayAnimation() {
    return function delayAnimationImpl(time, complete) {
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      return this.animation({
        delay: time,
        duration: time,
        complete: complete
      });
    };
  }, // delay

  animation: function animation() {
    return function animationImpl(properties, params) {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;
      var isCore = !selfIsArrayLike;
      var isEles = !isCore;

      if (!cy.styleEnabled()) {
        return this;
      }

      var style = cy.style();

      properties = util.assign({}, properties, params);

      var propertiesEmpty = Object.keys(properties).length === 0;

      if (propertiesEmpty) {
        return new Animation(all[0], properties); // nothing to animate
      }

      if (properties.duration === undefined) {
        properties.duration = 400;
      }

      switch (properties.duration) {
        case 'slow':
          properties.duration = 600;
          break;
        case 'fast':
          properties.duration = 200;
          break;
      }

      if (isEles) {
        properties.style = style.getPropsList(properties.style || properties.css);

        properties.css = undefined;
      }

      if (isEles && properties.renderedPosition != null) {
        var rpos = properties.renderedPosition;
        var pan = cy.pan();
        var zoom = cy.zoom();

        properties.position = math.renderedToModelPosition(rpos, zoom, pan);
      }

      // override pan w/ panBy if set
      if (isCore && properties.panBy != null) {
        var panBy = properties.panBy;
        var cyPan = cy.pan();

        properties.pan = {
          x: cyPan.x + panBy.x,
          y: cyPan.y + panBy.y
        };
      }

      // override pan w/ center if set
      var center = properties.center || properties.centre;
      if (isCore && center != null) {
        var centerPan = cy.getCenterPan(center.eles, properties.zoom);

        if (centerPan != null) {
          properties.pan = centerPan;
        }
      }

      // override pan & zoom w/ fit if set
      if (isCore && properties.fit != null) {
        var fit = properties.fit;
        var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);

        if (fitVp != null) {
          properties.pan = fitVp.pan;
          properties.zoom = fitVp.zoom;
        }
      }

      // override zoom (& potentially pan) w/ zoom obj if set
      if (isCore && is.plainObject(properties.zoom)) {
        var vp = cy.getZoomedViewport(properties.zoom);

        if (vp != null) {
          if (vp.zoomed) {
            properties.zoom = vp.zoom;
          }

          if (vp.panned) {
            properties.pan = vp.pan;
          }
        }
      }

      return new Animation(all[0], properties);
    };
  }, // animate

  animate: function animate() {
    return function animateImpl(properties, params) {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      if (params) {
        properties = util.extend({}, properties, params);
      }

      // manually hook and run the animation
      for (var i = 0; i < all.length; i++) {
        var ele = all[i];
        var queue = ele.animated() && (properties.queue === undefined || properties.queue);

        var ani = ele.animation(properties, queue ? { queue: true } : undefined);

        ani.play();
      }

      return this; // chaining
    };
  }, // animate

  stop: function stop() {
    return function stopImpl(clearQueue, jumpToEnd) {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      for (var i = 0; i < all.length; i++) {
        var ele = all[i];
        var _p = ele._private;
        var anis = _p.animation.current;

        for (var j = 0; j < anis.length; j++) {
          var ani = anis[j];
          var ani_p = ani._private;

          if (jumpToEnd) {
            // next iteration of the animation loop, the animation
            // will go straight to the end and be removed
            ani_p.duration = 0;
          }
        }

        // clear the queue of future animations
        if (clearQueue) {
          _p.animation.queue = [];
        }

        if (!jumpToEnd) {
          _p.animation.current = [];
        }
      }

      // we have to notify (the animation loop doesn't do it for us on `stop`)
      cy.notify({
        eles: this,
        type: 'draw'
      });

      return this;
    };
  } // stop

}; // define

module.exports = define;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var util = __webpack_require__(1);
var is = __webpack_require__(0);

var define = {

  // access data field
  data: function data(params) {
    var defaults = {
      field: 'data',
      bindingEvent: 'data',
      allowBinding: false,
      allowSetting: false,
      allowGetting: false,
      settingEvent: 'data',
      settingTriggersEvent: false,
      triggerFnName: 'trigger',
      immutableKeys: {}, // key => true if immutable
      updateStyle: false,
      beforeGet: function beforeGet(self) {},
      beforeSet: function beforeSet(self, obj) {},
      onSet: function onSet(self) {},
      canSet: function canSet(self) {
        return true;
      }
    };
    params = util.extend({}, defaults, params);

    return function dataImpl(name, value) {
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var single = selfIsArrayLike ? self[0] : self;

      // .data('foo', ...)
      if (is.string(name)) {
        // set or get property

        // .data('foo')
        if (p.allowGetting && value === undefined) {
          // get

          var ret = void 0;
          if (single) {
            p.beforeGet(single);

            ret = single._private[p.field][name];
          }
          return ret;

          // .data('foo', 'bar')
        } else if (p.allowSetting && value !== undefined) {
          // set
          var valid = !p.immutableKeys[name];
          if (valid) {
            var change = _defineProperty({}, name, value);

            p.beforeSet(self, change);

            for (var i = 0, l = all.length; i < l; i++) {
              var ele = all[i];

              if (p.canSet(ele)) {
                ele._private[p.field][name] = value;
              }
            }

            // update mappers if asked
            if (p.updateStyle) {
              self.updateStyle();
            }

            // call onSet callback
            p.onSet(self);

            if (p.settingTriggersEvent) {
              self[p.triggerFnName](p.settingEvent);
            }
          }
        }

        // .data({ 'foo': 'bar' })
      } else if (p.allowSetting && is.plainObject(name)) {
        // extend
        var obj = name;
        var k = void 0,
            v = void 0;
        var keys = Object.keys(obj);

        p.beforeSet(self, obj);

        for (var _i = 0; _i < keys.length; _i++) {
          k = keys[_i];
          v = obj[k];

          var _valid = !p.immutableKeys[k];
          if (_valid) {
            for (var j = 0; j < all.length; j++) {
              var _ele = all[j];

              if (p.canSet(_ele)) {
                _ele._private[p.field][k] = v;
              }
            }
          }
        }

        // update mappers if asked
        if (p.updateStyle) {
          self.updateStyle();
        }

        // call onSet callback
        p.onSet(self);

        if (p.settingTriggersEvent) {
          self[p.triggerFnName](p.settingEvent);
        }

        // .data(function(){ ... })
      } else if (p.allowBinding && is.fn(name)) {
        // bind to event
        var fn = name;
        self.on(p.bindingEvent, fn);

        // .data()
      } else if (p.allowGetting && name === undefined) {
        // get whole object
        var _ret = void 0;
        if (single) {
          p.beforeGet(single);

          _ret = single._private[p.field];
        }
        return _ret;
      }

      return self; // maintain chainability
    }; // function
  }, // data

  // remove data field
  removeData: function removeData(params) {
    var defaults = {
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: false,
      immutableKeys: {} // key => true if immutable
    };
    params = util.extend({}, defaults, params);

    return function removeDataImpl(names) {
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      // .removeData('foo bar')
      if (is.string(names)) {
        // then get the list of keys, and delete them
        var keys = names.split(/\s+/);
        var l = keys.length;

        for (var i = 0; i < l; i++) {
          // delete each non-empty key
          var key = keys[i];
          if (is.emptyString(key)) {
            continue;
          }

          var valid = !p.immutableKeys[key]; // not valid if immutable
          if (valid) {
            for (var i_a = 0, l_a = all.length; i_a < l_a; i_a++) {
              all[i_a]._private[p.field][key] = undefined;
            }
          }
        }

        if (p.triggerEvent) {
          self[p.triggerFnName](p.event);
        }

        // .removeData()
      } else if (names === undefined) {
        // then delete all keys

        for (var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++) {
          var _privateFields = all[_i_a]._private[p.field];
          var _keys = Object.keys(_privateFields);

          for (var _i2 = 0; _i2 < _keys.length; _i2++) {
            var _key = _keys[_i2];
            var validKeyToDelete = !p.immutableKeys[_key];

            if (validKeyToDelete) {
              _privateFields[_key] = undefined;
            }
          }
        }

        if (p.triggerEvent) {
          self[p.triggerFnName](p.event);
        }
      }

      return self; // maintain chaining
    }; // function
  } // removeData
}; // define

module.exports = define;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Promise = __webpack_require__(5);

var define = {

  eventAliasesOn: function eventAliasesOn(proto) {
    var p = proto;

    p.addListener = p.listen = p.bind = p.on;
    p.unlisten = p.unbind = p.off = p.removeListener;
    p.trigger = p.emit;

    // this is just a wrapper alias of .on()
    p.pon = p.promiseOn = function (events, selector) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 0);

      return new Promise(function (resolve, reject) {
        var callback = function callback(e) {
          self.off.apply(self, offArgs);

          resolve(e);
        };

        var onArgs = args.concat([callback]);
        var offArgs = onArgs.concat([]);

        self.on.apply(self, onArgs);
      });
    };
  }

}; // define

module.exports = define;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [{
  type: 'layout',
  extensions: __webpack_require__(82)
}, {
  type: 'renderer',
  extensions: __webpack_require__(115)
}];

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var math = __webpack_require__(2);
var is = __webpack_require__(0);

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
  padding: 30, // padding on fit
  circle: false, // put depths in concentric circles if true, put depths top down if false
  spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
  roots: undefined, // the roots of the trees
  maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled,
  animateFilter: function animateFilter(node, i) {
    return true;
  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined, // callback on layoutready
  stop: undefined, // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts
};

function BreadthFirstLayout(options) {
  this.options = util.extend({}, defaults, options);
}

BreadthFirstLayout.prototype.run = function () {
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');
  var graph = eles;

  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  });

  var roots = void 0;
  if (is.elementOrCollection(options.roots)) {
    roots = options.roots;
  } else if (is.array(options.roots)) {
    var rootsArray = [];

    for (var i = 0; i < options.roots.length; i++) {
      var id = options.roots[i];
      var ele = cy.getElementById(id);
      rootsArray.push(ele);
    }

    roots = cy.collection(rootsArray);
  } else if (is.string(options.roots)) {
    roots = cy.$(options.roots);
  } else {
    if (options.directed) {
      roots = nodes.roots();
    } else {
      var components = [];
      var unhandledNodes = nodes;

      var _loop = function _loop() {
        var currComp = cy.collection();

        eles.bfs({
          roots: unhandledNodes[0],
          visit: function visit(node, edge, pNode, i, depth) {
            currComp = currComp.add(node);
          },
          directed: false
        });

        unhandledNodes = unhandledNodes.not(currComp);
        components.push(currComp);
      };

      while (unhandledNodes.length > 0) {
        _loop();
      }

      roots = cy.collection();

      var _loop2 = function _loop2(_i) {
        var comp = components[_i];
        var maxDegree = comp.maxDegree(false);
        var compRoots = comp.filter(function (ele) {
          return ele.degree(false) === maxDegree;
        });

        roots = roots.add(compRoots);
      };

      for (var _i = 0; _i < components.length; _i++) {
        _loop2(_i);
      }
    }
  }

  var depths = [];
  var foundByBfs = {};
  var id2depth = {};
  var prevNode = {};
  var prevEdge = {};
  var successors = {};

  // find the depths of the nodes
  graph.bfs({
    roots: roots,
    directed: options.directed,
    visit: function visit(node, edge, pNode, i, depth) {
      var ele = node[0];
      var id = ele.id();

      if (!depths[depth]) {
        depths[depth] = [];
      }

      depths[depth].push(ele);
      foundByBfs[id] = true;
      id2depth[id] = depth;
      prevNode[id] = pNode;
      prevEdge[id] = edge;

      if (pNode) {
        var prevId = pNode.id();
        var succ = successors[prevId] = successors[prevId] || [];

        succ.push(node);
      }
    }
  });

  // check for nodes not found by bfs
  var orphanNodes = [];
  for (var _i2 = 0; _i2 < nodes.length; _i2++) {
    var _ele = nodes[_i2];

    if (foundByBfs[_ele.id()]) {
      continue;
    } else {
      orphanNodes.push(_ele);
    }
  }

  // assign orphan nodes a depth from their neighborhood
  var maxChecks = orphanNodes.length * 3;
  var checks = 0;
  while (orphanNodes.length !== 0 && checks < maxChecks) {
    var node = orphanNodes.shift();
    var neighbors = node.neighborhood().nodes();
    var assignedDepth = false;

    for (var _i3 = 0; _i3 < neighbors.length; _i3++) {
      var depth = id2depth[neighbors[_i3].id()];

      if (depth !== undefined) {
        depths[depth].push(node);
        assignedDepth = true;
        break;
      }
    }

    if (!assignedDepth) {
      orphanNodes.push(node);
    }

    checks++;
  }

  // assign orphan nodes that are still left to the depth of their subgraph
  while (orphanNodes.length !== 0) {
    var _node = orphanNodes.shift();
    //let subgraph = graph.bfs( node ).path;
    var _assignedDepth = false;

    // for( let i = 0; i < subgraph.length; i++ ){
    //   let depth = id2depth[ subgraph[i].id() ];

    //   if( depth !== undefined ){
    //     depths[depth].push( node );
    //     assignedDepth = true;
    //     break;
    //   }
    // }

    if (!_assignedDepth) {
      // worst case if the graph really isn't tree friendly, then just dump it in 0
      if (depths.length === 0) {
        depths.push([]);
      }

      depths[0].push(_node);
    }
  }

  // assign the nodes a depth and index
  var assignDepthsToEles = function assignDepthsToEles() {
    for (var _i4 = 0; _i4 < depths.length; _i4++) {
      var _eles = depths[_i4];

      for (var j = 0; j < _eles.length; j++) {
        var _ele2 = _eles[j];

        if (_ele2 == null) {
          _eles.splice(j, 1);
          j--;
          continue;
        }

        _ele2._private.scratch.breadthfirst = {
          depth: _i4,
          index: j
        };
      }
    }
  };
  assignDepthsToEles();

  var intersectsDepth = function intersectsDepth(node) {
    // returns true if has edges pointing in from a higher depth
    var edges = node.connectedEdges(function (ele) {
      return ele.data('target') === node.id();
    });
    var thisInfo = node._private.scratch.breadthfirst;
    var highestDepthOfOther = 0;
    var highestOther = void 0;
    for (var _i5 = 0; _i5 < edges.length; _i5++) {
      var edge = edges[_i5];
      var otherNode = edge.source()[0];
      var otherInfo = otherNode._private.scratch.breadthfirst;

      if (thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth) {
        highestDepthOfOther = otherInfo.depth;
        highestOther = otherNode;
      }
    }

    return highestOther;
  };

  // make maximal if so set by adjusting depths
  for (var adj = 0; adj < options.maximalAdjustments; adj++) {

    var nDepths = depths.length;
    var elesToMove = [];
    for (var _i6 = 0; _i6 < nDepths; _i6++) {
      var _depth = depths[_i6];

      var nDepth = _depth.length;
      for (var j = 0; j < nDepth; j++) {
        var _ele3 = _depth[j];
        var info = _ele3._private.scratch.breadthfirst;
        var intEle = intersectsDepth(_ele3);

        if (intEle) {
          info.intEle = intEle;
          elesToMove.push(_ele3);
        }
      }
    }

    for (var _i7 = 0; _i7 < elesToMove.length; _i7++) {
      var _ele4 = elesToMove[_i7];
      var _info = _ele4._private.scratch.breadthfirst;
      var _intEle = _info.intEle;
      var intInfo = _intEle._private.scratch.breadthfirst;

      depths[_info.depth][_info.index] = null; // remove from old depth & index (create hole to be cleaned)

      // add to end of new depth
      var newDepth = intInfo.depth + 1;
      while (newDepth > depths.length - 1) {
        depths.push([]);
      }
      depths[newDepth].push(_ele4);

      _info.depth = newDepth;
      _info.index = depths[newDepth].length - 1;
    }

    assignDepthsToEles();
  }

  // find min distance we need to leave between nodes
  var minDistance = 0;
  if (options.avoidOverlap) {
    for (var _i8 = 0; _i8 < nodes.length; _i8++) {
      var n = nodes[_i8];
      var nbb = n.layoutDimensions(options);
      var w = nbb.w;
      var h = nbb.h;

      minDistance = Math.max(minDistance, w, h);
    }
  }

  // get the weighted percent for an element based on its connectivity to other levels
  var cachedWeightedPercent = {};
  var getWeightedPercent = function getWeightedPercent(ele) {
    if (cachedWeightedPercent[ele.id()]) {
      return cachedWeightedPercent[ele.id()];
    }

    var eleDepth = ele._private.scratch.breadthfirst.depth;
    var neighbors = ele.neighborhood().nodes().not(':parent').intersection(nodes);
    var percent = 0;
    var samples = 0;

    for (var _i9 = 0; _i9 < neighbors.length; _i9++) {
      var neighbor = neighbors[_i9];
      var bf = neighbor._private.scratch.breadthfirst;
      var index = bf.index;
      var _depth2 = bf.depth;
      var _nDepth = depths[_depth2].length;

      if (eleDepth > _depth2 || eleDepth === 0) {
        // only get influenced by elements above
        percent += index / _nDepth;
        samples++;
      }
    }

    samples = Math.max(1, samples);
    percent = percent / samples;

    if (samples === 0) {
      // so lone nodes have a "don't care" state in sorting
      percent = undefined;
    }

    cachedWeightedPercent[ele.id()] = percent;
    return percent;
  };

  // rearrange the indices in each depth level based on connectivity

  var sortFn = function sortFn(a, b) {
    var apct = getWeightedPercent(a);
    var bpct = getWeightedPercent(b);

    return apct - bpct;
  };

  for (var times = 0; times < 3; times++) {
    // do it a few times b/c the depths are dynamic and we want a more stable result

    for (var _i10 = 0; _i10 < depths.length; _i10++) {
      depths[_i10] = depths[_i10].sort(sortFn);
    }
    assignDepthsToEles(); // and update
  }

  var biggestDepthSize = 0;
  for (var _i11 = 0; _i11 < depths.length; _i11++) {
    biggestDepthSize = Math.max(depths[_i11].length, biggestDepthSize);
  }

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.x1 + bb.h / 2
  };

  var getPosition = function getPosition(ele, isBottomDepth) {
    var info = ele._private.scratch.breadthfirst;
    var depth = info.depth;
    var index = info.index;
    var depthSize = depths[depth].length;

    var distanceX = Math.max(bb.w / (depthSize + 1), minDistance);
    var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);
    var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);
    radiusStepSize = Math.max(radiusStepSize, minDistance);

    if (!options.circle) {

      var epos = {
        x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
        y: (depth + 1) * distanceY
      };

      if (isBottomDepth) {
        return epos;
      }

      // let succs = successors[ ele.id() ];
      // if( succs ){
      //   epos.x = 0;
      //
      //   for( let i = 0 ; i < succs.length; i++ ){
      //     let spos = pos[ succs[i].id() ];
      //
      //     epos.x += spos.x;
      //   }
      //
      //   epos.x /= succs.length;
      // } else {
      //   //debugger;
      // }

      return epos;
    } else {
      if (options.circle) {
        var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);
        var theta = 2 * Math.PI / depths[depth].length * index;

        if (depth === 0 && depths[0].length === 1) {
          radius = 1;
        }

        return {
          x: center.x + radius * Math.cos(theta),
          y: center.y + radius * Math.sin(theta)
        };
      } else {
        return {
          x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
          y: (depth + 1) * distanceY
        };
      }
    }
  };

  // get positions in reverse depth order
  var pos = {};
  for (var _i12 = depths.length - 1; _i12 >= 0; _i12--) {
    var _depth3 = depths[_i12];

    for (var _j = 0; _j < _depth3.length; _j++) {
      var _node2 = _depth3[_j];

      pos[_node2.id()] = getPosition(_node2, _i12 === depths.length - 1);
    }
  }

  nodes.layoutPositions(this, options, function (node) {
    return pos[node.id()];
  });

  return this; // chaining
};

module.exports = BreadthFirstLayout;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var math = __webpack_require__(2);
var is = __webpack_require__(0);

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // the padding on fit
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
  nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  radius: undefined, // the radius of the circle
  startAngle: 3 / 2 * Math.PI, // where nodes start in radians
  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined, // callback on layoutready
  stop: undefined, // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 

};

function CircleLayout(options) {
  this.options = util.extend({}, defaults, options);
}

CircleLayout.prototype.run = function () {
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;

  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

  var nodes = eles.nodes().not(':parent');

  if (options.sort) {
    nodes = nodes.sort(options.sort);
  }

  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  });

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };

  var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;
  var dTheta = sweep / Math.max(1, nodes.length - 1);
  var r = void 0;

  var minDistance = 0;
  for (var i = 0; i < nodes.length; i++) {
    var n = nodes[i];
    var nbb = n.layoutDimensions(options);
    var w = nbb.w;
    var h = nbb.h;

    minDistance = Math.max(minDistance, w, h);
  }

  if (is.number(options.radius)) {
    r = options.radius;
  } else if (nodes.length <= 1) {
    r = 0;
  } else {
    r = Math.min(bb.h, bb.w) / 2 - minDistance;
  }

  // calculate the radius
  if (nodes.length > 1 && options.avoidOverlap) {
    // but only if more than one node (can't overlap)
    minDistance *= 1.75; // just to have some nice spacing

    var dcos = Math.cos(dTheta) - Math.cos(0);
    var dsin = Math.sin(dTheta) - Math.sin(0);
    var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping
    r = Math.max(rMin, r);
  }

  var getPos = function getPos(ele, i) {
    var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);

    var rx = r * Math.cos(theta);
    var ry = r * Math.sin(theta);
    var pos = {
      x: center.x + rx,
      y: center.y + ry
    };

    return pos;
  };

  nodes.layoutPositions(this, options, getPos);

  return this; // chaining
};

module.exports = CircleLayout;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var math = __webpack_require__(2);

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // the padding on fit
  startAngle: 3 / 2 * Math.PI, // where nodes start in radians
  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow
  minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
  height: undefined, // height of layout area (overrides container height)
  width: undefined, // width of layout area (overrides container width)
  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  concentric: function concentric(node) {
    // returns numeric value for each node, placing higher nodes in levels towards the centre
    return node.degree();
  },
  levelWidth: function levelWidth(nodes) {
    // the letiation of concentric values in each level
    return nodes.maxDegree() / 4;
  },
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined, // callback on layoutready
  stop: undefined, // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 
};

function ConcentricLayout(options) {
  this.options = util.extend({}, defaults, options);
}

ConcentricLayout.prototype.run = function () {
  var params = this.options;
  var options = params;

  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

  var cy = params.cy;

  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');

  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  });

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };

  var nodeValues = []; // { node, value }
  var theta = options.startAngle;
  var maxNodeSize = 0;

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var value = void 0;

    // calculate the node value
    value = options.concentric(node);
    nodeValues.push({
      value: value,
      node: node
    });

    // for style mapping
    node._private.scratch.concentric = value;
  }

  // in case we used the `concentric` in style
  nodes.updateStyle();

  // calculate max size now based on potentially updated mappers
  for (var _i = 0; _i < nodes.length; _i++) {
    var _node = nodes[_i];
    var nbb = _node.layoutDimensions(options);

    maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);
  }

  // sort node values in descreasing order
  nodeValues.sort(function (a, b) {
    return b.value - a.value;
  });

  var levelWidth = options.levelWidth(nodes);

  // put the values into levels
  var levels = [[]];
  var currentLevel = levels[0];
  for (var _i2 = 0; _i2 < nodeValues.length; _i2++) {
    var val = nodeValues[_i2];

    if (currentLevel.length > 0) {
      var diff = Math.abs(currentLevel[0].value - val.value);

      if (diff >= levelWidth) {
        currentLevel = [];
        levels.push(currentLevel);
      }
    }

    currentLevel.push(val);
  }

  // create positions from levels

  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

  if (!options.avoidOverlap) {
    // then strictly constrain to bb
    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
    var maxR = Math.min(bb.w, bb.h) / 2 - minDist;
    var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);

    minDist = Math.min(minDist, rStep);
  }

  // find the metrics for each level
  var r = 0;
  for (var _i3 = 0; _i3 < levels.length; _i3++) {
    var level = levels[_i3];
    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;
    var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1);

    // calculate the radius
    if (level.length > 1 && options.avoidOverlap) {
      // but only if more than one node (can't overlap)
      var dcos = Math.cos(dTheta) - Math.cos(0);
      var dsin = Math.sin(dTheta) - Math.sin(0);
      var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping

      r = Math.max(rMin, r);
    }

    level.r = r;

    r += minDist;
  }

  if (options.equidistant) {
    var rDeltaMax = 0;
    var _r = 0;

    for (var _i4 = 0; _i4 < levels.length; _i4++) {
      var _level = levels[_i4];
      var rDelta = _level.r - _r;

      rDeltaMax = Math.max(rDeltaMax, rDelta);
    }

    _r = 0;
    for (var _i5 = 0; _i5 < levels.length; _i5++) {
      var _level2 = levels[_i5];

      if (_i5 === 0) {
        _r = _level2.r;
      }

      _level2.r = _r;

      _r += rDeltaMax;
    }
  }

  // calculate the node positions
  var pos = {}; // id => position
  for (var _i6 = 0; _i6 < levels.length; _i6++) {
    var _level3 = levels[_i6];
    var _dTheta = _level3.dTheta;
    var _r2 = _level3.r;

    for (var j = 0; j < _level3.length; j++) {
      var _val = _level3[j];
      var _theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;

      var p = {
        x: center.x + _r2 * Math.cos(_theta),
        y: center.y + _r2 * Math.sin(_theta)
      };

      pos[_val.node.id()] = p;
    }
  }

  // position the nodes
  nodes.layoutPositions(this, options, function (ele) {
    var id = ele.id();

    return pos[id];
  });

  return this; // chaining
};

module.exports = ConcentricLayout;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
The CoSE layout was written by Gerardo Huck.
https://www.linkedin.com/in/gerardohuck/

Based on the following article:
http://dl.acm.org/citation.cfm?id=1498047

Modifications tracked on Github.
*/

var util = __webpack_require__(1);
var math = __webpack_require__(2);
var is = __webpack_require__(0);
var Promise = __webpack_require__(5);

var DEBUG;

/**
 * @brief :  default layout options
 */
var defaults = {
  // Called on `layoutready`
  ready: function ready() {},

  // Called on `layoutstop`
  stop: function stop() {},

  // Whether to animate while running the layout
  // true : Animate continuously as the layout is running
  // false : Just show the end result
  // 'end' : Animate with the end result, from the initial positions to the end positions
  animate: true,

  // Easing of the animation for animate:'end'
  animationEasing: undefined,

  // The duration of the animation for animate:'end'
  animationDuration: undefined,

  // A function that determines whether the node should be animated
  // All nodes animated by default on animate enabled
  // Non-animated nodes are positioned immediately when the layout starts
  animateFilter: function animateFilter(node, i) {
    return true;
  },

  // The layout animates only after this many milliseconds for animate:true
  // (prevents flashing on fast runs)
  animationThreshold: 250,

  // Number of iterations between consecutive screen positions update
  // (0 -> only updated on the end)
  refresh: 20,

  // Whether to fit the network view after when done
  fit: true,

  // Padding on fit
  padding: 30,

  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  boundingBox: undefined,

  // Excludes the label when calculating node bounding boxes for the layout algorithm
  nodeDimensionsIncludeLabels: false,

  // Randomize the initial positions of the nodes (true) or use existing positions (false)
  randomize: false,

  // Extra spacing between components in non-compound graphs
  componentSpacing: 40,

  // Node repulsion (non overlapping) multiplier
  nodeRepulsion: function nodeRepulsion(node) {
    return 2048;
  },

  // Node repulsion (overlapping) multiplier
  nodeOverlap: 4,

  // Ideal edge (non nested) length
  idealEdgeLength: function idealEdgeLength(edge) {
    return 32;
  },

  // Divisor to compute edge forces
  edgeElasticity: function edgeElasticity(edge) {
    return 32;
  },

  // Nesting factor (multiplier) to compute ideal edge length for nested edges
  nestingFactor: 1.2,

  // Gravity force (constant)
  gravity: 1,

  // Maximum number of iterations to perform
  numIter: 1000,

  // Initial temperature (maximum node displacement)
  initialTemp: 1000,

  // Cooling factor (how the temperature is reduced between consecutive iterations
  coolingFactor: 0.99,

  // Lower temperature threshold (below this point the layout will end)
  minTemp: 1.0,

  // Pass a reference to weaver to use threads for calculations
  weaver: false
};

/**
 * @brief       : constructor
 * @arg options : object containing layout options
 */
function CoseLayout(options) {
  this.options = util.extend({}, defaults, options);

  this.options.layout = this;
}

/**
 * @brief : runs the layout
 */
CoseLayout.prototype.run = function () {
  var options = this.options;
  var cy = options.cy;
  var layout = this;
  var thread = this.thread;
  var Thread = options.weaver ? options.weaver.Thread : null;

  var falseThread = { // use false thread as polyfill
    listeners: [],
    on: function on(e, cb) {
      this.listeners.push({ event: e, callback: cb });

      return this;
    },
    trigger: function trigger(e) {
      if (is.string(e)) {
        e = { type: e };
      }

      var matchesEvent = function matchesEvent(l) {
        return l.event === e.type;
      };
      var trigger = function trigger(l) {
        l.callback(e);
      };

      this.listeners.filter(matchesEvent).forEach(trigger);

      return this;
    },
    pass: function pass(data) {
      this.pass = data;

      return this;
    },
    run: function run(cb) {
      var pass = this.pass;

      return new Promise(function (resolve) {
        resolve(cb(pass));
      });
    },
    stop: function stop() {
      return this;
    }
  };

  function broadcast(message) {
    // for false thread
    var e = { type: 'message', message: message };

    falseThread.trigger(e);
  }

  if (!thread || thread.stopped()) {
    thread = this.thread = Thread ? new Thread() : falseThread;
  }

  layout.stopped = false;

  if (options.animate === true || options.animate === false) {
    layout.emit({ type: 'layoutstart', layout: layout });
  }

  // Set DEBUG - Global variable
  if (true === options.debug) {
    DEBUG = true;
  } else {
    DEBUG = false;
  }

  // Initialize layout info
  var layoutInfo = createLayoutInfo(cy, layout, options);

  // Show LayoutInfo contents if debugging
  if (DEBUG) {
    printLayoutInfo(layoutInfo);
  }

  // If required, randomize node positions
  if (options.randomize) {
    randomizePositions(layoutInfo, cy);
  }

  var startTime = Date.now();
  var refreshRequested = false;
  var refresh = function refresh(rOpts) {
    rOpts = rOpts || {};

    if (refreshRequested && !rOpts.next) {
      return;
    }

    if (!rOpts.force && Date.now() - startTime < options.animationThreshold) {
      return;
    }

    refreshRequested = true;

    util.requestAnimationFrame(function () {
      refreshPositions(layoutInfo, cy, options);

      // Fit the graph if necessary
      if (true === options.fit) {
        cy.fit(options.padding);
      }

      refreshRequested = false;

      if (rOpts.next) {
        rOpts.next();
      }
    });
  };

  thread.on('message', function (e) {
    var layoutNodes = e.message;

    layoutInfo.layoutNodes = layoutNodes;
    refresh();
  });

  thread.pass({
    layoutInfo: layoutInfo,
    options: {
      animate: options.animate,
      refresh: options.refresh,
      componentSpacing: options.componentSpacing,
      nodeOverlap: options.nodeOverlap,
      nestingFactor: options.nestingFactor,
      gravity: options.gravity,
      numIter: options.numIter,
      initialTemp: options.initialTemp,
      coolingFactor: options.coolingFactor,
      minTemp: options.minTemp
    }
  }).run(function (pass) {
    var layoutInfo = pass.layoutInfo;
    var options = pass.options;
    var stopped = false;

    /**
     * @brief          : Performs one iteration of the physical simulation
     * @arg layoutInfo : LayoutInfo object already initialized
     * @arg cy         : Cytoscape object
     * @arg options    : Layout options
     */
    var step = function step(layoutInfo, options, _step) {
      // var s = "\n\n###############################";
      // s += "\nSTEP: " + step;
      // s += "\n###############################\n";
      // logDebug(s);

      // Calculate node repulsions
      calculateNodeForces(layoutInfo, options);
      // Calculate edge forces
      calculateEdgeForces(layoutInfo, options);
      // Calculate gravity forces
      calculateGravityForces(layoutInfo, options);
      // Propagate forces from parent to child
      propagateForces(layoutInfo, options);
      // Update positions based on calculated forces
      updatePositions(layoutInfo, options);
    };

    /**
     * @brief : Computes the node repulsion forces
     */
    var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {
      // Go through each of the graphs in graphSet
      // Nodes only repel each other if they belong to the same graph
      // var s = 'calculateNodeForces';
      // logDebug(s);
      for (var i = 0; i < layoutInfo.graphSet.length; i++) {
        var graph = layoutInfo.graphSet[i];
        var numNodes = graph.length;

        // s = "Set: " + graph.toString();
        // logDebug(s);

        // Now get all the pairs of nodes
        // Only get each pair once, (A, B) = (B, A)
        for (var j = 0; j < numNodes; j++) {
          var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];

          for (var k = j + 1; k < numNodes; k++) {
            var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];

            nodeRepulsion(node1, node2, layoutInfo, options);
          }
        }
      }
    };

    var randomDistance = function randomDistance(max) {
      return -max + 2 * max * Math.random();
    };

    /**
     * @brief : Compute the node repulsion forces between a pair of nodes
     */
    var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {
      // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;

      var cmptId1 = node1.cmptId;
      var cmptId2 = node2.cmptId;

      if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {
        return;
      }

      // Get direction of line connecting both node centers
      var directionX = node2.positionX - node1.positionX;
      var directionY = node2.positionY - node1.positionY;
      var maxRandDist = 1;
      // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;

      // If both centers are the same, apply a random force
      if (0 === directionX && 0 === directionY) {
        directionX = randomDistance(maxRandDist);
        directionY = randomDistance(maxRandDist);
      }

      var overlap = nodesOverlap(node1, node2, directionX, directionY);

      if (overlap > 0) {
        // s += "\nNodes DO overlap.";
        // s += "\nOverlap: " + overlap;
        // If nodes overlap, repulsion force is proportional
        // to the overlap
        var force = options.nodeOverlap * overlap;

        // Compute the module and components of the force vector
        var distance = Math.sqrt(directionX * directionX + directionY * directionY);
        // s += "\nDistance: " + distance;
        var forceX = force * directionX / distance;
        var forceY = force * directionY / distance;
      } else {
        // s += "\nNodes do NOT overlap.";
        // If there's no overlap, force is inversely proportional
        // to squared distance

        // Get clipping points for both nodes
        var point1 = findClippingPoint(node1, directionX, directionY);
        var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);

        // Use clipping points to compute distance
        var distanceX = point2.x - point1.x;
        var distanceY = point2.y - point1.y;
        var distanceSqr = distanceX * distanceX + distanceY * distanceY;
        var distance = Math.sqrt(distanceSqr);
        // s += "\nDistance: " + distance;

        // Compute the module and components of the force vector
        var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;
        var forceX = force * distanceX / distance;
        var forceY = force * distanceY / distance;
      }

      // Apply force
      if (!node1.isLocked) {
        node1.offsetX -= forceX;
        node1.offsetY -= forceY;
      }

      if (!node2.isLocked) {
        node2.offsetX += forceX;
        node2.offsetY += forceY;
      }

      // s += "\nForceX: " + forceX + " ForceY: " + forceY;
      // logDebug(s);

      return;
    };

    /**
     * @brief  : Determines whether two nodes overlap or not
     * @return : Amount of overlapping (0 => no overlap)
     */
    var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {

      if (dX > 0) {
        var overlapX = node1.maxX - node2.minX;
      } else {
        var overlapX = node2.maxX - node1.minX;
      }

      if (dY > 0) {
        var overlapY = node1.maxY - node2.minY;
      } else {
        var overlapY = node2.maxY - node1.minY;
      }

      if (overlapX >= 0 && overlapY >= 0) {
        return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
      } else {
        return 0;
      }
    };

    /**
     * @brief : Finds the point in which an edge (direction dX, dY) intersects
     *          the rectangular bounding box of it's source/target node
     */
    var findClippingPoint = function findClippingPoint(node, dX, dY) {

      // Shorcuts
      var X = node.positionX;
      var Y = node.positionY;
      var H = node.height || 1;
      var W = node.width || 1;
      var dirSlope = dY / dX;
      var nodeSlope = H / W;

      // var s = 'Computing clipping point of node ' + node.id +
      //   " . Height:  " + H + ", Width: " + W +
      //   "\nDirection " + dX + ", " + dY;
      //
      // Compute intersection
      var res = {};

      // Case: Vertical direction (up)
      if (0 === dX && 0 < dY) {
        res.x = X;
        // s += "\nUp direction";
        res.y = Y + H / 2;

        return res;
      }

      // Case: Vertical direction (down)
      if (0 === dX && 0 > dY) {
        res.x = X;
        res.y = Y + H / 2;
        // s += "\nDown direction";

        return res;
      }

      // Case: Intersects the right border
      if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
        res.x = X + W / 2;
        res.y = Y + W * dY / 2 / dX;
        // s += "\nRightborder";

        return res;
      }

      // Case: Intersects the left border
      if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
        res.x = X - W / 2;
        res.y = Y - W * dY / 2 / dX;
        // s += "\nLeftborder";

        return res;
      }

      // Case: Intersects the top border
      if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
        res.x = X + H * dX / 2 / dY;
        res.y = Y + H / 2;
        // s += "\nTop border";

        return res;
      }

      // Case: Intersects the bottom border
      if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
        res.x = X - H * dX / 2 / dY;
        res.y = Y - H / 2;
        // s += "\nBottom border";

        return res;
      }

      // s += "\nClipping point found at " + res.x + ", " + res.y;
      // logDebug(s);
      return res;
    };

    /**
     * @brief : Calculates all edge forces
     */
    var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {
      // Iterate over all edges
      for (var i = 0; i < layoutInfo.edgeSize; i++) {
        // Get edge, source & target nodes
        var edge = layoutInfo.layoutEdges[i];
        var sourceIx = layoutInfo.idToIndex[edge.sourceId];
        var source = layoutInfo.layoutNodes[sourceIx];
        var targetIx = layoutInfo.idToIndex[edge.targetId];
        var target = layoutInfo.layoutNodes[targetIx];

        // Get direction of line connecting both node centers
        var directionX = target.positionX - source.positionX;
        var directionY = target.positionY - source.positionY;

        // If both centers are the same, do nothing.
        // A random force has already been applied as node repulsion
        if (0 === directionX && 0 === directionY) {
          continue;
        }

        // Get clipping points for both nodes
        var point1 = findClippingPoint(source, directionX, directionY);
        var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);

        var lx = point2.x - point1.x;
        var ly = point2.y - point1.y;
        var l = Math.sqrt(lx * lx + ly * ly);

        var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;

        if (0 !== l) {
          var forceX = force * lx / l;
          var forceY = force * ly / l;
        } else {
          var forceX = 0;
          var forceY = 0;
        }

        // Add this force to target and source nodes
        if (!source.isLocked) {
          source.offsetX += forceX;
          source.offsetY += forceY;
        }

        if (!target.isLocked) {
          target.offsetX -= forceX;
          target.offsetY -= forceY;
        }

        // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
        // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
        // logDebug(s);
      }
    };

    /**
     * @brief : Computes gravity forces for all nodes
     */
    var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {
      var distThreshold = 1;

      // var s = 'calculateGravityForces';
      // logDebug(s);
      for (var i = 0; i < layoutInfo.graphSet.length; i++) {
        var graph = layoutInfo.graphSet[i];
        var numNodes = graph.length;

        // s = "Set: " + graph.toString();
        // logDebug(s);

        // Compute graph center
        if (0 === i) {
          var centerX = layoutInfo.clientHeight / 2;
          var centerY = layoutInfo.clientWidth / 2;
        } else {
          // Get Parent node for this graph, and use its position as center
          var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
          var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
          var centerX = parent.positionX;
          var centerY = parent.positionY;
        }
        // s = "Center found at: " + centerX + ", " + centerY;
        // logDebug(s);

        // Apply force to all nodes in graph
        for (var j = 0; j < numNodes; j++) {
          var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
          // s = "Node: " + node.id;

          if (node.isLocked) {
            continue;
          }

          var dx = centerX - node.positionX;
          var dy = centerY - node.positionY;
          var d = Math.sqrt(dx * dx + dy * dy);
          if (d > distThreshold) {
            var fx = options.gravity * dx / d;
            var fy = options.gravity * dy / d;
            node.offsetX += fx;
            node.offsetY += fy;
            // s += ": Applied force: " + fx + ", " + fy;
          } else {}
            // s += ": skypped since it's too close to center";

            // logDebug(s);
        }
      }
    };

    /**
     * @brief          : This function propagates the existing offsets from
     *                   parent nodes to its descendents.
     * @arg layoutInfo : layoutInfo Object
     * @arg cy         : cytoscape Object
     * @arg options    : Layout options
     */
    var propagateForces = function propagateForces(layoutInfo, options) {
      // Inline implementation of a queue, used for traversing the graph in BFS order
      var queue = [];
      var start = 0; // Points to the start the queue
      var end = -1; // Points to the end of the queue

      // logDebug('propagateForces');

      // Start by visiting the nodes in the root graph
      queue.push.apply(queue, layoutInfo.graphSet[0]);
      end += layoutInfo.graphSet[0].length;

      // Traverse the graph, level by level,
      while (start <= end) {
        // Get the node to visit and remove it from queue
        var nodeId = queue[start++];
        var nodeIndex = layoutInfo.idToIndex[nodeId];
        var node = layoutInfo.layoutNodes[nodeIndex];
        var children = node.children;

        // We only need to process the node if it's compound
        if (0 < children.length && !node.isLocked) {
          var offX = node.offsetX;
          var offY = node.offsetY;

          // var s = "Propagating offset from parent node : " + node.id +
          //   ". OffsetX: " + offX + ". OffsetY: " + offY;
          // s += "\n Children: " + children.toString();
          // logDebug(s);

          for (var i = 0; i < children.length; i++) {
            var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];
            // Propagate offset
            childNode.offsetX += offX;
            childNode.offsetY += offY;
            // Add children to queue to be visited
            queue[++end] = children[i];
          }

          // Reset parent offsets
          node.offsetX = 0;
          node.offsetY = 0;
        }
      }
    };

    /**
     * @brief : Updates the layout model positions, based on
     *          the accumulated forces
     */
    var updatePositions = function updatePositions(layoutInfo, options) {
      // var s = 'Updating positions';
      // logDebug(s);

      // Reset boundaries for compound nodes
      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i];
        if (0 < n.children.length) {
          // logDebug("Resetting boundaries of compound node: " + n.id);
          n.maxX = undefined;
          n.minX = undefined;
          n.maxY = undefined;
          n.minY = undefined;
        }
      }

      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i];
        if (0 < n.children.length || n.isLocked) {
          // No need to set compound or locked node position
          // logDebug("Skipping position update of node: " + n.id);
          continue;
        }
        // s = "Node: " + n.id + " Previous position: (" +
        // n.positionX + ", " + n.positionY + ").";

        // Limit displacement in order to improve stability
        var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
        n.positionX += tempForce.x;
        n.positionY += tempForce.y;
        n.offsetX = 0;
        n.offsetY = 0;
        n.minX = n.positionX - n.width;
        n.maxX = n.positionX + n.width;
        n.minY = n.positionY - n.height;
        n.maxY = n.positionY + n.height;
        // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
        // logDebug(s);

        // Update ancestry boudaries
        updateAncestryBoundaries(n, layoutInfo);
      }

      // Update size, position of compund nodes
      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i];
        if (0 < n.children.length && !n.isLocked) {
          n.positionX = (n.maxX + n.minX) / 2;
          n.positionY = (n.maxY + n.minY) / 2;
          n.width = n.maxX - n.minX;
          n.height = n.maxY - n.minY;
          // s = "Updating position, size of compound node " + n.id;
          // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
          // s += "\nWidth: " + n.width + ", Height: " + n.height;
          // logDebug(s);
        }
      }
    };

    /**
     * @brief : Limits a force (forceX, forceY) to be not
     *          greater (in modulo) than max.
     8          Preserves force direction.
     */
    var limitForce = function limitForce(forceX, forceY, max) {
      // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
      var force = Math.sqrt(forceX * forceX + forceY * forceY);

      if (force > max) {
        var res = {
          x: max * forceX / force,
          y: max * forceY / force
        };
      } else {
        var res = {
          x: forceX,
          y: forceY
        };
      }

      // s += ".\nResult: (" + res.x + ", " + res.y + ")";
      // logDebug(s);

      return res;
    };

    /**
     * @brief : Function used for keeping track of compound node
     *          sizes, since they should bound all their subnodes.
     */
    var updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {
      // var s = "Propagating new position/size of node " + node.id;
      var parentId = node.parentId;
      if (null == parentId) {
        // If there's no parent, we are done
        // s += ". No parent node.";
        // logDebug(s);
        return;
      }

      // Get Parent Node
      var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
      var flag = false;

      // MaxX
      if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
        p.maxX = node.maxX + p.padRight;
        flag = true;
        // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
      }

      // MinX
      if (null == p.minX || node.minX - p.padLeft < p.minX) {
        p.minX = node.minX - p.padLeft;
        flag = true;
        // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
      }

      // MaxY
      if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
        p.maxY = node.maxY + p.padBottom;
        flag = true;
        // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
      }

      // MinY
      if (null == p.minY || node.minY - p.padTop < p.minY) {
        p.minY = node.minY - p.padTop;
        flag = true;
        // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
      }

      // If updated boundaries, propagate changes upward
      if (flag) {
        // logDebug(s);
        return updateAncestryBoundaries(p, layoutInfo);
      }

      // s += ". No changes in boundaries/position of parent node " + p.id;
      // logDebug(s);
      return;
    };

    var separateComponents = function separateComponents(layutInfo, options) {
      var nodes = layoutInfo.layoutNodes;
      var components = [];

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var cid = node.cmptId;
        var component = components[cid] = components[cid] || [];

        component.push(node);
      }

      var totalA = 0;

      for (var i = 0; i < components.length; i++) {
        var c = components[i];

        if (!c) {
          continue;
        }

        c.x1 = Infinity;
        c.x2 = -Infinity;
        c.y1 = Infinity;
        c.y2 = -Infinity;

        for (var j = 0; j < c.length; j++) {
          var n = c[j];

          c.x1 = Math.min(c.x1, n.positionX - n.width / 2);
          c.x2 = Math.max(c.x2, n.positionX + n.width / 2);
          c.y1 = Math.min(c.y1, n.positionY - n.height / 2);
          c.y2 = Math.max(c.y2, n.positionY + n.height / 2);
        }

        c.w = c.x2 - c.x1;
        c.h = c.y2 - c.y1;

        totalA += c.w * c.h;
      }

      components.sort(function (c1, c2) {
        return c2.w * c2.h - c1.w * c1.h;
      });

      var x = 0;
      var y = 0;
      var usedW = 0;
      var rowH = 0;
      var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;

      for (var i = 0; i < components.length; i++) {
        var c = components[i];

        if (!c) {
          continue;
        }

        for (var j = 0; j < c.length; j++) {
          var n = c[j];

          if (!n.isLocked) {
            n.positionX += x;
            n.positionY += y;
          }
        }

        x += c.w + options.componentSpacing;
        usedW += c.w + options.componentSpacing;
        rowH = Math.max(rowH, c.h);

        if (usedW > maxRowW) {
          y += rowH + options.componentSpacing;
          x = 0;
          usedW = 0;
          rowH = 0;
        }
      }
    };

    var mainLoop = function mainLoop(i) {
      if (stopped) {
        // logDebug("Layout manually stopped. Stopping computation in step " + i);
        return false;
      }

      // Do one step in the phisical simulation
      step(layoutInfo, options, i);

      // Update temperature
      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;
      // logDebug("New temperature: " + layoutInfo.temperature);

      if (layoutInfo.temperature < options.minTemp) {
        // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
        return false;
      }

      return true;
    };

    var i = 0;
    var loopRet;

    do {
      var f = 0;

      while (f < options.refresh && i < options.numIter) {
        var loopRet = mainLoop(i);
        if (!loopRet) {
          break;
        }

        f++;
        i++;
      }

      if (options.animate === true) {
        broadcast(layoutInfo.layoutNodes); // eslint-disable-line no-undef
      }
    } while (loopRet && i + 1 < options.numIter);

    separateComponents(layoutInfo, options);

    return layoutInfo;
  }).then(function (layoutInfoUpdated) {
    layoutInfo.layoutNodes = layoutInfoUpdated.layoutNodes; // get the positions

    thread.stop();
    done();
  });

  var done = function done() {
    if (options.animate === true || options.animate === false) {
      refresh({
        force: true,
        next: function next() {
          // Layout has finished
          layout.one('layoutstop', options.stop);
          layout.emit({ type: 'layoutstop', layout: layout });
        }
      });
    } else {
      options.eles.nodes().layoutPositions(layout, options, function (node) {
        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];

        return { x: lnode.positionX, y: lnode.positionY };
      });
    }
  };

  return this; // chaining
};

/**
 * @brief : called on continuous layouts to stop them before they finish
 */
CoseLayout.prototype.stop = function () {
  this.stopped = true;

  if (this.thread) {
    this.thread.stop();
  }

  this.emit('layoutstop');

  return this; // chaining
};

CoseLayout.prototype.destroy = function () {
  if (this.thread) {
    this.thread.stop();
  }

  return this; // chaining
};

/**
 * @brief     : Creates an object which is contains all the data
 *              used in the layout process
 * @arg cy    : cytoscape.js object
 * @return    : layoutInfo object initialized
 */
var createLayoutInfo = function createLayoutInfo(cy, layout, options) {
  // Shortcut
  var edges = options.eles.edges();
  var nodes = options.eles.nodes();

  var layoutInfo = {
    isCompound: cy.hasCompoundNodes(),
    layoutNodes: [],
    idToIndex: {},
    nodeSize: nodes.size(),
    graphSet: [],
    indexToGraph: [],
    layoutEdges: [],
    edgeSize: edges.size(),
    temperature: options.initialTemp,
    clientWidth: cy.width(),
    clientHeight: cy.width(),
    boundingBox: math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    })
  };

  var components = options.eles.components();
  var id2cmptId = {};

  for (var i = 0; i < components.length; i++) {
    var component = components[i];

    for (var j = 0; j < component.length; j++) {
      var node = component[j];

      id2cmptId[node.id()] = i;
    }
  }

  // Iterate over all nodes, creating layout nodes
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = nodes[i];
    var nbb = n.layoutDimensions(options);

    var tempNode = {};
    tempNode.isLocked = n.locked();
    tempNode.id = n.data('id');
    tempNode.parentId = n.data('parent');
    tempNode.cmptId = id2cmptId[n.id()];
    tempNode.children = [];
    tempNode.positionX = n.position('x');
    tempNode.positionY = n.position('y');
    tempNode.offsetX = 0;
    tempNode.offsetY = 0;
    tempNode.height = nbb.w;
    tempNode.width = nbb.h;
    tempNode.maxX = tempNode.positionX + tempNode.width / 2;
    tempNode.minX = tempNode.positionX - tempNode.width / 2;
    tempNode.maxY = tempNode.positionY + tempNode.height / 2;
    tempNode.minY = tempNode.positionY - tempNode.height / 2;
    tempNode.padLeft = parseFloat(n.style('padding'));
    tempNode.padRight = parseFloat(n.style('padding'));
    tempNode.padTop = parseFloat(n.style('padding'));
    tempNode.padBottom = parseFloat(n.style('padding'));

    // forces
    tempNode.nodeRepulsion = is.fn(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion;

    // Add new node
    layoutInfo.layoutNodes.push(tempNode);
    // Add entry to id-index map
    layoutInfo.idToIndex[tempNode.id] = i;
  }

  // Inline implementation of a queue, used for traversing the graph in BFS order
  var queue = [];
  var start = 0; // Points to the start the queue
  var end = -1; // Points to the end of the queue

  var tempGraph = [];

  // Second pass to add child information and
  // initialize queue for hierarchical traversal
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];
    var p_id = n.parentId;
    // Check if node n has a parent node
    if (null != p_id) {
      // Add node Id to parent's list of children
      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
    } else {
      // If a node doesn't have a parent, then it's in the root graph
      queue[++end] = n.id;
      tempGraph.push(n.id);
    }
  }

  // Add root graph to graphSet
  layoutInfo.graphSet.push(tempGraph);

  // Traverse the graph, level by level,
  while (start <= end) {
    // Get the node to visit and remove it from queue
    var node_id = queue[start++];
    var node_ix = layoutInfo.idToIndex[node_id];
    var node = layoutInfo.layoutNodes[node_ix];
    var children = node.children;
    if (children.length > 0) {
      // Add children nodes as a new graph to graph set
      layoutInfo.graphSet.push(children);
      // Add children to que queue to be visited
      for (var i = 0; i < children.length; i++) {
        queue[++end] = children[i];
      }
    }
  }

  // Create indexToGraph map
  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
    var graph = layoutInfo.graphSet[i];
    for (var j = 0; j < graph.length; j++) {
      var index = layoutInfo.idToIndex[graph[j]];
      layoutInfo.indexToGraph[index] = i;
    }
  }

  // Iterate over all edges, creating Layout Edges
  for (var i = 0; i < layoutInfo.edgeSize; i++) {
    var e = edges[i];
    var tempEdge = {};
    tempEdge.id = e.data('id');
    tempEdge.sourceId = e.data('source');
    tempEdge.targetId = e.data('target');

    // Compute ideal length
    var idealLength = is.fn(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;
    var elasticity = is.fn(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity;

    // Check if it's an inter graph edge
    var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];
    var targetIx = layoutInfo.idToIndex[tempEdge.targetId];
    var sourceGraph = layoutInfo.indexToGraph[sourceIx];
    var targetGraph = layoutInfo.indexToGraph[targetIx];

    if (sourceGraph != targetGraph) {
      // Find lowest common graph ancestor
      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);

      // Compute sum of node depths, relative to lca graph
      var lcaGraph = layoutInfo.graphSet[lca];
      var depth = 0;

      // Source depth
      var tempNode = layoutInfo.layoutNodes[sourceIx];
      while (-1 === lcaGraph.indexOf(tempNode.id)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      // Target depth
      tempNode = layoutInfo.layoutNodes[targetIx];
      while (-1 === lcaGraph.indexOf(tempNode.id)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
      //  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
      //  ". Depth: " + depth);

      // Update idealLength
      idealLength *= depth * options.nestingFactor;
    }

    tempEdge.idealLength = idealLength;
    tempEdge.elasticity = elasticity;

    layoutInfo.layoutEdges.push(tempEdge);
  }

  // Finally, return layoutInfo object
  return layoutInfo;
};

/**
 * @brief : This function finds the index of the lowest common
 *          graph ancestor between 2 nodes in the subtree
 *          (from the graph hierarchy induced tree) whose
 *          root is graphIx
 *
 * @arg node1: node1's ID
 * @arg node2: node2's ID
 * @arg layoutInfo: layoutInfo object
 *
 */
var findLCA = function findLCA(node1, node2, layoutInfo) {
  // Find their common ancester, starting from the root graph
  var res = findLCA_aux(node1, node2, 0, layoutInfo);
  if (2 > res.count) {
    // If aux function couldn't find the common ancester,
    // then it is the root graph
    return 0;
  } else {
    return res.graph;
  }
};

/**
 * @brief          : Auxiliary function used for LCA computation
 *
 * @arg node1      : node1's ID
 * @arg node2      : node2's ID
 * @arg graphIx    : subgraph index
 * @arg layoutInfo : layoutInfo object
 *
 * @return         : object of the form {count: X, graph: Y}, where:
 *                   X is the number of ancesters (max: 2) found in
 *                   graphIx (and it's subgraphs),
 *                   Y is the graph index of the lowest graph containing
 *                   all X nodes
 */
var findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {
  var graph = layoutInfo.graphSet[graphIx];
  // If both nodes belongs to graphIx
  if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {
    return { count: 2, graph: graphIx };
  }

  // Make recursive calls for all subgraphs
  var c = 0;
  for (var i = 0; i < graph.length; i++) {
    var nodeId = graph[i];
    var nodeIx = layoutInfo.idToIndex[nodeId];
    var children = layoutInfo.layoutNodes[nodeIx].children;

    // If the node has no child, skip it
    if (0 === children.length) {
      continue;
    }

    var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
    var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);
    if (0 === result.count) {
      // Neither node1 nor node2 are present in this subgraph
      continue;
    } else if (1 === result.count) {
      // One of (node1, node2) is present in this subgraph
      c++;
      if (2 === c) {
        // We've already found both nodes, no need to keep searching
        break;
      }
    } else {
      // Both nodes are present in this subgraph
      return result;
    }
  }

  return { count: c, graph: graphIx };
};

/**
 * @brief: printsLayoutInfo into js console
 *         Only used for debbuging
 */
var printLayoutInfo = function printLayoutInfo(layoutInfo) {
  /* eslint-disable */

  if (!DEBUG) {
    return;
  }
  console.debug('layoutNodes:');
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];
    var s = '\nindex: ' + i + '\nId: ' + n.id + '\nChildren: ' + n.children.toString() + '\nparentId: ' + n.parentId + '\npositionX: ' + n.positionX + '\npositionY: ' + n.positionY + '\nOffsetX: ' + n.offsetX + '\nOffsetY: ' + n.offsetY + '\npadLeft: ' + n.padLeft + '\npadRight: ' + n.padRight + '\npadTop: ' + n.padTop + '\npadBottom: ' + n.padBottom;

    console.debug(s);
  }

  console.debug('idToIndex');
  for (var i in layoutInfo.idToIndex) {
    console.debug('Id: ' + i + '\nIndex: ' + layoutInfo.idToIndex[i]);
  }

  console.debug('Graph Set');
  var set = layoutInfo.graphSet;
  for (var i = 0; i < set.length; i++) {
    console.debug('Set : ' + i + ': ' + set[i].toString());
  }

  var s = 'IndexToGraph';
  for (var i = 0; i < layoutInfo.indexToGraph.length; i++) {
    s += '\nIndex : ' + i + ' Graph: ' + layoutInfo.indexToGraph[i];
  }
  console.debug(s);

  s = 'Layout Edges';
  for (var i = 0; i < layoutInfo.layoutEdges.length; i++) {
    var e = layoutInfo.layoutEdges[i];
    s += '\nEdge Index: ' + i + ' ID: ' + e.id + ' SouceID: ' + e.sourceId + ' TargetId: ' + e.targetId + ' Ideal Length: ' + e.idealLength;
  }
  console.debug(s);

  s = 'nodeSize: ' + layoutInfo.nodeSize;
  s += '\nedgeSize: ' + layoutInfo.edgeSize;
  s += '\ntemperature: ' + layoutInfo.temperature;
  console.debug(s);

  return;
  /* eslint-enable */
};

/**
 * @brief : Randomizes the position of all nodes
 */
var randomizePositions = function randomizePositions(layoutInfo, cy) {
  var width = layoutInfo.clientWidth;
  var height = layoutInfo.clientHeight;

  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];

    // No need to randomize compound nodes or locked nodes
    if (0 === n.children.length && !n.isLocked) {
      n.positionX = Math.random() * width;
      n.positionY = Math.random() * height;
    }
  }
};

/**
 * @brief          : Updates the positions of nodes in the network
 * @arg layoutInfo : LayoutInfo object
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */
var refreshPositions = function refreshPositions(layoutInfo, cy, options) {
  // var s = 'Refreshing positions';
  // logDebug(s);

  var layout = options.layout;
  var nodes = options.eles.nodes();
  var bb = layoutInfo.boundingBox;
  var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };

  if (options.boundingBox) {
    nodes.forEach(function (node) {
      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];

      coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);
      coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);

      coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);
      coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);
    });

    coseBB.w = coseBB.x2 - coseBB.x1;
    coseBB.h = coseBB.y2 - coseBB.y1;
  }

  nodes.positions(function (ele, i) {
    var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];
    // s = "Node: " + lnode.id + ". Refreshed position: (" +
    // lnode.positionX + ", " + lnode.positionY + ").";
    // logDebug(s);

    if (options.boundingBox) {
      // then add extra bounding box constraint
      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;

      return {
        x: bb.x1 + pctX * bb.w,
        y: bb.y1 + pctY * bb.h
      };
    } else {
      return {
        x: lnode.positionX,
        y: lnode.positionY
      };
    }
  });

  // Trigger layoutReady only on first call
  if (true !== layoutInfo.ready) {
    // s = 'Triggering layoutready';
    // logDebug(s);
    layoutInfo.ready = true;
    layout.one('layoutready', options.ready);
    layout.emit({ type: 'layoutready', layout: this });
  }
};

/**
 * @brief : Logs a debug message in JS console, if DEBUG is ON
 */
// var logDebug = function(text) {
//   if (DEBUG) {
//     console.debug(text);
//   }
// };

module.exports = CoseLayout;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var math = __webpack_require__(2);

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // padding used on fit
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true
  nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  condense: false, // uses all available space on false, uses minimal space on true
  rows: undefined, // force num of rows in the grid
  cols: undefined, // force num of columns in the grid
  position: function position(node) {}, // returns { row, col } for element
  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined, // callback on layoutready
  stop: undefined, // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 
};

function GridLayout(options) {
  this.options = util.extend({}, defaults, options);
}

GridLayout.prototype.run = function () {
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');

  if (options.sort) {
    nodes = nodes.sort(options.sort);
  }

  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  });

  if (bb.h === 0 || bb.w === 0) {
    nodes.layoutPositions(this, options, function (ele) {
      return { x: bb.x1, y: bb.y1 };
    });
  } else {

    // width/height * splits^2 = cells where splits is number of times to split width
    var cells = nodes.size();
    var splits = Math.sqrt(cells * bb.h / bb.w);
    var rows = Math.round(splits);
    var cols = Math.round(bb.w / bb.h * splits);

    var small = function small(val) {
      if (val == null) {
        return Math.min(rows, cols);
      } else {
        var min = Math.min(rows, cols);
        if (min == rows) {
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var large = function large(val) {
      if (val == null) {
        return Math.max(rows, cols);
      } else {
        var max = Math.max(rows, cols);
        if (max == rows) {
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var oRows = options.rows;
    var oCols = options.cols != null ? options.cols : options.columns;

    // if rows or columns were set in options, use those values
    if (oRows != null && oCols != null) {
      rows = oRows;
      cols = oCols;
    } else if (oRows != null && oCols == null) {
      rows = oRows;
      cols = Math.ceil(cells / rows);
    } else if (oRows == null && oCols != null) {
      cols = oCols;
      rows = Math.ceil(cells / cols);
    }

    // otherwise use the automatic values and adjust accordingly

    // if rounding was up, see if we can reduce rows or columns
    else if (cols * rows > cells) {
        var sm = small();
        var lg = large();

        // reducing the small side takes away the most cells, so try it first
        if ((sm - 1) * lg >= cells) {
          small(sm - 1);
        } else if ((lg - 1) * sm >= cells) {
          large(lg - 1);
        }
      } else {

        // if rounding was too low, add rows or columns
        while (cols * rows < cells) {
          var _sm = small();
          var _lg = large();

          // try to add to larger side first (adds less in multiplication)
          if ((_lg + 1) * _sm >= cells) {
            large(_lg + 1);
          } else {
            small(_sm + 1);
          }
        }
      }

    var cellWidth = bb.w / cols;
    var cellHeight = bb.h / rows;

    if (options.condense) {
      cellWidth = 0;
      cellHeight = 0;
    }

    if (options.avoidOverlap) {
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var pos = node._private.position;

        if (pos.x == null || pos.y == null) {
          // for bb
          pos.x = 0;
          pos.y = 0;
        }

        var nbb = node.layoutDimensions(options);
        var p = options.avoidOverlapPadding;

        var w = nbb.w + p;
        var h = nbb.h + p;

        cellWidth = Math.max(cellWidth, w);
        cellHeight = Math.max(cellHeight, h);
      }
    }

    var cellUsed = {}; // e.g. 'c-0-2' => true

    var used = function used(row, col) {
      return cellUsed['c-' + row + '-' + col] ? true : false;
    };

    var use = function use(row, col) {
      cellUsed['c-' + row + '-' + col] = true;
    };

    // to keep track of current cell position
    var row = 0;
    var col = 0;
    var moveToNextCell = function moveToNextCell() {
      col++;
      if (col >= cols) {
        col = 0;
        row++;
      }
    };

    // get a cache of all the manual positions
    var id2manPos = {};
    for (var _i = 0; _i < nodes.length; _i++) {
      var _node = nodes[_i];
      var rcPos = options.position(_node);

      if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {
        // must have at least row or col def'd
        var _pos = {
          row: rcPos.row,
          col: rcPos.col
        };

        if (_pos.col === undefined) {
          // find unused col
          _pos.col = 0;

          while (used(_pos.row, _pos.col)) {
            _pos.col++;
          }
        } else if (_pos.row === undefined) {
          // find unused row
          _pos.row = 0;

          while (used(_pos.row, _pos.col)) {
            _pos.row++;
          }
        }

        id2manPos[_node.id()] = _pos;
        use(_pos.row, _pos.col);
      }
    }

    var getPos = function getPos(element, i) {
      var x = void 0,
          y = void 0;

      if (element.locked() || element.isParent()) {
        return false;
      }

      // see if we have a manual position set
      var rcPos = id2manPos[element.id()];
      if (rcPos) {
        x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;
        y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;
      } else {
        // otherwise set automatically

        while (used(row, col)) {
          moveToNextCell();
        }

        x = col * cellWidth + cellWidth / 2 + bb.x1;
        y = row * cellHeight + cellHeight / 2 + bb.y1;
        use(row, col);

        moveToNextCell();
      }

      return { x: x, y: y };
    };

    nodes.layoutPositions(this, options, getPos);
  }

  return this; // chaining
};

module.exports = GridLayout;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [{ name: 'breadthfirst', impl: __webpack_require__(77) }, { name: 'circle', impl: __webpack_require__(78) }, { name: 'concentric', impl: __webpack_require__(79) }, { name: 'cose', impl: __webpack_require__(80) }, { name: 'grid', impl: __webpack_require__(81) }, { name: 'null', impl: __webpack_require__(83) }, { name: 'preset', impl: __webpack_require__(84) }, { name: 'random', impl: __webpack_require__(85) }];

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

// default layout options
var defaults = {
  ready: function ready() {}, // on layoutready
  stop: function stop() {} // on layoutstop
};

// constructor
// options : object containing layout options
function NullLayout(options) {
  this.options = util.extend({}, defaults, options);
}

// runs the layout
NullLayout.prototype.run = function () {
  var options = this.options;
  var eles = options.eles; // elements to consider in the layout
  var layout = this;

  // cy is automatically populated for us in the constructor
  var cy = options.cy; // jshint ignore:line

  layout.emit('layoutstart');

  // puts all nodes at (0, 0)
  eles.nodes().positions(function () {
    return {
      x: 0,
      y: 0
    };
  });

  // trigger layoutready when each node has had its position set at least once
  layout.one('layoutready', options.ready);
  layout.emit('layoutready');

  // trigger layoutstop when the layout stops (e.g. finishes)
  layout.one('layoutstop', options.stop);
  layout.emit('layoutstop');

  return this; // chaining
};

// called on continuous layouts to stop them before they finish
NullLayout.prototype.stop = function () {
  return this; // chaining
};

module.exports = NullLayout;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);

var defaults = {
  positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }
  zoom: undefined, // the zoom level to set (prob want fit = false if set)
  pan: undefined, // the pan level to set (prob want fit = false if set)
  fit: true, // whether to fit to viewport
  padding: 30, // padding on fit
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined, // callback on layoutready
  stop: undefined, // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 
};

function PresetLayout(options) {
  this.options = util.extend({}, defaults, options);
}

PresetLayout.prototype.run = function () {
  var options = this.options;
  var eles = options.eles;

  var nodes = eles.nodes();
  var posIsFn = is.fn(options.positions);

  function getPosition(node) {
    if (options.positions == null) {
      return null;
    }

    if (posIsFn) {
      return options.positions(node);
    }

    var pos = options.positions[node._private.data.id];

    if (pos == null) {
      return null;
    }

    return pos;
  }

  nodes.layoutPositions(this, options, function (node, i) {
    var position = getPosition(node);

    if (node.locked() || position == null) {
      return false;
    }

    return position;
  });

  return this; // chaining
};

module.exports = PresetLayout;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var math = __webpack_require__(2);

var defaults = {
  fit: true, // whether to fit to viewport
  padding: 30, // fit padding
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined, // callback on layoutready
  stop: undefined, // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 
};

function RandomLayout(options) {
  this.options = util.extend({}, defaults, options);
}

RandomLayout.prototype.run = function () {
  var options = this.options;
  var cy = options.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');

  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  });

  var getPos = function getPos(node, i) {
    return {
      x: bb.x1 + Math.round(Math.random() * bb.w),
      y: bb.y1 + Math.round(Math.random() * bb.h)
    };
  };

  nodes.layoutPositions(this, options, getPos);

  return this; // chaining
};

module.exports = RandomLayout;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);
var is = __webpack_require__(0);
var util = __webpack_require__(1);

var BRp = {};

BRp.arrowShapeWidth = 0.3;

BRp.registerArrowShapes = function () {
  var arrowShapes = this.arrowShapes = {};
  var renderer = this;

  // Contract for arrow shapes:
  // 0, 0 is arrow tip
  // (0, 1) is direction towards node
  // (1, 0) is right
  //
  // functional api:
  // collide: check x, y in shape
  // roughCollide: called before collide, no false negatives
  // draw: draw
  // spacing: dist(arrowTip, nodeBoundary)
  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

  var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {
    var x1 = translation.x - size / 2 - padding;
    var x2 = translation.x + size / 2 + padding;
    var y1 = translation.y - size / 2 - padding;
    var y2 = translation.y + size / 2 + padding;

    var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;

    return inside;
  };

  var transform = function transform(x, y, size, angle, translation) {
    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);

    var xScaled = xRotated * size;
    var yScaled = yRotated * size;

    var xTranslated = xScaled + translation.x;
    var yTranslated = yScaled + translation.y;

    return {
      x: xTranslated,
      y: yTranslated
    };
  };

  var transformPoints = function transformPoints(pts, size, angle, translation) {
    var retPts = [];

    for (var i = 0; i < pts.length; i += 2) {
      var x = pts[i];
      var y = pts[i + 1];

      retPts.push(transform(x, y, size, angle, translation));
    }

    return retPts;
  };

  var pointsToArr = function pointsToArr(pts) {
    var ret = [];

    for (var i = 0; i < pts.length; i++) {
      var p = pts[i];

      ret.push(p.x, p.y);
    }

    return ret;
  };

  var standardGap = function standardGap(edge) {
    return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;
  };

  var defineArrowShape = function defineArrowShape(name, defn) {
    if (is.string(defn)) {
      defn = arrowShapes[defn];
    }

    arrowShapes[name] = util.extend({
      name: name,

      points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],

      collide: function collide(x, y, size, angle, translation, padding) {
        var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
        var inside = math.pointInsidePolygonPoints(x, y, points);

        return inside;
      },

      roughCollide: bbCollide,

      draw: function draw(context, size, angle, translation) {
        var points = transformPoints(this.points, size, angle, translation);

        renderer.arrowShapeImpl('polygon')(context, points);
      },

      spacing: function spacing(edge) {
        return 0;
      },

      gap: standardGap
    }, defn);
  };

  defineArrowShape('none', {
    collide: util.falsify,

    roughCollide: util.falsify,

    draw: util.noop,

    spacing: util.zeroify,

    gap: util.zeroify
  });

  defineArrowShape('triangle', {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3]
  });

  defineArrowShape('arrow', 'triangle');

  defineArrowShape('triangle-backcurve', {
    points: arrowShapes['triangle'].points,

    controlPoint: [0, -0.15],

    roughCollide: bbCollide,

    draw: function draw(context, size, angle, translation, edgeWidth) {
      var ptsTrans = transformPoints(this.points, size, angle, translation);
      var ctrlPt = this.controlPoint;
      var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);

      renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);
    },

    gap: function gap(edge) {
      return standardGap(edge) * 0.985;
    }
  });

  defineArrowShape('triangle-tee', {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, -0.15, -0.3],

    pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],

    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
      var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));

      var inside = math.pointInsidePolygonPoints(x, y, triPts) || math.pointInsidePolygonPoints(x, y, teePts);

      return inside;
    },

    draw: function draw(context, size, angle, translation, edgeWidth) {
      var triPts = transformPoints(this.points, size, angle, translation);
      var teePts = transformPoints(this.pointsTee, size, angle, translation);

      renderer.arrowShapeImpl(this.name)(context, triPts, teePts);
    }
  });

  defineArrowShape('triangle-cross', {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, -0.15, -0.3],

    baseCrossLinePts: [-0.15, -0.4, // first half of the rectangle
    -0.15, -0.4, 0.15, -0.4, // second half of the rectangle
    0.15, -0.4],

    crossLinePts: function crossLinePts(size, edgeWidth) {
      // shift points so that the distance between the cross points matches edge width
      var p = this.baseCrossLinePts.slice();
      var shiftFactor = edgeWidth / size;
      var y0 = 3;
      var y1 = 5;

      p[y0] = p[y0] - shiftFactor;
      p[y1] = p[y1] - shiftFactor;

      return p;
    },

    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
      var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));
      var inside = math.pointInsidePolygonPoints(x, y, triPts) || math.pointInsidePolygonPoints(x, y, teePts);

      return inside;
    },

    draw: function draw(context, size, angle, translation, edgeWidth) {
      var triPts = transformPoints(this.points, size, angle, translation);
      var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);

      renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);
    }
  });

  defineArrowShape('vee', {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],

    gap: function gap(edge) {
      return standardGap(edge) * 0.985;
    }
  });

  defineArrowShape('circle', {
    radius: 0.15,

    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
      var t = translation;
      var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);

      return inside;
    },

    draw: function draw(context, size, angle, translation, edgeWidth) {
      renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);
    },

    spacing: function spacing(edge) {
      return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;
    }
  });

  defineArrowShape('tee', {
    points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],

    spacing: function spacing(edge) {
      return 1;
    },

    gap: function gap(edge) {
      return 1;
    }
  });

  defineArrowShape('square', {
    points: [-0.15, 0.00, 0.15, 0.00, 0.15, -0.3, -0.15, -0.3]
  });

  defineArrowShape('diamond', {
    points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],

    gap: function gap(edge) {
      return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;
    }
  });
};

module.exports = BRp;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var window = __webpack_require__(4);
var math = __webpack_require__(2);
var util = __webpack_require__(1);
var window = __webpack_require__(4);

var BRp = {};

// Project mouse
BRp.projectIntoViewport = function (clientX, clientY) {
  var cy = this.cy;
  var offsets = this.findContainerClientCoords();
  var offsetLeft = offsets[0];
  var offsetTop = offsets[1];
  var scale = offsets[4];
  var pan = cy.pan();
  var zoom = cy.zoom();

  var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;
  var y = ((clientY - offsetTop) / scale - pan.y) / zoom;

  return [x, y];
};

BRp.findContainerClientCoords = function () {
  if (this.containerBB) {
    return this.containerBB;
  }

  var container = this.container;
  var rect = container.getBoundingClientRect();
  var style = window.getComputedStyle(container);
  var styleValue = function styleValue(name) {
    return parseFloat(style.getPropertyValue(name));
  };

  var padding = {
    left: styleValue('padding-left'),
    right: styleValue('padding-right'),
    top: styleValue('padding-top'),
    bottom: styleValue('padding-bottom')
  };

  var border = {
    left: styleValue('border-left-width'),
    right: styleValue('border-right-width'),
    top: styleValue('border-top-width'),
    bottom: styleValue('border-bottom-width')
  };

  var clientWidth = container.clientWidth;
  var clientHeight = container.clientHeight;

  var paddingHor = padding.left + padding.right;
  var paddingVer = padding.top + padding.bottom;

  var borderHor = border.left + border.right;
  var borderVer = border.top + border.bottom;

  var scale = rect.width / (clientWidth + borderHor);

  var unscaledW = clientWidth - paddingHor;
  var unscaledH = clientHeight - paddingVer;

  var scaledW = rect.width - (paddingHor + borderHor) * scale;
  var scaledH = rect.height - (paddingVer + borderVer) * scale;

  var left = rect.left + padding.left + border.left;
  var top = rect.top + padding.top + border.top;

  return this.containerBB = [left, top, unscaledW, unscaledH, scale];
};

BRp.invalidateContainerClientCoordsCache = function () {
  this.containerBB = null;
};

BRp.findNearestElement = function (x, y, interactiveElementsOnly, isTouch) {
  return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];
};

BRp.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {
  var self = this;
  var r = this;
  var eles = r.getCachedZSortedEles();
  var near = []; // 1 node max, 1 edge max
  var zoom = r.cy.zoom();
  var hasCompounds = r.cy.hasCompoundNodes();
  var edgeThreshold = (isTouch ? 24 : 8) / zoom;
  var nodeThreshold = (isTouch ? 8 : 2) / zoom;
  var labelThreshold = (isTouch ? 8 : 2) / zoom;
  var minSqDist = Infinity;
  var nearEdge;
  var nearNode;

  if (interactiveElementsOnly) {
    eles = eles.interactive;
  }

  function addEle(ele, sqDist) {
    if (ele.isNode()) {
      if (nearNode) {
        return; // can't replace node
      } else {
        nearNode = ele;
        near.push(ele);
      }
    }

    if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {
      if (nearEdge) {
        // then replace existing edge
        // can replace only if same z-index
        if (nearEdge.pstyle('z-index').value === ele.pstyle('z-index').value) {
          for (var i = 0; i < near.length; i++) {
            if (near[i].isEdge()) {
              near[i] = ele;
              nearEdge = ele;
              minSqDist = sqDist != null ? sqDist : minSqDist;
              break;
            }
          }
        }
      } else {
        near.push(ele);
        nearEdge = ele;
        minSqDist = sqDist != null ? sqDist : minSqDist;
      }
    }
  }

  function checkNode(node) {
    var width = node.outerWidth() + 2 * nodeThreshold;
    var height = node.outerHeight() + 2 * nodeThreshold;
    var hw = width / 2;
    var hh = height / 2;
    var pos = node.position();

    if (pos.x - hw <= x && x <= pos.x + hw // bb check x
    && pos.y - hh <= y && y <= pos.y + hh // bb check y
    ) {
        var shape = r.nodeShapes[self.getNodeShape(node)];

        if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)) {
          addEle(node, 0);
          return true;
        }
      }
  }

  function checkEdge(edge) {
    var _p = edge._private;

    var rs = _p.rscratch;
    var styleWidth = edge.pstyle('width').pfValue;
    var scale = edge.pstyle('arrow-scale').value;
    var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre
    var widthSq = width * width;
    var width2 = width * 2;
    var src = _p.source;
    var tgt = _p.target;
    var inEdgeBB = false;
    var sqDist;

    if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {
      var pts = rs.allpts;

      for (var i = 0; i + 3 < pts.length; i += 2) {
        if ((inEdgeBB = math.inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2)) && widthSq > (sqDist = math.sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {
          addEle(edge, sqDist);
          return true;
        }
      }
    } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
      var pts = rs.allpts;
      for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
        if ((inEdgeBB = math.inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2)) && widthSq > (sqDist = math.sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {
          addEle(edge, sqDist);
          return true;
        }
      }
    }

    // if we're close to the edge but didn't hit it, maybe we hit its arrows

    var src = src || _p.source;
    var tgt = tgt || _p.target;

    var arSize = self.getArrowWidth(styleWidth, scale);

    var arrows = [{ name: 'source', x: rs.arrowStartX, y: rs.arrowStartY, angle: rs.srcArrowAngle }, { name: 'target', x: rs.arrowEndX, y: rs.arrowEndY, angle: rs.tgtArrowAngle }, { name: 'mid-source', x: rs.midX, y: rs.midY, angle: rs.midsrcArrowAngle }, { name: 'mid-target', x: rs.midX, y: rs.midY, angle: rs.midtgtArrowAngle }];

    for (var i = 0; i < arrows.length; i++) {
      var ar = arrows[i];
      var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];
      var edgeWidth = edge.pstyle('width').pfValue;
      if (shape.roughCollide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeWidth, edgeThreshold)) {
        addEle(edge);
        return true;
      }
    }

    // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
    if (hasCompounds && near.length > 0) {
      checkNode(src);
      checkNode(tgt);
    }
  }

  function preprop(obj, name, pre) {
    return util.getPrefixedProperty(obj, name, pre);
  }

  function checkLabel(ele, prefix) {
    var _p = ele._private;
    var th = labelThreshold;

    var prefixDash;
    if (prefix) {
      prefixDash = prefix + '-';
    } else {
      prefixDash = '';
    }

    var text = ele.pstyle(prefixDash + 'label').value;
    var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';

    if (!eventsEnabled || !text) {
      return;
    }

    var rstyle = _p.rstyle;
    var bw = ele.pstyle('text-border-width').pfValue;
    var pw = ele.pstyle('text-background-padding').pfValue;
    var lw = preprop(rstyle, 'labelWidth', prefix) + bw + 2 * th + 2 * pw;
    var lh = preprop(rstyle, 'labelHeight', prefix) + bw + 2 * th + 2 * pw;
    var lx = preprop(rstyle, 'labelX', prefix);
    var ly = preprop(rstyle, 'labelY', prefix);

    var theta = preprop(_p.rscratch, 'labelAngle', prefix);

    var lx1 = lx - lw / 2;
    var lx2 = lx + lw / 2;
    var ly1 = ly - lh / 2;
    var ly2 = ly + lh / 2;

    if (theta) {
      var cos = Math.cos(theta);
      var sin = Math.sin(theta);

      var rotate = function rotate(x, y) {
        x = x - lx;
        y = y - ly;

        return {
          x: x * cos - y * sin + lx,
          y: x * sin + y * cos + ly
        };
      };

      var px1y1 = rotate(lx1, ly1);
      var px1y2 = rotate(lx1, ly2);
      var px2y1 = rotate(lx2, ly1);
      var px2y2 = rotate(lx2, ly2);

      var points = [px1y1.x, px1y1.y, px2y1.x, px2y1.y, px2y2.x, px2y2.y, px1y2.x, px1y2.y];

      if (math.pointInsidePolygonPoints(x, y, points)) {
        addEle(ele);
        return true;
      }
    } else {
      // do a cheaper bb check
      var bb = {
        w: lw,
        h: lh,
        x1: lx1,
        x2: lx2,
        y1: ly1,
        y2: ly2
      };

      if (math.inBoundingBox(bb, x, y)) {
        addEle(ele);
        return true;
      }
    }
  }

  for (var i = eles.length - 1; i >= 0; i--) {
    // reverse order for precedence
    var ele = eles[i];

    if (ele.isNode()) {
      checkNode(ele) || checkLabel(ele);
    } else {
      // then edge
      checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');
    }
  }

  return near;
};

// 'Give me everything from this box'
BRp.getAllInBox = function (x1, y1, x2, y2) {
  var eles = this.getCachedZSortedEles().interactive;
  var box = [];

  var x1c = Math.min(x1, x2);
  var x2c = Math.max(x1, x2);
  var y1c = Math.min(y1, y2);
  var y2c = Math.max(y1, y2);

  x1 = x1c;
  x2 = x2c;
  y1 = y1c;
  y2 = y2c;

  var boxBb = math.makeBoundingBox({
    x1: x1, y1: y1,
    x2: x2, y2: y2
  });

  for (var e = 0; e < eles.length; e++) {
    var ele = eles[e];

    if (ele.isNode()) {
      var node = ele;
      var nodeBb = node.boundingBox({
        includeNodes: true,
        includeEdges: false,
        includeLabels: false
      });

      if (math.boundingBoxesIntersect(boxBb, nodeBb) && !math.boundingBoxInBoundingBox(nodeBb, boxBb)) {
        box.push(node);
      }
    } else {
      var edge = ele;
      var _p = edge._private;
      var rs = _p.rscratch;

      if (rs.startX != null && rs.startY != null && !math.inBoundingBox(boxBb, rs.startX, rs.startY)) {
        continue;
      }
      if (rs.endX != null && rs.endY != null && !math.inBoundingBox(boxBb, rs.endX, rs.endY)) {
        continue;
      }

      if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {

        var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
        var allInside = true;

        for (var i = 0; i < pts.length; i++) {
          if (!math.pointInBoundingBox(boxBb, pts[i])) {
            allInside = false;
            break;
          }
        }

        if (allInside) {
          box.push(edge);
        }
      } else if (rs.edgeType === 'haystack' || rs.edgeType === 'straight') {
        box.push(edge);
      }
    }
  }

  return box;
};

module.exports = BRp;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);

var BRp = {};

BRp.calculateArrowAngles = function (edge) {
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';
  var isBezier = rs.edgeType === 'bezier';
  var isMultibezier = rs.edgeType === 'multibezier';
  var isSegments = rs.edgeType === 'segments';
  var isCompound = rs.edgeType === 'compound';
  var isSelf = rs.edgeType === 'self';

  // Displacement gives direction for arrowhead orientation
  var dispX, dispY;
  var startX, startY, endX, endY, midX, midY;

  if (isHaystack) {
    startX = rs.haystackPts[0];
    startY = rs.haystackPts[1];
    endX = rs.haystackPts[2];
    endY = rs.haystackPts[3];
  } else {
    startX = rs.arrowStartX;
    startY = rs.arrowStartY;
    endX = rs.arrowEndX;
    endY = rs.arrowEndY;
  }

  midX = rs.midX;
  midY = rs.midY;

  // source
  //

  if (isSegments) {
    dispX = startX - rs.segpts[0];
    dispY = startY - rs.segpts[1];
  } else if (isMultibezier || isCompound || isSelf || isBezier) {
    var pts = rs.allpts;
    var bX = math.qbezierAt(pts[0], pts[2], pts[4], 0.1);
    var bY = math.qbezierAt(pts[1], pts[3], pts[5], 0.1);

    dispX = startX - bX;
    dispY = startY - bY;
  } else {
    dispX = startX - midX;
    dispY = startY - midY;
  }

  rs.srcArrowAngle = math.getAngleFromDisp(dispX, dispY);

  // mid target
  //

  var midX = rs.midX;
  var midY = rs.midY;

  if (isHaystack) {
    midX = (startX + endX) / 2;
    midY = (startY + endY) / 2;
  }

  dispX = endX - startX;
  dispY = endY - startY;

  if (isSegments) {
    var pts = rs.allpts;

    if (pts.length / 2 % 2 === 0) {
      var i2 = pts.length / 2;
      var i1 = i2 - 2;

      dispX = pts[i2] - pts[i1];
      dispY = pts[i2 + 1] - pts[i1 + 1];
    } else {
      var i2 = pts.length / 2 - 1;
      var i1 = i2 - 2;
      var i3 = i2 + 2;

      dispX = pts[i2] - pts[i1];
      dispY = pts[i2 + 1] - pts[i1 + 1];
    }
  } else if (isMultibezier || isCompound || isSelf) {
    var pts = rs.allpts;
    var cpts = rs.ctrlpts;
    var bp0x, bp0y;
    var bp1x, bp1y;

    if (cpts.length / 2 % 2 === 0) {
      var p0 = pts.length / 2 - 1; // startpt
      var ic = p0 + 2;
      var p1 = ic + 2;

      bp0x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);
      bp0y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);

      bp1x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);
      bp1y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);
    } else {
      var ic = pts.length / 2 - 1; // ctrpt
      var p0 = ic - 2; // startpt
      var p1 = ic + 2; // endpt

      bp0x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);
      bp0y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);

      bp1x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);
      bp1y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);
    }

    dispX = bp1x - bp0x;
    dispY = bp1y - bp0y;
  }

  rs.midtgtArrowAngle = math.getAngleFromDisp(dispX, dispY);

  rs.midDispX = dispX;
  rs.midDispY = dispY;

  // mid source
  //

  dispX *= -1;
  dispY *= -1;

  if (isSegments) {
    var pts = rs.allpts;

    if (pts.length / 2 % 2 === 0) {
      // already ok
    } else {
      var i2 = pts.length / 2 - 1;
      var i3 = i2 + 2;

      dispX = -(pts[i3] - pts[i2]);
      dispY = -(pts[i3 + 1] - pts[i2 + 1]);
    }
  }

  rs.midsrcArrowAngle = math.getAngleFromDisp(dispX, dispY);

  // target
  //

  if (isSegments) {
    dispX = endX - rs.segpts[rs.segpts.length - 2];
    dispY = endY - rs.segpts[rs.segpts.length - 1];
  } else if (isMultibezier || isCompound || isSelf || isBezier) {
    var pts = rs.allpts;
    var l = pts.length;
    var bX = math.qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);
    var bY = math.qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);

    dispX = endX - bX;
    dispY = endY - bY;
  } else {
    dispX = endX - midX;
    dispY = endY - midY;
  }

  rs.tgtArrowAngle = math.getAngleFromDisp(dispX, dispY);
};

BRp.getArrowWidth = BRp.getArrowHeight = function (edgeWidth, scale) {
  var cache = this.arrowWidthCache = this.arrowWidthCache || {};

  var cachedVal = cache[edgeWidth + ', ' + scale];
  if (cachedVal) {
    return cachedVal;
  }

  cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;
  cache[edgeWidth + ', ' + scale] = cachedVal;

  return cachedVal;
};

module.exports = BRp;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);
var is = __webpack_require__(0);

var BRp = {};

BRp.findEdgeControlPoints = function (edges) {
  if (!edges || edges.length === 0) {
    return;
  }

  var r = this;
  var cy = r.cy;
  var hasCompounds = cy.hasCompoundNodes();
  var hashTable = {};
  var pairIds = [];
  var haystackEdges = [];

  // create a table of edge (src, tgt) => list of edges between them
  var pairId;
  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];
    var _p = edge._private;
    var data = _p.data;
    var curveStyle = edge.pstyle('curve-style').value;
    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';
    var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';

    // ignore edges who are not to be displayed
    // they shouldn't take up space
    if (edge.pstyle('display').value === 'none') {
      continue;
    }

    if (curveStyle === 'haystack') {
      haystackEdges.push(edge);
      continue;
    }

    var srcId = data.source;
    var tgtId = data.target;

    pairId = srcId > tgtId ? tgtId + '$-$' + srcId : srcId + '$-$' + tgtId;

    if (edgeIsUnbundled) {
      pairId = 'unbundled' + '$-$' + data.id;
    }

    var tableEntry = hashTable[pairId];

    if (tableEntry == null) {
      tableEntry = hashTable[pairId] = [];
      pairIds.push(pairId);
    }

    tableEntry.push(edge);

    if (edgeIsUnbundled) {
      tableEntry.hasUnbundled = true;
    }

    if (edgeIsBezier) {
      tableEntry.hasBezier = true;
    }
  }

  var src, tgt, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape;
  var vectorNormInverse;
  var badBezier;

  // for each pair (src, tgt), create the ctrl pts
  // Nested for loop is OK; total number of iterations for both loops = edgeCount
  for (var p = 0; p < pairIds.length; p++) {
    pairId = pairIds[p];
    var pairEdges = hashTable[pairId];

    // for each pair id, the edges should be sorted by index
    pairEdges.sort(function (edge1, edge2) {
      return edge1.poolIndex() - edge2.poolIndex();
    });

    src = pairEdges[0]._private.source;
    tgt = pairEdges[0]._private.target;

    // make sure src/tgt distinction is consistent for bundled edges
    if (!pairEdges.hasUnbundled && src.id() > tgt.id()) {
      var temp = src;
      src = tgt;
      tgt = temp;
    }

    srcPos = src.position();
    tgtPos = tgt.position();

    srcW = src.outerWidth();
    srcH = src.outerHeight();

    tgtW = tgt.outerWidth();
    tgtH = tgt.outerHeight();

    srcShape = r.nodeShapes[this.getNodeShape(src)];
    tgtShape = r.nodeShapes[this.getNodeShape(tgt)];

    badBezier = false;

    var edge;
    var edge_p;
    var rs;

    var dirCounts = {
      'north': 0,
      'west': 0,
      'south': 0,
      'east': 0,
      'northwest': 0,
      'southwest': 0,
      'northeast': 0,
      'southeast': 0
    };

    var srcX2 = srcPos.x;
    var srcY2 = srcPos.y;
    var srcW2 = srcW;
    var srcH2 = srcH;

    var tgtX2 = tgtPos.x;
    var tgtY2 = tgtPos.y;
    var tgtW2 = tgtW;
    var tgtH2 = tgtH;

    var numEdges2 = pairEdges.length;

    for (var i = 0; i < pairEdges.length; i++) {
      edge = pairEdges[i];
      edge_p = edge._private;
      rs = edge_p.rscratch;

      var edgeIndex1 = rs.lastEdgeIndex;
      var edgeIndex2 = i;

      var numEdges1 = rs.lastNumEdges;

      var curveStyle = edge.pstyle('curve-style').value;

      var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';

      // whether the normalised pair order is the reverse of the edge's src-tgt order
      var edgeIsSwapped = src.id() !== edge.source().id();

      var ctrlptDists = edge.pstyle('control-point-distances');
      var loopDir = edge.pstyle('loop-direction').pfValue;
      var loopSwp = edge.pstyle('loop-sweep').pfValue;
      var ctrlptWs = edge.pstyle('control-point-weights');
      var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;
      var stepSize = edge.pstyle('control-point-step-size').pfValue;
      var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
      var ctrlptWeight = ctrlptWs.value[0];
      var edgeDistances = edge.pstyle('edge-distances').value;
      var segmentWs = edge.pstyle('segment-weights');
      var segmentDs = edge.pstyle('segment-distances');
      var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);
      var srcEndpt = edge.pstyle('source-endpoint').value;
      var tgtEndpt = edge.pstyle('target-endpoint').value;
      var srcArrShape = edge.pstyle('source-arrow-shape').value;
      var tgtArrShape = edge.pstyle('target-arrow-shape').value;
      var arrowScale = edge.pstyle('arrow-scale').value;
      var lineWidth = edge.pstyle('width').pfValue;

      var srcX1 = rs.lastSrcCtlPtX;
      var srcY1 = rs.lastSrcCtlPtY;
      var srcW1 = rs.lastSrcCtlPtW;
      var srcH1 = rs.lastSrcCtlPtH;

      var tgtX1 = rs.lastTgtCtlPtX;
      var tgtY1 = rs.lastTgtCtlPtY;
      var tgtW1 = rs.lastTgtCtlPtW;
      var tgtH1 = rs.lastTgtCtlPtH;

      var curveStyle1 = rs.lastCurveStyle;
      var curveStyle2 = curveStyle;

      var ctrlptDists1 = rs.lastCtrlptDists;
      var ctrlptDists2 = ctrlptDists ? ctrlptDists.strValue : null;

      var ctrlptWs1 = rs.lastCtrlptWs;
      var ctrlptWs2 = ctrlptWs.strValue;

      var segmentWs1 = rs.lastSegmentWs;
      var segmentWs2 = segmentWs.strValue;

      var segmentDs1 = rs.lastSegmentDs;
      var segmentDs2 = segmentDs.strValue;

      var stepSize1 = rs.lastStepSize;
      var stepSize2 = stepSize;

      var loopDir1 = rs.lastLoopDir;
      var loopDir2 = loopDir;

      var loopSwp1 = rs.lastLoopSwp;
      var loopSwp2 = loopSwp;

      var edgeDistances1 = rs.lastEdgeDistances;
      var edgeDistances2 = edgeDistances;

      var srcEndpt1 = rs.lastSrcEndpt;
      var srcEndpt2 = srcEndpt;

      var tgtEndpt1 = rs.lastTgtEndpt;
      var tgtEndpt2 = tgtEndpt;

      var srcArr1 = rs.lastSrcArr;
      var srcArr2 = srcArrShape;

      var tgtArr1 = rs.lastTgtArr;
      var tgtArr2 = tgtArrShape;

      var lineW1 = rs.lastLineW;
      var lineW2 = lineWidth;

      var arrScl1 = rs.lastArrScl;
      var arrScl2 = arrowScale;

      if (badBezier) {
        rs.badBezier = true;
      } else {
        rs.badBezier = false;
      }

      var ptCacheHit;

      if (srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2 && tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2 && curveStyle1 === curveStyle2 && ctrlptDists1 === ctrlptDists2 && ctrlptWs1 === ctrlptWs2 && segmentWs1 === segmentWs2 && segmentDs1 === segmentDs2 && stepSize1 === stepSize2 && loopDir1 === loopDir2 && loopSwp1 === loopSwp2 && edgeDistances1 === edgeDistances2 && srcEndpt1 === srcEndpt2 && tgtEndpt1 === tgtEndpt2 && srcArr1 === srcArr2 && tgtArr1 === tgtArr2 && lineW1 === lineW2 && arrScl1 === arrScl2 && (edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2 || edgeIsUnbundled)) {
        ptCacheHit = true; // then the control points haven't changed and we can skip calculating them
      } else {
        ptCacheHit = false;

        rs.lastSrcCtlPtX = srcX2;
        rs.lastSrcCtlPtY = srcY2;
        rs.lastSrcCtlPtW = srcW2;
        rs.lastSrcCtlPtH = srcH2;
        rs.lastTgtCtlPtX = tgtX2;
        rs.lastTgtCtlPtY = tgtY2;
        rs.lastTgtCtlPtW = tgtW2;
        rs.lastTgtCtlPtH = tgtH2;
        rs.lastEdgeIndex = edgeIndex2;
        rs.lastNumEdges = numEdges2;
        rs.lastCurveStyle = curveStyle2;
        rs.lastCtrlptDists = ctrlptDists2;
        rs.lastCtrlptWs = ctrlptWs2;
        rs.lastSegmentDs = segmentDs2;
        rs.lastSegmentWs = segmentWs2;
        rs.lastStepSize = stepSize2;
        rs.lastLoopDir = loopDir2;
        rs.lastLoopSwp = loopSwp2;
        rs.lastEdgeDistances = edgeDistances2;
        rs.lastSrcEndpt = srcEndpt2;
        rs.lastTgtEndpt = tgtEndpt2;
        rs.lastSrcArr = srcArr2;
        rs.lastTgtArr = tgtArr2;
        rs.lastLineW = lineW2;
        rs.lastArrScl = arrScl2;
      }

      if (!ptCacheHit) {

        if (!pairEdges.calculatedIntersection && src !== tgt && (pairEdges.hasBezier || pairEdges.hasUnbundled)) {

          pairEdges.calculatedIntersection = true;

          // pt outside src shape to calc distance/displacement from src to tgt
          var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0);

          pairEdges.srcIntn = srcOutside;

          // pt outside tgt shape to calc distance/displacement from src to tgt
          var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0);

          pairEdges.tgtIntn = tgtOutside;

          var midptSrcPts = {
            x1: srcOutside[0],
            x2: tgtOutside[0],
            y1: srcOutside[1],
            y2: tgtOutside[1]
          };

          var posPts = {
            x1: srcPos.x,
            x2: tgtPos.x,
            y1: srcPos.y,
            y2: tgtPos.y
          };

          var dy = tgtOutside[1] - srcOutside[1];
          var dx = tgtOutside[0] - srcOutside[0];
          var l = Math.sqrt(dx * dx + dy * dy);

          var vector = {
            x: dx,
            y: dy
          };

          var vectorNorm = {
            x: vector.x / l,
            y: vector.y / l
          };
          vectorNormInverse = {
            x: -vectorNorm.y,
            y: vectorNorm.x
          };

          // if node shapes overlap, then no ctrl pts to draw
          if (tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y) && srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y)) {
            vectorNormInverse = {};
            badBezier = true;
          }
        }

        if (!edgeIsSwapped) {
          rs.srcIntn = pairEdges.srcIntn;
          rs.tgtIntn = pairEdges.tgtIntn;
        } else {
          // ensure that the per-edge cached value for intersections are correct for swapped bundled edges
          rs.srcIntn = pairEdges.tgtIntn;
          rs.tgtIntn = pairEdges.srcIntn;
        }

        if (src === tgt) {
          // Self-edge

          rs.edgeType = 'self';

          var j = i;
          var loopDist = stepSize;

          if (edgeIsUnbundled) {
            j = 0;
            loopDist = ctrlptDist;
          }

          var loopAngle = loopDir - Math.PI / 2;
          var outAngle = loopAngle - loopSwp / 2;
          var inAngle = loopAngle + loopSwp / 2;

          // increase by step size for overlapping loops, keyed on direction and sweep values
          var dc = String(loopDir + '_' + loopSwp);
          j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];

          rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];
        } else if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src))) {
          // Compound edge

          rs.edgeType = 'compound';

          // because the line approximation doesn't apply for compound beziers
          // (loop/self edges are already elided b/c of cheap src==tgt check)
          rs.badBezier = false;

          var j = i;
          var loopDist = stepSize;

          if (edgeIsUnbundled) {
            j = 0;
            loopDist = ctrlptDist;
          }

          var loopW = 50;

          var loopaPos = {
            x: srcPos.x - srcW / 2,
            y: srcPos.y - srcH / 2
          };

          var loopbPos = {
            x: tgtPos.x - tgtW / 2,
            y: tgtPos.y - tgtH / 2
          };

          var loopPos = {
            x: Math.min(loopaPos.x, loopbPos.x),
            y: Math.min(loopaPos.y, loopbPos.y)
          };

          // avoids cases with impossible beziers
          var minCompoundStretch = 0.5;
          var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));
          var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));

          rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];
        } else if (curveStyle === 'segments') {
          // Segments (multiple straight lines)

          rs.edgeType = 'segments';
          rs.segpts = [];

          for (var s = 0; s < segmentsN; s++) {
            var w = segmentWs.pfValue[s];
            var d = segmentDs.pfValue[s];

            var w1 = 1 - w;
            var w2 = w;

            var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;

            var adjustedMidpt = {
              x: midptPts.x1 * w1 + midptPts.x2 * w2,
              y: midptPts.y1 * w1 + midptPts.y2 * w2
            };

            rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);
          }

          // Straight edge
        } else if (pairEdges.length % 2 === 1 && i === Math.floor(pairEdges.length / 2) && !edgeIsUnbundled) {

          rs.edgeType = 'straight';
        } else {
          // (Multi)bezier

          var multi = edgeIsUnbundled;

          rs.edgeType = multi ? 'multibezier' : 'bezier';
          rs.ctrlpts = [];

          for (var b = 0; b < bezierN; b++) {
            var normctrlptDist = (0.5 - pairEdges.length / 2 + i) * stepSize;
            var manctrlptDist;
            var sign = math.signum(normctrlptDist);

            if (multi) {
              ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size
              ctrlptWeight = ctrlptWs.value[b];
            }

            if (edgeIsUnbundled) {
              // multi or single unbundled
              manctrlptDist = ctrlptDist;
            } else {
              manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;
            }

            var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;

            var w1 = 1 - ctrlptWeight;
            var w2 = ctrlptWeight;

            if (edgeIsSwapped) {
              var temp = w1;
              w1 = w2;
              w2 = temp;
            }

            var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;

            var adjustedMidpt = {
              x: midptPts.x1 * w1 + midptPts.x2 * w2,
              y: midptPts.y1 * w1 + midptPts.y2 * w2
            };

            rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);
          }
        }

        // find endpts for edge
        this.findEndpoints(edge);

        var badStart = !is.number(rs.startX) || !is.number(rs.startY);
        var badAStart = !is.number(rs.arrowStartX) || !is.number(rs.arrowStartY);
        var badEnd = !is.number(rs.endX) || !is.number(rs.endY);
        var badAEnd = !is.number(rs.arrowEndX) || !is.number(rs.arrowEndY);

        var minCpADistFactor = 3;
        var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
        var minCpADist = minCpADistFactor * arrowW;

        if (rs.edgeType === 'bezier') {
          var startACpDist = math.dist({ x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.startX, y: rs.startY });
          var closeStartACp = startACpDist < minCpADist;
          var endACpDist = math.dist({ x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.endX, y: rs.endY });
          var closeEndACp = endACpDist < minCpADist;

          var overlapping = false;

          if (badStart || badAStart || closeStartACp) {
            overlapping = true;

            // project control point along line from src centre to outside the src shape
            // (otherwise intersection will yield nothing)
            var cpD = { // delta
              x: rs.ctrlpts[0] - srcPos.x,
              y: rs.ctrlpts[1] - srcPos.y
            };
            var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line
            var cpM = { // normalised delta
              x: cpD.x / cpL,
              y: cpD.y / cpL
            };
            var radius = Math.max(srcW, srcH);
            var cpProj = { // *2 radius guarantees outside shape
              x: rs.ctrlpts[0] + cpM.x * 2 * radius,
              y: rs.ctrlpts[1] + cpM.y * 2 * radius
            };

            var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0);

            if (closeStartACp) {
              rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
              rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
            } else {
              rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
              rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
            }
          }

          if (badEnd || badAEnd || closeEndACp) {
            overlapping = true;

            // project control point along line from tgt centre to outside the tgt shape
            // (otherwise intersection will yield nothing)
            var cpD = { // delta
              x: rs.ctrlpts[0] - tgtPos.x,
              y: rs.ctrlpts[1] - tgtPos.y
            };
            var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line
            var cpM = { // normalised delta
              x: cpD.x / cpL,
              y: cpD.y / cpL
            };
            var radius = Math.max(srcW, srcH);
            var cpProj = { // *2 radius guarantees outside shape
              x: rs.ctrlpts[0] + cpM.x * 2 * radius,
              y: rs.ctrlpts[1] + cpM.y * 2 * radius
            };

            var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, cpProj.x, cpProj.y, 0);

            if (closeEndACp) {
              rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - endACpDist);
              rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - endACpDist);
            } else {
              rs.ctrlpts[0] = tgtCtrlPtIntn[0] + cpM.x * minCpADist;
              rs.ctrlpts[1] = tgtCtrlPtIntn[1] + cpM.y * minCpADist;
            }
          }

          if (overlapping) {
            // recalc endpts
            this.findEndpoints(edge);
          }
        }

        if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
          rs.allpts = [];

          rs.allpts.push(rs.startX, rs.startY);

          for (var b = 0; b + 1 < rs.ctrlpts.length; b += 2) {
            // ctrl pt itself
            rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]);

            // the midpt between ctrlpts as intermediate destination pts
            if (b + 3 < rs.ctrlpts.length) {
              rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);
            }
          }

          rs.allpts.push(rs.endX, rs.endY);

          var m, mt;
          if (rs.ctrlpts.length / 2 % 2 === 0) {
            m = rs.allpts.length / 2 - 1;

            rs.midX = rs.allpts[m];
            rs.midY = rs.allpts[m + 1];
          } else {
            m = rs.allpts.length / 2 - 3;
            mt = 0.5;

            rs.midX = math.qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);
            rs.midY = math.qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);
          }
        } else if (rs.edgeType === 'straight') {
          // need to calc these after endpts
          rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY];

          // default midpt for labels etc
          rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;
          rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;
        } else if (rs.edgeType === 'segments') {
          rs.allpts = [];
          rs.allpts.push(rs.startX, rs.startY);
          rs.allpts.push.apply(rs.allpts, rs.segpts);
          rs.allpts.push(rs.endX, rs.endY);

          if (rs.segpts.length % 4 === 0) {
            var i2 = rs.segpts.length / 2;
            var i1 = i2 - 2;

            rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;
            rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;
          } else {
            var i1 = rs.segpts.length / 2 - 1;

            rs.midX = rs.segpts[i1];
            rs.midY = rs.segpts[i1 + 1];
          }
        }

        this.storeEdgeProjections(edge);
        this.calculateArrowAngles(edge);
      } // if point cache miss

      this.recalculateEdgeLabelProjections(edge);
      this.calculateLabelAngles(edge);
    } // for pair edges
  } // for pair ids

  for (var i = 0; i < haystackEdges.length; i++) {
    var edge = haystackEdges[i];
    var _p = edge._private;
    var rscratch = _p.rscratch;
    var rs = rscratch;

    if (!rscratch.haystack) {
      var angle = Math.random() * 2 * Math.PI;

      rscratch.source = {
        x: Math.cos(angle),
        y: Math.sin(angle)
      };

      var angle = Math.random() * 2 * Math.PI;

      rscratch.target = {
        x: Math.cos(angle),
        y: Math.sin(angle)
      };
    }

    var src = _p.source;
    var tgt = _p.target;
    var srcPos = src.position();
    var tgtPos = tgt.position();
    var srcW = src.width();
    var tgtW = tgt.width();
    var srcH = src.height();
    var tgtH = tgt.height();
    var radius = edge.pstyle('haystack-radius').value;
    var halfRadius = radius / 2; // b/c have to half width/height

    rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];

    rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;
    rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;

    // always override as haystack in case set to different type previously
    rscratch.edgeType = rscratch.lastCurveStyle = 'haystack';
    rscratch.haystack = true;

    this.storeEdgeProjections(edge);
    this.calculateArrowAngles(edge);
    this.recalculateEdgeLabelProjections(edge);
    this.calculateLabelAngles(edge);
  }
};

function getPts(pts) {
  var retPts = [];

  if (pts == null) {
    return;
  }

  for (var i = 0; i < pts.length; i += 2) {
    var x = pts[i];
    var y = pts[i + 1];

    retPts.push({ x: x, y: y });
  }

  return retPts;
}

BRp.getSegmentPoints = function (edge) {
  var rs = edge[0]._private.rscratch;
  var type = rs.edgeType;

  if (type === 'segments') {
    return getPts(rs.segpts);
  }
};

BRp.getControlPoints = function (edge) {
  var rs = edge[0]._private.rscratch;
  var type = rs.edgeType;

  if (type === 'bezier' || type === 'multibezier') {
    return getPts(rs.ctrlpts);
  }
};

BRp.getEdgeMidpoint = function (edge) {
  var rs = edge[0]._private.rscratch;

  return {
    x: rs.midX,
    y: rs.midY
  };
};

module.exports = BRp;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);
var is = __webpack_require__(0);

var BRp = {};

BRp.manualEndptToPx = function (node, prop) {
  var r = this;
  var npos = node.position();
  var w = node.outerWidth();
  var h = node.outerHeight();

  if (prop.value.length === 2) {
    var p = [prop.pfValue[0], prop.pfValue[1]];

    if (prop.units[0] === '%') {
      p[0] = p[0] * w;
    }

    if (prop.units[1] === '%') {
      p[1] = p[1] * h;
    }

    p[0] += npos.x;
    p[1] += npos.y;

    return p;
  } else {
    var angle = prop.pfValue[0];

    angle = -Math.PI / 2 + angle; // start at 12 o'clock

    var l = 2 * Math.max(w, h);

    var _p = [npos.x + Math.cos(angle) * l, npos.y + Math.sin(angle) * l];

    return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0);
  }
};

BRp.findEndpoints = function (edge) {
  var r = this;
  var intersect = void 0;

  var source = edge.source()[0];
  var target = edge.target()[0];

  var srcPos = source.position();
  var tgtPos = target.position();

  var tgtArShape = edge.pstyle('target-arrow-shape').value;
  var srcArShape = edge.pstyle('source-arrow-shape').value;

  var tgtDist = edge.pstyle('target-distance-from-node').pfValue;
  var srcDist = edge.pstyle('source-distance-from-node').pfValue;

  var rs = edge._private.rscratch;

  var et = rs.edgeType;
  var self = et === 'self' || et === 'compound';
  var bezier = et === 'bezier' || et === 'multibezier' || self;
  var multi = et !== 'bezier';
  var lines = et === 'straight' || et === 'segments';
  var segments = et === 'segments';
  var hasEndpts = bezier || multi || lines;
  var srcManEndpt = edge.pstyle('source-endpoint');
  var srcManEndptVal = self ? 'outside-to-node' : srcManEndpt.value;
  var tgtManEndpt = edge.pstyle('target-endpoint');
  var tgtManEndptVal = self ? 'outside-to-node' : tgtManEndpt.value;

  rs.srcManEndpt = srcManEndpt;
  rs.tgtManEndpt = tgtManEndpt;

  var p1 = void 0; // last known point of edge on target side
  var p2 = void 0; // last known point of edge on source side

  var p1_i = void 0; // point to intersect with target shape
  var p2_i = void 0; // point to intersect with source shape

  if (bezier) {
    var cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];
    var cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;

    p1 = cpEnd;
    p2 = cpStart;
  } else if (lines) {
    var srcArrowFromPt = !segments ? [tgtPos.x, tgtPos.y] : rs.segpts.slice(0, 2);
    var tgtArrowFromPt = !segments ? [srcPos.x, srcPos.y] : rs.segpts.slice(rs.segpts.length - 2);

    p1 = tgtArrowFromPt;
    p2 = srcArrowFromPt;
  }

  if (tgtManEndptVal === 'inside-to-node') {
    intersect = [tgtPos.x, tgtPos.y];
  } else if (tgtManEndpt.units) {
    intersect = this.manualEndptToPx(target, tgtManEndpt);
  } else if (tgtManEndptVal === 'outside-to-line') {
    intersect = rs.tgtIntn; // use cached value from ctrlpt calc
  } else {
    if (tgtManEndptVal === 'outside-to-node') {
      p1_i = p1;
    } else if (tgtManEndptVal === 'outside-to-line') {
      p1_i = [srcPos.x, srcPos.y];
    }

    intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0);
  }

  var arrowEnd = math.shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);
  var edgeEnd = math.shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);

  rs.endX = edgeEnd[0];
  rs.endY = edgeEnd[1];

  rs.arrowEndX = arrowEnd[0];
  rs.arrowEndY = arrowEnd[1];

  if (srcManEndptVal === 'inside-to-node') {
    intersect = [srcPos.x, srcPos.y];
  } else if (srcManEndpt.units) {
    intersect = this.manualEndptToPx(source, srcManEndpt);
  } else if (srcManEndptVal === 'outside-to-line') {
    intersect = rs.srcIntn; // use cached value from ctrlpt calc
  } else {
    if (srcManEndptVal === 'outside-to-node') {
      p2_i = p2;
    } else if (srcManEndptVal === 'outside-to-line') {
      p2_i = [tgtPos.x, tgtPos.y];
    }

    intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0);
  }

  var arrowStart = math.shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);
  var edgeStart = math.shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);

  rs.startX = edgeStart[0];
  rs.startY = edgeStart[1];

  rs.arrowStartX = arrowStart[0];
  rs.arrowStartY = arrowStart[1];

  if (hasEndpts) {
    if (!is.number(rs.startX) || !is.number(rs.startY) || !is.number(rs.endX) || !is.number(rs.endY)) {
      rs.badLine = true;
    } else {
      rs.badLine = false;
    }
  }
};

BRp.getSourceEndpoint = function (edge) {
  var rs = edge[0]._private.rscratch;

  switch (rs.edgeType) {
    case 'haystack':
      return {
        x: rs.haystackPts[0],
        y: rs.haystackPts[1]
      };
    default:
      return {
        x: rs.arrowStartX,
        y: rs.arrowStartY
      };
  }
};

BRp.getTargetEndpoint = function (edge) {
  var rs = edge[0]._private.rscratch;

  switch (rs.edgeType) {
    case 'haystack':
      return {
        x: rs.haystackPts[2],
        y: rs.haystackPts[3]
      };
    default:
      return {
        x: rs.arrowEndX,
        y: rs.arrowEndY
      };
  }
};

module.exports = BRp;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);

var BRp = {};

function pushBezierPts(r, edge, pts) {
  var qbezierAt = function qbezierAt(p1, p2, p3, t) {
    return math.qbezierAt(p1, p2, p3, t);
  };
  var _p = edge._private;
  var bpts = _p.rstyle.bezierPts;

  for (var i = 0; i < r.bezierProjPcts.length; i++) {
    var p = r.bezierProjPcts[i];

    bpts.push({
      x: qbezierAt(pts[0], pts[2], pts[4], p),
      y: qbezierAt(pts[1], pts[3], pts[5], p)
    });
  }
}

BRp.storeEdgeProjections = function (edge) {
  var _p = edge._private;
  var rs = _p.rscratch;
  var et = rs.edgeType;

  // clear the cached points state
  _p.rstyle.bezierPts = null;
  _p.rstyle.linePts = null;
  _p.rstyle.haystackPts = null;

  if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {
    var bpts = _p.rstyle.bezierPts = []; // jshint ignore:line

    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
      pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));
    }
  } else if (et === 'segments') {
    var lpts = _p.rstyle.linePts = [];

    for (var i = 0; i + 1 < rs.allpts.length; i += 2) {
      lpts.push({
        x: rs.allpts[i],
        y: rs.allpts[i + 1]
      });
    }
  } else if (et === 'haystack') {
    var hpts = rs.haystackPts;

    _p.rstyle.haystackPts = [{ x: hpts[0], y: hpts[1] }, { x: hpts[2], y: hpts[3] }];
  }

  _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
};

BRp.recalculateEdgeProjections = function (edges) {
  this.findEdgeControlPoints(edges);
};

module.exports = BRp;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

var BRp = {};

[__webpack_require__(87), __webpack_require__(88), __webpack_require__(89), __webpack_require__(90), __webpack_require__(91), __webpack_require__(93), __webpack_require__(94), __webpack_require__(95), __webpack_require__(96)].forEach(function (props) {
  util.extend(BRp, props);
});

module.exports = BRp;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);
var is = __webpack_require__(0);
var util = __webpack_require__(1);

var BRp = {};

BRp.recalculateNodeLabelProjection = function (node) {
  var content = node.pstyle('label').strValue;

  if (is.emptyString(content)) {
    return;
  }

  var textX, textY;
  var _p = node._private;
  var nodeWidth = node.width();
  var nodeHeight = node.height();
  var padding = node.padding();
  var nodePos = node.position();
  var textHalign = node.pstyle('text-halign').strValue;
  var textValign = node.pstyle('text-valign').strValue;
  var rs = _p.rscratch;
  var rstyle = _p.rstyle;

  switch (textHalign) {
    case 'left':
      textX = nodePos.x - nodeWidth / 2 - padding;
      break;

    case 'right':
      textX = nodePos.x + nodeWidth / 2 + padding;
      break;

    default:
      // e.g. center
      textX = nodePos.x;
  }

  switch (textValign) {
    case 'top':
      textY = nodePos.y - nodeHeight / 2 - padding;
      break;

    case 'bottom':
      textY = nodePos.y + nodeHeight / 2 + padding;
      break;

    default:
      // e.g. middle
      textY = nodePos.y;
  }

  rs.labelX = textX;
  rs.labelY = textY;
  rstyle.labelX = textX;
  rstyle.labelY = textY;

  this.applyLabelDimensions(node);
};

BRp.recalculateEdgeLabelProjections = function (edge) {
  var p;
  var _p = edge._private;
  var rs = _p.rscratch;
  var r = this;
  var content = {
    mid: edge.pstyle('label').strValue,
    source: edge.pstyle('source-label').strValue,
    target: edge.pstyle('target-label').strValue
  };

  if (content.mid || content.source || content.target) {
    // then we have to calculate...
  } else {
      return; // no labels => no calcs
    }

  // add center point to style so bounding box calculations can use it
  //
  p = {
    x: rs.midX,
    y: rs.midY
  };

  var setRs = function setRs(propName, prefix, value) {
    util.setPrefixedProperty(_p.rscratch, propName, prefix, value);
    util.setPrefixedProperty(_p.rstyle, propName, prefix, value);
  };

  setRs('labelX', null, p.x);
  setRs('labelY', null, p.y);

  var createControlPointInfo = function createControlPointInfo() {
    if (createControlPointInfo.cache) {
      return createControlPointInfo.cache;
    } // use cache so only 1x per edge

    var ctrlpts = [];

    // store each ctrlpt info init
    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
      var p0 = { x: rs.allpts[i], y: rs.allpts[i + 1] };
      var p1 = { x: rs.allpts[i + 2], y: rs.allpts[i + 3] }; // ctrlpt
      var p2 = { x: rs.allpts[i + 4], y: rs.allpts[i + 5] };

      ctrlpts.push({
        p0: p0,
        p1: p1,
        p2: p2,
        startDist: 0,
        length: 0,
        segments: []
      });
    }

    var bpts = _p.rstyle.bezierPts;
    var nProjs = r.bezierProjPcts.length;

    function addSegment(cp, p0, p1, t0, t1) {
      var length = math.dist(p0, p1);
      var prevSegment = cp.segments[cp.segments.length - 1];
      var segment = {
        p0: p0,
        p1: p1,
        t0: t0,
        t1: t1,
        startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,
        length: length
      };

      cp.segments.push(segment);

      cp.length += length;
    }

    // update each ctrlpt with segment info
    for (var i = 0; i < ctrlpts.length; i++) {
      var cp = ctrlpts[i];
      var prevCp = ctrlpts[i - 1];

      if (prevCp) {
        cp.startDist = prevCp.startDist + prevCp.length;
      }

      addSegment(cp, cp.p0, bpts[i * nProjs], 0, r.bezierProjPcts[0]); // first

      for (var j = 0; j < nProjs - 1; j++) {
        addSegment(cp, bpts[i * nProjs + j], bpts[i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);
      }

      addSegment(cp, bpts[i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last
    }

    return createControlPointInfo.cache = ctrlpts;
  };

  var calculateEndProjection = function calculateEndProjection(prefix) {
    var angle;
    var isSrc = prefix === 'source';

    if (!content[prefix]) {
      return;
    }

    var offset = edge.pstyle(prefix + '-text-offset').pfValue;

    var lineAngle = function lineAngle(p0, p1) {
      var dx = p1.x - p0.x;
      var dy = p1.y - p0.y;

      return Math.atan(dy / dx);
    };

    var bezierAngle = function bezierAngle(p0, p1, p2, t) {
      var t0 = math.bound(0, t - 0.001, 1);
      var t1 = math.bound(0, t + 0.001, 1);

      var lp0 = math.qbezierPtAt(p0, p1, p2, t0);
      var lp1 = math.qbezierPtAt(p0, p1, p2, t1);

      return lineAngle(lp0, lp1);
    };

    switch (rs.edgeType) {
      case 'self':
      case 'compound':
      case 'bezier':
      case 'multibezier':
        var cps = createControlPointInfo();
        var selected;
        var startDist = 0;
        var totalDist = 0;

        // find the segment we're on
        for (var i = 0; i < cps.length; i++) {
          var cp = cps[isSrc ? i : cps.length - 1 - i];

          for (var j = 0; j < cp.segments.length; j++) {
            var seg = cp.segments[isSrc ? j : cp.segments.length - 1 - j];
            var lastSeg = i === cps.length - 1 && j === cp.segments.length - 1;

            startDist = totalDist;
            totalDist += seg.length;

            if (totalDist >= offset || lastSeg) {
              selected = { cp: cp, segment: seg };
              break;
            }
          }

          if (selected) {
            break;
          }
        }

        var cp = selected.cp;
        var seg = selected.segment;
        var tSegment = (offset - startDist) / seg.length;
        var segDt = seg.t1 - seg.t0;
        var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;

        t = math.bound(0, t, 1);
        p = math.qbezierPtAt(cp.p0, cp.p1, cp.p2, t);
        angle = bezierAngle(cp.p0, cp.p1, cp.p2, t, p);

        break;

      case 'straight':
      case 'segments':
      case 'haystack':
        var d = 0,
            di,
            d0;
        var p0, p1;
        var l = rs.allpts.length;

        for (var i = 0; i + 3 < l; i += 2) {
          if (isSrc) {
            p0 = { x: rs.allpts[i], y: rs.allpts[i + 1] };
            p1 = { x: rs.allpts[i + 2], y: rs.allpts[i + 3] };
          } else {
            p0 = { x: rs.allpts[l - 2 - i], y: rs.allpts[l - 1 - i] };
            p1 = { x: rs.allpts[l - 4 - i], y: rs.allpts[l - 3 - i] };
          }

          di = math.dist(p0, p1);
          d0 = d;
          d += di;

          if (d >= offset) {
            break;
          }
        }

        var pD = offset - d0;
        var t = pD / di;

        t = math.bound(0, t, 1);
        p = math.lineAt(p0, p1, t);
        angle = lineAngle(p0, p1);

        break;
    }

    setRs('labelX', prefix, p.x);
    setRs('labelY', prefix, p.y);
    setRs('labelAutoAngle', prefix, angle);
  };

  calculateEndProjection('source');
  calculateEndProjection('target');

  this.applyLabelDimensions(edge);
};

BRp.applyLabelDimensions = function (ele) {
  this.applyPrefixedLabelDimensions(ele);

  if (ele.isEdge()) {
    this.applyPrefixedLabelDimensions(ele, 'source');
    this.applyPrefixedLabelDimensions(ele, 'target');
  }
};

BRp.applyPrefixedLabelDimensions = function (ele, prefix) {
  var _p = ele._private;

  var text = this.getLabelText(ele, prefix);
  var labelDims = this.calculateLabelDimensions(ele, text);

  util.setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, labelDims.width);
  util.setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, labelDims.width);

  util.setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, labelDims.height);
  util.setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, labelDims.height);
};

BRp.getLabelText = function (ele, prefix) {
  var _p = ele._private;
  var pfd = prefix ? prefix + '-' : '';
  var text = ele.pstyle(pfd + 'label').strValue;
  var textTransform = ele.pstyle('text-transform').value;
  var rscratch = function rscratch(propName, value) {
    if (value) {
      util.setPrefixedProperty(_p.rscratch, propName, prefix, value);
      return value;
    } else {
      return util.getPrefixedProperty(_p.rscratch, propName, prefix);
    }
  };

  if (textTransform == 'none') {
    // passthrough
  } else if (textTransform == 'uppercase') {
    text = text.toUpperCase();
  } else if (textTransform == 'lowercase') {
    text = text.toLowerCase();
  }

  var wrapStyle = ele.pstyle('text-wrap').value;

  if (wrapStyle === 'wrap') {
    //console.log('wrap');

    var labelKey = rscratch('labelKey');

    // save recalc if the label is the same as before
    if (labelKey && rscratch('labelWrapKey') === labelKey) {
      // console.log('wrap cache hit');
      return rscratch('labelWrapCachedText');
    }
    // console.log('wrap cache miss');

    var lines = text.split('\n');
    var maxW = ele.pstyle('text-max-width').pfValue;
    var wrappedLines = [];

    for (var l = 0; l < lines.length; l++) {
      var line = lines[l];
      var lineDims = this.calculateLabelDimensions(ele, line, 'line=' + line);
      var lineW = lineDims.width;

      if (lineW > maxW) {
        // line is too long
        var words = line.split(/\s+/); // NB: assume collapsed whitespace into single space
        var subline = '';

        for (var w = 0; w < words.length; w++) {
          var word = words[w];
          var testLine = subline.length === 0 ? word : subline + ' ' + word;
          var testDims = this.calculateLabelDimensions(ele, testLine, 'testLine=' + testLine);
          var testW = testDims.width;

          if (testW <= maxW) {
            // word fits on current line
            subline += word + ' ';
          } else {
            // word starts new line
            wrappedLines.push(subline);
            subline = word + ' ';
          }
        }

        // if there's remaining text, put it in a wrapped line
        if (!subline.match(/^\s+$/)) {
          wrappedLines.push(subline);
        }
      } else {
        // line is already short enough
        wrappedLines.push(line);
      }
    } // for

    rscratch('labelWrapCachedLines', wrappedLines);
    text = rscratch('labelWrapCachedText', wrappedLines.join('\n'));
    rscratch('labelWrapKey', labelKey);

    // console.log(text)
  } else if (wrapStyle === 'ellipsis') {
    var maxW = ele.pstyle('text-max-width').pfValue;
    var ellipsized = '';
    var ellipsis = '\u2026';
    var incLastCh = false;

    for (var i = 0; i < text.length; i++) {
      var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;

      if (widthWithNextCh > maxW) {
        break;
      }

      ellipsized += text[i];

      if (i === text.length - 1) {
        incLastCh = true;
      }
    }

    if (!incLastCh) {
      ellipsized += ellipsis;
    }

    return ellipsized;
  } // if ellipsize

  return text;
};

BRp.calculateLabelDimensions = function (ele, text, extraKey) {
  var r = this;

  var cacheKey = ele._private.labelStyleKey + '$@$' + text;

  if (extraKey) {
    cacheKey += '$@$' + extraKey;
  }

  var cache = r.labelDimCache || (r.labelDimCache = {});

  if (cache[cacheKey]) {
    return cache[cacheKey];
  }

  var sizeMult = 1; // increase the scale to increase accuracy w.r.t. zoomed text
  var fStyle = ele.pstyle('font-style').strValue;
  var size = sizeMult * ele.pstyle('font-size').pfValue + 'px';
  var family = ele.pstyle('font-family').strValue;
  var weight = ele.pstyle('font-weight').strValue;

  var div = this.labelCalcDiv;

  if (!div) {
    div = this.labelCalcDiv = document.createElement('div'); // eslint-disable-line no-undef
    document.body.appendChild(div); // eslint-disable-line no-undef
  }

  var ds = div.style;

  // from ele style
  ds.fontFamily = family;
  ds.fontStyle = fStyle;
  ds.fontSize = size;
  ds.fontWeight = weight;

  // forced style
  ds.position = 'absolute';
  ds.left = '-9999px';
  ds.top = '-9999px';
  ds.zIndex = '-1';
  ds.visibility = 'hidden';
  ds.pointerEvents = 'none';
  ds.padding = '0';
  ds.lineHeight = '1';

  if (ele.pstyle('text-wrap').value === 'wrap') {
    ds.whiteSpace = 'pre'; // so newlines are taken into account
  } else {
    ds.whiteSpace = 'normal';
  }

  // put label content in div
  div.textContent = text;

  cache[cacheKey] = {
    width: Math.ceil(div.clientWidth / sizeMult),
    height: Math.ceil(div.clientHeight / sizeMult)
  };

  return cache[cacheKey];
};

BRp.calculateLabelAngles = function (ele) {
  var _p = ele._private;
  var rs = _p.rscratch;
  var isEdge = ele.isEdge();
  var rot = ele.pstyle('text-rotation');
  var rotStr = rot.strValue;

  if (rotStr === 'none') {
    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;
  } else if (isEdge && rotStr === 'autorotate') {
    rs.labelAngle = Math.atan(rs.midDispY / rs.midDispX);
    rs.sourceLabelAngle = rs.sourceLabelAutoAngle;
    rs.targetLabelAngle = rs.targetLabelAutoAngle;
  } else if (rotStr === 'autorotate') {
    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;
  } else {
    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = rot.pfValue;
  }
};

module.exports = BRp;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BRp = {};

BRp.getNodeShape = function (node) {
  var r = this;
  var shape = node.pstyle('shape').value;

  if (node.isParent()) {
    if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'cutrectangle' || shape === 'barrel') {
      return shape;
    } else {
      return 'rectangle';
    }
  }

  if (shape === 'polygon') {
    var points = node.pstyle('shape-polygon-points').value;

    return r.nodeShapes.makePolygon(points).name;
  }

  return shape;
};

module.exports = BRp;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BRp = {};

BRp.registerCalculationListeners = function () {
  var cy = this.cy;
  var elesToUpdate = cy.collection();
  var r = this;

  var enqueue = function enqueue(eles, e) {
    var dirtyStyleCaches = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    elesToUpdate.merge(eles);

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var _p = ele._private;
      var rstyle = _p.rstyle;

      if (dirtyStyleCaches) {
        rstyle.clean = false;
        _p.bbCache = null;
      }

      var evts = rstyle.dirtyEvents = rstyle.dirtyEvents || { length: 0 };

      if (!evts[e.type]) {
        evts[e.type] = true;
        evts.length++;
      }
    }
  };

  r.binder(cy)
  // nodes

  .on('position.* style.* free.* bounds.*', 'node', function onDirtyModNode(e) {
    var node = e.target;

    enqueue(node, e);
    enqueue(node.connectedEdges(), e);
  }).on('add.*', 'node', function onDirtyAddNode(e) {
    var ele = e.target;

    enqueue(ele, e);
  }).on('background.*', 'node', function onDirtyBgNode(e) {
    var ele = e.target;

    enqueue(ele, e, false);
  })

  // edges

  .on('add.* style.*', 'edge', function onDirtyEdge(e) {
    var edge = e.target;

    enqueue(edge, e);
    enqueue(edge.parallelEdges(), e);
  }).on('remove.*', 'edge', function onDirtyRemoveEdge(e) {
    var edge = e.target;
    var pEdges = edge.parallelEdges();

    for (var i = 0; i < pEdges.length; i++) {
      var pEdge = pEdges[i];

      if (!pEdge.removed()) {
        enqueue(pEdge, e);
      }
    }
  })

  // manual dirtying

  .on('dirty.*', 'node', function onDirtyEle(e) {
    var ele = e.target;

    enqueue(ele, e);
  });

  var updateEleCalcs = function updateEleCalcs(willDraw) {
    if (willDraw) {
      var fns = r.onUpdateEleCalcsFns;

      if (fns) {
        for (var i = 0; i < fns.length; i++) {
          var fn = fns[i];

          fn(willDraw, elesToUpdate);
        }
      }

      r.recalculateRenderedStyle(elesToUpdate, false);

      for (var i = 0; i < elesToUpdate.length; i++) {
        elesToUpdate[i]._private.rstyle.dirtyEvents = null;
      }

      elesToUpdate = cy.collection();
    }
  };

  r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);
};

BRp.onUpdateEleCalcs = function (fn) {
  var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];

  fns.push(fn);
};

BRp.recalculateRenderedStyle = function (eles, useCache) {
  var edges = [];
  var nodes = [];

  // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()
  if (this.destroyed) {
    return;
  }

  // use cache by default for perf
  if (useCache === undefined) {
    useCache = true;
  }

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var _p = ele._private;
    var rstyle = _p.rstyle;

    // only update if dirty and in graph
    if (useCache && rstyle.clean || ele.removed()) {
      continue;
    }

    // only update if not display: none
    if (ele.pstyle('display').value === 'none') {
      continue;
    }

    if (_p.group === 'nodes') {
      nodes.push(ele);
    } else {
      // edges
      edges.push(ele);
    }

    rstyle.clean = true;
    // rstyle.dirtyEvents = null;
  }

  // update node data from projections
  for (var i = 0; i < nodes.length; i++) {
    var ele = nodes[i];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var pos = ele.position();

    this.recalculateNodeLabelProjection(ele);

    rstyle.nodeX = pos.x;
    rstyle.nodeY = pos.y;
    rstyle.nodeW = ele.pstyle('width').pfValue;
    rstyle.nodeH = ele.pstyle('height').pfValue;
  }

  this.recalculateEdgeProjections(edges);

  // update edge data from projections
  for (var i = 0; i < edges.length; i++) {
    var ele = edges[i];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var rs = _p.rscratch;

    this.recalculateEdgeLabelProjections(ele);

    // update rstyle positions
    rstyle.srcX = rs.arrowStartX;
    rstyle.srcY = rs.arrowStartY;
    rstyle.tgtX = rs.arrowEndX;
    rstyle.tgtY = rs.arrowEndY;
    rstyle.midX = rs.midX;
    rstyle.midY = rs.midY;
    rstyle.labelAngle = rs.labelAngle;
    rstyle.sourceLabelAngle = rs.sourceLabelAngle;
    rstyle.targetLabelAngle = rs.targetLabelAngle;
  }
};

module.exports = BRp;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var zIndexSort = __webpack_require__(14);

var BRp = {};

BRp.updateCachedGrabbedEles = function () {
  var eles = this.cachedZSortedEles;

  if (!eles) {
    // just let this be recalculated on the next z sort tick
    return;
  }

  eles.drag = [];
  eles.nondrag = [];

  var grabTargets = [];

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var rs = ele._private.rscratch;

    if (ele.grabbed() && !ele.isParent()) {
      grabTargets.push(ele);
    } else if (rs.inDragLayer) {
      eles.drag.push(ele);
    } else {
      eles.nondrag.push(ele);
    }
  }

  // put the grab target nodes last so it's on top of its neighbourhood
  for (var i = 0; i < grabTargets.length; i++) {
    var ele = grabTargets[i];

    eles.drag.push(ele);
  }
};

BRp.invalidateCachedZSortedEles = function () {
  this.cachedZSortedEles = null;
};

BRp.getCachedZSortedEles = function (forceRecalc) {
  if (forceRecalc || !this.cachedZSortedEles) {
    //console.time('cachezorder')

    var eles = this.cy.mutableElements().toArray();

    eles.sort(zIndexSort);

    eles.interactive = eles.filter(function (ele) {
      return ele.interactive();
    });

    this.cachedZSortedEles = eles;

    this.updateCachedGrabbedEles();
  } else {
    eles = this.cachedZSortedEles;
  }

  return eles;
};

module.exports = BRp;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BRp = {};

BRp.getCachedImage = function (url, crossOrigin, onLoad) {
  var r = this;
  var imageCache = r.imageCache = r.imageCache || {};
  var cache = imageCache[url];

  if (cache) {
    if (!cache.image.complete) {
      cache.image.addEventListener('load', onLoad);
    }

    return cache.image;
  } else {
    cache = imageCache[url] = imageCache[url] || {};

    var image = cache.image = new Image(); // eslint-disable-line no-undef

    image.addEventListener('load', onLoad);
    image.addEventListener('error', function () {
      image.error = true;
    });

    // #1582 safari doesn't load data uris with crossOrigin properly
    // https://bugs.webkit.org/show_bug.cgi?id=123978
    var dataUriPrefix = 'data:';
    var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;
    if (!isDataUri) {
      image.crossOrigin = crossOrigin; // prevent tainted canvas
    }

    image.src = url;

    return image;
  }
};

module.exports = BRp;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);
var window = __webpack_require__(4);

var BaseRenderer = function BaseRenderer(options) {
  this.init(options);
};
var BR = BaseRenderer;
var BRp = BR.prototype;

BRp.clientFunctions = ['redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl'];

BRp.init = function (options) {
  var r = this;

  r.options = options;

  r.cy = options.cy;

  var ctr = r.container = options.cy.container();

  // prepend a stylesheet in the head such that
  if (window) {
    var document = window.document;
    var head = document.head;
    var stylesheetId = '__________cytoscape_stylesheet';
    var className = '__________cytoscape_container';
    var stylesheetAlreadyExists = document.getElementById(stylesheetId) != null;

    if (ctr.className.indexOf(className) < 0) {
      ctr.className = (ctr.className || '') + ' ' + className;
    }

    if (!stylesheetAlreadyExists) {
      var stylesheet = document.createElement('style');

      stylesheet.id = stylesheetId;
      stylesheet.innerHTML = '.' + className + ' { position: relative; }';

      head.insertBefore(stylesheet, head.children[0]); // first so lowest priority
    }

    var computedStyle = window.getComputedStyle(ctr);
    var position = computedStyle.getPropertyValue('position');

    if (position === 'static') {
      util.error('A Cytoscape container has style position:static and so can not use UI extensions properly');
    }
  }

  r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag

  r.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95];

  //--Pointer-related data
  r.hoverData = { down: null, last: null,
    downTime: null, triggerMode: null,
    dragging: false,
    initialPan: [null, null], capture: false };

  r.dragData = { possibleDragElements: [] };

  r.touchData = {
    start: null, capture: false,

    // These 3 fields related to tap, taphold events
    startPosition: [null, null, null, null, null, null],
    singleTouchStartTime: null,
    singleTouchMoved: true,

    now: [null, null, null, null, null, null],
    earlier: [null, null, null, null, null, null]
  };

  r.redraws = 0;
  r.showFps = options.showFps;
  r.debug = options.debug;

  r.hideEdgesOnViewport = options.hideEdgesOnViewport;
  r.hideLabelsOnViewport = options.hideLabelsOnViewport;
  r.textureOnViewport = options.textureOnViewport;
  r.wheelSensitivity = options.wheelSensitivity;
  r.motionBlurEnabled = options.motionBlur; // on by default
  r.forcedPixelRatio = options.pixelRatio;
  r.motionBlur = options.motionBlur; // for initial kick off
  r.motionBlurOpacity = options.motionBlurOpacity;
  r.motionBlurTransparency = 1 - r.motionBlurOpacity;
  r.motionBlurPxRatio = 1;
  r.mbPxRBlurry = 1; //0.8;
  r.minMbLowQualFrames = 4;
  r.fullQualityMb = false;
  r.clearedForMotionBlur = [];
  r.desktopTapThreshold = options.desktopTapThreshold;
  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
  r.touchTapThreshold = options.touchTapThreshold;
  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
  r.tapholdDuration = 500;

  r.bindings = [];
  r.beforeRenderCallbacks = [];
  r.beforeRenderPriorities = { // higher priority execs before lower one
    animations: 400,
    eleCalcs: 300,
    eleTxrDeq: 200,
    lyrTxrDeq: 100
  };

  r.registerNodeShapes();
  r.registerArrowShapes();
  r.registerCalculationListeners();
};

BRp.notify = function (params) {
  var types;
  var r = this;

  // the renderer can't be notified after it's destroyed
  if (this.destroyed) {
    return;
  }

  if (is.array(params.type)) {
    types = params.type;
  } else {
    types = [params.type];
  }

  var has = {};
  for (var i = 0; i < types.length; i++) {
    var type = types[i];

    has[type] = true;
  } // for

  if (has['init']) {
    r.load();
    return;
  }

  if (has['destroy']) {
    r.destroy();
    return;
  }

  if (has['add'] || has['remove'] || has['load'] || has['zorder']) {
    r.invalidateCachedZSortedEles();
  }

  if (has['viewport']) {
    r.redrawHint('select', true);
  }

  if (has['load'] || has['resize']) {
    r.invalidateContainerClientCoordsCache();
    r.matchCanvasSize(r.container);
  }

  r.redrawHint('eles', true);
  r.redrawHint('drag', true);

  this.startRenderLoop();

  this.redraw();
};

BRp.destroy = function () {
  var r = this;

  r.destroyed = true;

  r.cy.stopAnimationLoop();

  for (var i = 0; i < r.bindings.length; i++) {
    var binding = r.bindings[i];
    var b = binding;
    var tgt = b.target;

    (tgt.off || tgt.removeEventListener).apply(tgt, b.args);
  }

  r.bindings = [];
  r.beforeRenderCallbacks = [];
  r.onUpdateEleCalcsFns = [];

  if (r.removeObserver) {
    r.removeObserver.disconnect();
  }

  if (r.styleObserver) {
    r.styleObserver.disconnect();
  }

  if (r.labelCalcDiv) {
    try {
      document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef
    } catch (e) {
      // ie10 issue #1014
    }
  }
};

[__webpack_require__(86), __webpack_require__(92), __webpack_require__(97), __webpack_require__(99), __webpack_require__(100), __webpack_require__(101)].forEach(function (props) {
  util.extend(BRp, props);
});

module.exports = BR;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);
var math = __webpack_require__(2);
var Event = __webpack_require__(15);

var BRp = {};

BRp.registerBinding = function (target, event, handler, useCapture) {
  var args = Array.prototype.slice.apply(arguments, [1]); // copy
  var b = this.binder(target);

  return b.on.apply(b, args);
};

BRp.binder = function (tgt) {
  var r = this;

  var tgtIsDom = tgt === window || tgt === document || tgt === document.body || is.domElement(tgt);

  if (r.supportsPassiveEvents == null) {

    // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
    var supportsPassive = false;
    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function get() {
          supportsPassive = true;
        }
      });

      window.addEventListener('test', null, opts);
    } catch (err) {}

    r.supportsPassiveEvents = supportsPassive;
  }

  var on = function on(event, handler, useCapture) {
    var args = Array.prototype.slice.call(arguments);

    if (tgtIsDom && r.supportsPassiveEvents) {
      // replace useCapture w/ opts obj
      args[2] = {
        capture: useCapture != null ? useCapture : false,
        passive: false,
        once: false
      };
    }

    r.bindings.push({
      target: tgt,
      args: args
    });

    (tgt.addEventListener || tgt.on).apply(tgt, args);

    return this;
  };

  return {
    on: on,
    addEventListener: on,
    addListener: on,
    bind: on
  };
};

BRp.nodeIsDraggable = function (node) {
  return node && node.isNode() && !node.locked() && node.grabbable();
};

BRp.nodeIsGrabbable = function (node) {
  return this.nodeIsDraggable(node) && node.interactive();
};

BRp.load = function () {
  var r = this;

  var triggerEvents = function triggerEvents(target, names, e, props) {
    if (target == null) {
      target = r.cy;
    }

    for (var i = 0; i < names.length; i++) {
      var name = names[i];

      target.emit(util.extend({ originalEvent: e, type: name }, props));
    }
  };

  var isMultSelKeyDown = function isMultSelKeyDown(e) {
    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey
  };

  var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {
    var allowPassthrough = true;

    if (r.cy.hasCompoundNodes() && down && down.isEdge()) {
      // a compound node below the edge => no passthrough panning
      for (var i = 0; downs && i < downs.length; i++) {
        var down = downs[i];

        if (down.isNode() && down.isParent()) {
          allowPassthrough = false;
          break;
        }
      }
    } else {
      allowPassthrough = true;
    }

    return allowPassthrough;
  };

  var getDragListIds = function getDragListIds(opts) {
    var listHasId;

    if (opts.addToList && r.cy.hasCompoundNodes()) {
      // only needed for compound graphs
      if (!opts.addToList.hasId) {
        // build ids lookup if doesn't already exist
        opts.addToList.hasId = {};

        for (var i = 0; i < opts.addToList.length; i++) {
          var ele = opts.addToList[i];

          opts.addToList.hasId[ele.id()] = true;
        }
      }

      listHasId = opts.addToList.hasId;
    }

    return listHasId || {};
  };

  var setGrabbed = function setGrabbed(ele) {
    ele[0]._private.grabbed = true;
  };

  var setFreed = function setFreed(ele) {
    ele[0]._private.grabbed = false;
  };

  var setInDragLayer = function setInDragLayer(ele) {
    ele[0]._private.rscratch.inDragLayer = true;
  };

  var setOutDragLayer = function setOutDragLayer(ele) {
    ele[0]._private.rscratch.inDragLayer = false;
  };

  var setGrabTarget = function setGrabTarget(ele) {
    ele[0]._private.rscratch.isGrabTarget = true;
  };

  var removeGrabTarget = function removeGrabTarget(ele) {
    ele[0]._private.rscratch.isGrabTarget = false;
  };

  var addToDragList = function addToDragList(ele, opts) {
    var listHasId = getDragListIds(opts);

    if (!listHasId[ele.id()]) {
      opts.addToList.push(ele);
      listHasId[ele.id()] = true;

      setGrabbed(ele);
    }
  };

  // helper function to determine which child nodes and inner edges
  // of a compound node to be dragged as well as the grabbed and selected nodes
  var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {
    if (!node.cy().hasCompoundNodes()) {
      return;
    }

    if (opts.inDragLayer == null && opts.addToList == null) {
      return;
    } // nothing to do

    var innerNodes = node.descendants();

    if (opts.inDragLayer) {
      innerNodes.forEach(setInDragLayer);
      innerNodes.connectedEdges().forEach(setInDragLayer);
    }

    if (opts.addToList) {
      innerNodes.forEach(function (ele) {
        addToDragList(ele, opts);
      });
    }
  };

  // adds the given nodes and its neighbourhood to the drag layer
  var addNodesToDrag = function addNodesToDrag(nodes, opts) {
    opts = opts || {};

    var hasCompoundNodes = nodes.cy().hasCompoundNodes();

    if (opts.inDragLayer) {
      nodes.forEach(setInDragLayer);

      nodes.neighborhood().stdFilter(function (ele) {
        return !hasCompoundNodes || ele.isEdge();
      }).forEach(setInDragLayer);
    }

    if (opts.addToList) {
      nodes.forEach(function (ele) {
        addToDragList(ele, opts);
      });
    }

    addDescendantsToDrag(nodes, opts); // always add to drag

    // also add nodes and edges related to the topmost ancestor
    updateAncestorsInDragLayer(nodes, {
      inDragLayer: opts.inDragLayer
    });

    r.updateCachedGrabbedEles();
  };

  var addNodeToDrag = addNodesToDrag;

  var freeDraggedElements = function freeDraggedElements(grabbedEles) {
    if (!grabbedEles) {
      return;
    }

    grabbedEles.hasId = {}; // clear the id list

    // just go over all elements rather than doing a bunch of (possibly expensive) traversals
    r.getCachedZSortedEles().forEach(function (ele) {
      setFreed(ele);
      setOutDragLayer(ele);
      removeGrabTarget(ele);
    });

    r.updateCachedGrabbedEles();
  };

  // helper function to determine which ancestor nodes and edges should go
  // to the drag layer (or should be removed from drag layer).
  var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {

    if (opts.inDragLayer == null && opts.addToList == null) {
      return;
    } // nothing to do

    if (!node.cy().hasCompoundNodes()) {
      return;
    }

    // find top-level parent
    var parent = node.ancestors().orphans();

    // no parent node: no nodes to add to the drag layer
    if (parent.same(node)) {
      return;
    }

    var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());

    var edges = nodes.connectedEdges();

    if (opts.inDragLayer) {
      edges.forEach(setInDragLayer);
      nodes.forEach(setInDragLayer);
    }

    if (opts.addToList) {
      nodes.forEach(function (ele) {
        addToDragList(ele, opts);
      });
    }
  };

  var haveMutationsApi = typeof MutationObserver !== 'undefined';

  // watch for when the cy container is removed from the dom
  if (haveMutationsApi) {
    r.removeObserver = new MutationObserver(function (mutns) {
      // eslint-disable-line no-undef
      for (var i = 0; i < mutns.length; i++) {
        var mutn = mutns[i];
        var rNodes = mutn.removedNodes;

        if (rNodes) {
          for (var j = 0; j < rNodes.length; j++) {
            var rNode = rNodes[j];

            if (rNode === r.container) {
              r.destroy();
              break;
            }
          }
        }
      }
    });

    if (r.container.parentNode) {
      r.removeObserver.observe(r.container.parentNode, { childList: true });
    }
  } else {
    r.registerBinding(r.container, 'DOMNodeRemoved', function (e) {
      r.destroy();
    });
  }

  var onResize = util.debounce(function () {
    r.cy.resize();
  }, 100);

  if (haveMutationsApi) {
    r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef

    r.styleObserver.observe(r.container, { attributes: true });
  }

  // auto resize
  r.registerBinding(window, 'resize', onResize); // eslint-disable-line no-undef

  var forEachUp = function forEachUp(domEle, fn) {
    while (domEle != null) {
      fn(domEle);

      domEle = domEle.parentNode;
    }
  };

  var invalidateCoords = function invalidateCoords() {
    r.invalidateContainerClientCoordsCache();
  };

  forEachUp(r.container, function (domEle) {
    r.registerBinding(domEle, 'transitionend', invalidateCoords);
    r.registerBinding(domEle, 'animationend', invalidateCoords);
    r.registerBinding(domEle, 'scroll', invalidateCoords);
  });

  // stop right click menu from appearing on cy
  r.registerBinding(r.container, 'contextmenu', function (e) {
    e.preventDefault();
  });

  var inBoxSelection = function inBoxSelection() {
    return r.selection[4] !== 0;
  };

  var eventInContainer = function eventInContainer(e) {
    // save cycles if mouse events aren't to be captured
    var containerPageCoords = r.findContainerClientCoords();
    var x = containerPageCoords[0];
    var y = containerPageCoords[1];
    var width = containerPageCoords[2];
    var height = containerPageCoords[3];

    var positions = e.touches ? e.touches : [e];
    var atLeastOnePosInside = false;

    for (var i = 0; i < positions.length; i++) {
      var p = positions[i];

      if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {
        atLeastOnePosInside = true;
        break;
      }
    }

    if (!atLeastOnePosInside) {
      return false;
    }

    var container = r.container;
    var target = e.target;
    var tParent = target.parentNode;
    var containerIsTarget = false;

    while (tParent) {
      if (tParent === container) {
        containerIsTarget = true;
        break;
      }

      tParent = tParent.parentNode;
    }

    if (!containerIsTarget) {
      return false;
    } // if target is outisde cy container, then this event is not for us

    return true;
  };

  // Primary key
  r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {
    if (!eventInContainer(e)) {
      return;
    }

    e.preventDefault();
    r.hoverData.capture = true;
    r.hoverData.which = e.which;

    var cy = r.cy;
    var gpos = [e.clientX, e.clientY];
    var pos = r.projectIntoViewport(gpos[0], gpos[1]);
    var select = r.selection;
    var nears = r.findNearestElements(pos[0], pos[1], true, false);
    var near = nears[0];
    var draggedElements = r.dragData.possibleDragElements;

    r.hoverData.mdownPos = pos;
    r.hoverData.mdownGPos = gpos;

    var checkForTaphold = function checkForTaphold() {
      r.hoverData.tapholdCancelled = false;

      clearTimeout(r.hoverData.tapholdTimeout);

      r.hoverData.tapholdTimeout = setTimeout(function () {

        if (r.hoverData.tapholdCancelled) {
          return;
        } else {
          var ele = r.hoverData.down;

          if (ele) {
            ele.emit({
              originalEvent: e,
              type: 'taphold',
              position: { x: pos[0], y: pos[1] }
            });
          } else {
            cy.emit({
              originalEvent: e,
              type: 'taphold',
              position: { x: pos[0], y: pos[1] }
            });
          }
        }
      }, r.tapholdDuration);
    };

    // Right click button
    if (e.which == 3) {

      r.hoverData.cxtStarted = true;

      var cxtEvt = {
        originalEvent: e,
        type: 'cxttapstart',
        position: { x: pos[0], y: pos[1] }
      };

      if (near) {
        near.activate();
        near.emit(cxtEvt);

        r.hoverData.down = near;
      } else {
        cy.emit(cxtEvt);
      }

      r.hoverData.downTime = new Date().getTime();
      r.hoverData.cxtDragged = false;

      // Primary button
    } else if (e.which == 1) {

      if (near) {
        near.activate();
      }

      // Element dragging
      {
        // If something is under the cursor and it is draggable, prepare to grab it
        if (near != null) {

          if (r.nodeIsGrabbable(near)) {

            var makeEvent = function makeEvent(type) {
              return {
                originalEvent: e,
                type: type,
                position: { x: pos[0], y: pos[1] }
              };
            };

            var triggerGrab = function triggerGrab(ele) {
              ele.emit(makeEvent('grab'));
            };

            setGrabTarget(near);

            if (!near.selected()) {

              draggedElements = r.dragData.possibleDragElements = [];
              addNodeToDrag(near, { addToList: draggedElements });

              near.emit(makeEvent('grabon')).emit(makeEvent('grab'));
            } else {
              draggedElements = r.dragData.possibleDragElements = [];

              var selectedNodes = cy.$(function (ele) {
                return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);
              });

              addNodesToDrag(selectedNodes, { addToList: draggedElements });

              near.emit(makeEvent('grabon'));

              selectedNodes.forEach(triggerGrab);
            }

            r.redrawHint('eles', true);
            r.redrawHint('drag', true);
          }
        }

        r.hoverData.down = near;
        r.hoverData.downs = nears;
        r.hoverData.downTime = new Date().getTime();
      }

      triggerEvents(near, ['mousedown', 'tapstart', 'vmousedown'], e, {
        position: { x: pos[0], y: pos[1] }
      });

      if (near == null) {
        select[4] = 1;

        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };

        r.redrawHint('select', true);

        r.redraw();
      } else if (near.isEdge()) {
        select[4] = 1; // for future pan
      }

      checkForTaphold();
    }

    // Initialize selection box coordinates
    select[0] = select[2] = pos[0];
    select[1] = select[3] = pos[1];
  }, false);

  r.registerBinding(window, 'mousemove', function mousemoveHandler(e) {
    // eslint-disable-line no-undef
    var capture = r.hoverData.capture;

    if (!capture && !eventInContainer(e)) {
      return;
    }

    var preventDefault = false;
    var cy = r.cy;
    var zoom = cy.zoom();
    var gpos = [e.clientX, e.clientY];
    var pos = r.projectIntoViewport(gpos[0], gpos[1]);
    var mdownPos = r.hoverData.mdownPos;
    var mdownGPos = r.hoverData.mdownGPos;
    var select = r.selection;

    var near = null;
    if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {
      near = r.findNearestElement(pos[0], pos[1], true, false);
    }
    var last = r.hoverData.last;
    var down = r.hoverData.down;

    var disp = [pos[0] - select[2], pos[1] - select[3]];

    var draggedElements = r.dragData.possibleDragElements;

    var isOverThresholdDrag;

    if (mdownGPos) {
      var dx = gpos[0] - mdownGPos[0];
      var dx2 = dx * dx;
      var dy = gpos[1] - mdownGPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;

      r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;
    }

    var multSelKeyDown = isMultSelKeyDown(e);

    if (isOverThresholdDrag) {
      r.hoverData.tapholdCancelled = true;
    }

    var updateDragDelta = function updateDragDelta() {
      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

      if (dragDelta.length === 0) {
        dragDelta.push(disp[0]);
        dragDelta.push(disp[1]);
      } else {
        dragDelta[0] += disp[0];
        dragDelta[1] += disp[1];
      }
    };

    preventDefault = true;

    triggerEvents(near, ['mousemove', 'vmousemove', 'tapdrag'], e, {
      position: { x: pos[0], y: pos[1] }
    });

    var goIntoBoxMode = function goIntoBoxMode() {
      r.data.bgActivePosistion = undefined;

      if (!r.hoverData.selecting) {
        cy.emit('boxstart');
      }

      select[4] = 1;
      r.hoverData.selecting = true;

      r.redrawHint('select', true);
      r.redraw();
    };

    // trigger context drag if rmouse down
    if (r.hoverData.which === 3) {
      // but only if over threshold
      if (isOverThresholdDrag) {
        var cxtEvt = {
          originalEvent: e,
          type: 'cxtdrag',
          position: { x: pos[0], y: pos[1] }
        };

        if (down) {
          down.emit(cxtEvt);
        } else {
          cy.emit(cxtEvt);
        }

        r.hoverData.cxtDragged = true;

        if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {

          if (r.hoverData.cxtOver) {
            r.hoverData.cxtOver.emit({
              originalEvent: e,
              type: 'cxtdragout',
              position: { x: pos[0], y: pos[1] }
            });
          }

          r.hoverData.cxtOver = near;

          if (near) {
            near.emit({
              originalEvent: e,
              type: 'cxtdragover',
              position: { x: pos[0], y: pos[1] }
            });
          }
        }
      }

      // Check if we are drag panning the entire graph
    } else if (r.hoverData.dragging) {
      preventDefault = true;

      if (cy.panningEnabled() && cy.userPanningEnabled()) {
        var deltaP;

        if (r.hoverData.justStartedPan) {
          var mdPos = r.hoverData.mdownPos;

          deltaP = {
            x: (pos[0] - mdPos[0]) * zoom,
            y: (pos[1] - mdPos[1]) * zoom
          };

          r.hoverData.justStartedPan = false;
        } else {
          deltaP = {
            x: disp[0] * zoom,
            y: disp[1] * zoom
          };
        }

        cy.panBy(deltaP);

        r.hoverData.dragged = true;
      }

      // Needs reproject due to pan changing viewport
      pos = r.projectIntoViewport(e.clientX, e.clientY);

      // Checks primary button down & out of time & mouse not moved much
    } else if (select[4] == 1 && (down == null || down.isEdge())) {

      if (isOverThresholdDrag) {

        if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {
          goIntoBoxMode();
        } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {
          var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);

          if (allowPassthrough) {
            r.hoverData.dragging = true;
            r.hoverData.justStartedPan = true;
            select[4] = 0;

            r.data.bgActivePosistion = math.array2point(mdownPos);

            r.redrawHint('select', true);
            r.redraw();
          }
        }

        if (down && down.isEdge() && down.active()) {
          down.unactivate();
        }
      }
    } else {
      if (down && down.isEdge() && down.active()) {
        down.unactivate();
      }

      if ((!down || !down.grabbed()) && near != last) {

        if (last) {
          triggerEvents(last, ['mouseout', 'tapdragout'], e, {
            position: { x: pos[0], y: pos[1] }
          });
        }

        if (near) {
          triggerEvents(near, ['mouseover', 'tapdragover'], e, {
            position: { x: pos[0], y: pos[1] }
          });
        }

        r.hoverData.last = near;
      }

      if (down) {

        if (isOverThresholdDrag) {
          // then we can take action

          if (cy.boxSelectionEnabled() && multSelKeyDown) {
            // then selection overrides
            if (down && down.grabbed()) {
              freeDraggedElements(draggedElements);

              down.emit('free');
            }

            goIntoBoxMode();
          } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {
            // drag node
            var justStartedDrag = !r.dragData.didDrag;

            if (justStartedDrag) {
              r.redrawHint('eles', true);
            }

            r.dragData.didDrag = true; // indicate that we actually did drag the node

            var toTrigger = [];

            // now, add the elements to the drag layer if not done already
            if (!r.hoverData.draggingEles) {
              addNodesToDrag(cy.collection(draggedElements), { inDragLayer: true });
            }

            for (var i = 0; i < draggedElements.length; i++) {
              var dEle = draggedElements[i];

              // Locked nodes not draggable, as well as non-visible nodes
              if (r.nodeIsDraggable(dEle) && dEle.grabbed()) {
                var dPos = dEle.position();

                toTrigger.push(dEle);

                if (is.number(disp[0]) && is.number(disp[1])) {
                  dPos.x += disp[0];
                  dPos.y += disp[1];

                  if (justStartedDrag) {
                    var dragDelta = r.hoverData.dragDelta;

                    if (dragDelta && is.number(dragDelta[0]) && is.number(dragDelta[1])) {
                      dPos.x += dragDelta[0];
                      dPos.y += dragDelta[1];
                    }
                  }
                }
              }
            }

            r.hoverData.draggingEles = true;

            var tcol = cy.collection(toTrigger);

            tcol.dirtyCompoundBoundsCache();
            tcol.emit('position drag');

            r.redrawHint('drag', true);
            r.redraw();
          }
        } else {
          // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
          updateDragDelta();
        }
      }

      // prevent the dragging from triggering text selection on the page
      preventDefault = true;
    }

    select[2] = pos[0];select[3] = pos[1];

    if (preventDefault) {
      if (e.stopPropagation) e.stopPropagation();
      if (e.preventDefault) e.preventDefault();
      return false;
    }
  }, false);

  r.registerBinding(window, 'mouseup', function mouseupHandler(e) {
    // eslint-disable-line no-undef
    var capture = r.hoverData.capture;
    if (!capture) {
      return;
    }
    r.hoverData.capture = false;

    var cy = r.cy;var pos = r.projectIntoViewport(e.clientX, e.clientY);var select = r.selection;
    var near = r.findNearestElement(pos[0], pos[1], true, false);
    var draggedElements = r.dragData.possibleDragElements;var down = r.hoverData.down;
    var multSelKeyDown = isMultSelKeyDown(e);

    if (r.data.bgActivePosistion) {
      r.redrawHint('select', true);
      r.redraw();
    }

    r.hoverData.tapholdCancelled = true;

    r.data.bgActivePosistion = undefined; // not active bg now

    if (down) {
      down.unactivate();
    }

    if (r.hoverData.which === 3) {
      var cxtEvt = {
        originalEvent: e,
        type: 'cxttapend',
        position: { x: pos[0], y: pos[1] }
      };

      if (down) {
        down.emit(cxtEvt);
      } else {
        cy.emit(cxtEvt);
      }

      if (!r.hoverData.cxtDragged) {
        var cxtTap = {
          originalEvent: e,
          type: 'cxttap',
          position: { x: pos[0], y: pos[1] }
        };

        if (down) {
          down.emit(cxtTap);
        } else {
          cy.emit(cxtTap);
        }
      }

      r.hoverData.cxtDragged = false;
      r.hoverData.which = null;
    } else if (r.hoverData.which === 1) {

      // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
      if (down == null && // not mousedown on node
      !r.dragData.didDrag // didn't move the node around
      && !r.hoverData.selecting // not box selection
      && !r.hoverData.dragged // didn't pan
      && !isMultSelKeyDown(e)) {

        cy.$(function (ele) {
          return ele.selected();
        }).unselect();

        if (draggedElements.length > 0) {
          r.redrawHint('eles', true);
        }

        r.dragData.possibleDragElements = draggedElements = [];
      }

      triggerEvents(near, ['mouseup', 'tapend', 'vmouseup'], e, {
        position: { x: pos[0], y: pos[1] }
      });

      if (!r.dragData.didDrag // didn't move a node around
      && !r.hoverData.dragged // didn't pan
      && !r.hoverData.selecting // not box selection
      && !r.hoverData.isOverThresholdDrag // didn't move too much
      ) {
          triggerEvents(down, ['click', 'tap', 'vclick'], e, {
            position: { x: pos[0], y: pos[1] }
          });
        }

      // Single selection
      if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {
        if (near != null && near._private.selectable) {

          if (r.hoverData.dragging) {
            // if panning, don't change selection state
          } else if (cy.selectionType() === 'additive' || multSelKeyDown) {
            if (near.selected()) {
              near.unselect();
            } else {
              near.select();
            }
          } else {
            if (!multSelKeyDown) {
              cy.$(':selected').unmerge(near).unselect();
              near.select();
            }
          }

          r.redrawHint('eles', true);
        }
      }

      if (r.hoverData.selecting) {
        var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));

        r.redrawHint('select', true);

        if (box.length > 0) {
          r.redrawHint('eles', true);
        }

        cy.emit('boxend');

        var eleWouldBeSelected = function eleWouldBeSelected(ele) {
          return ele.selectable() && !ele.selected();
        };

        if (cy.selectionType() === 'additive') {
          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
        } else {
          if (!multSelKeyDown) {
            cy.$(':selected').unmerge(box).unselect();
          }

          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
        }

        // always need redraw in case eles unselectable
        r.redraw();
      }

      // Cancel drag pan
      if (r.hoverData.dragging) {
        r.hoverData.dragging = false;

        r.redrawHint('select', true);
        r.redrawHint('eles', true);

        r.redraw();
      }

      if (!select[4]) {
        r.redrawHint('drag', true);
        r.redrawHint('eles', true);

        var downWasGrabbed = down && down.grabbed();

        freeDraggedElements(draggedElements);

        if (downWasGrabbed) {
          down.emit('free');
        }
      }
    } // else not right mouse

    select[4] = 0;r.hoverData.down = null;

    r.hoverData.cxtStarted = false;
    r.hoverData.draggingEles = false;
    r.hoverData.selecting = false;
    r.hoverData.isOverThresholdDrag = false;
    r.dragData.didDrag = false;
    r.hoverData.dragged = false;
    r.hoverData.dragDelta = [];
    r.hoverData.mdownPos = null;
    r.hoverData.mdownGPos = null;
  }, false);

  var wheelHandler = function wheelHandler(e) {

    if (r.scrollingPage) {
      return;
    } // while scrolling, ignore wheel-to-zoom

    var cy = r.cy;
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    var rpos = [pos[0] * cy.zoom() + cy.pan().x, pos[1] * cy.zoom() + cy.pan().y];

    if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {
      // if pan dragging or cxt dragging, wheel movements make no zoom
      e.preventDefault();
      return;
    }

    if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {
      e.preventDefault();

      r.data.wheelZooming = true;
      clearTimeout(r.data.wheelTimeout);
      r.data.wheelTimeout = setTimeout(function () {
        r.data.wheelZooming = false;

        r.redrawHint('eles', true);
        r.redraw();
      }, 150);

      var diff;

      if (e.deltaY != null) {
        diff = e.deltaY / -250;
      } else if (e.wheelDeltaY != null) {
        diff = e.wheelDeltaY / 1000;
      } else {
        diff = e.wheelDelta / 1000;
      }

      diff = diff * r.wheelSensitivity;

      var needsWheelFix = e.deltaMode === 1;
      if (needsWheelFix) {
        // fixes slow wheel events on ff/linux and ff/windows
        diff *= 33;
      }

      cy.zoom({
        level: cy.zoom() * Math.pow(10, diff),
        renderedPosition: { x: rpos[0], y: rpos[1] }
      });
    }
  };

  // Functions to help with whether mouse wheel should trigger zooming
  // --
  r.registerBinding(r.container, 'wheel', wheelHandler, true);

  // disable nonstandard wheel events
  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);
  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);
  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

  r.registerBinding(window, 'scroll', function scrollHandler(e) {
    // eslint-disable-line no-undef
    r.scrollingPage = true;

    clearTimeout(r.scrollingPageTimeout);
    r.scrollingPageTimeout = setTimeout(function () {
      r.scrollingPage = false;
    }, 250);
  }, true);

  // Functions to help with handling mouseout/mouseover on the Cytoscape container
  // Handle mouseout on Cytoscape container
  r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {
    var pos = r.projectIntoViewport(e.clientX, e.clientY);

    r.cy.emit({
      originalEvent: e,
      type: 'mouseout',
      position: { x: pos[0], y: pos[1] }
    });
  }, false);

  r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {
    var pos = r.projectIntoViewport(e.clientX, e.clientY);

    r.cy.emit({
      originalEvent: e,
      type: 'mouseover',
      position: { x: pos[0], y: pos[1] }
    });
  }, false);

  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
  var center1, modelCenter1; // center point on start pinch to zoom
  var offsetLeft, offsetTop;
  var containerWidth, containerHeight;
  var twoFingersStartInside;

  var distance = function distance(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  };

  var distanceSq = function distanceSq(x1, y1, x2, y2) {
    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
  };

  var touchstartHandler;
  r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {
    if (!eventInContainer(e)) {
      return;
    }

    r.touchData.capture = true;
    r.data.bgActivePosistion = undefined;

    var cy = r.cy;
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if (e.touches[0]) {
      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];
    }
    if (e.touches[1]) {
      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];
    }
    if (e.touches[2]) {
      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];
    }

    // record starting points for pinch-to-zoom
    if (e.touches[1]) {

      freeDraggedElements(r.dragData.touchDragEles);

      var offsets = r.findContainerClientCoords();
      offsetLeft = offsets[0];
      offsetTop = offsets[1];
      containerWidth = offsets[2];
      containerHeight = offsets[3];

      f1x1 = e.touches[0].clientX - offsetLeft;
      f1y1 = e.touches[0].clientY - offsetTop;

      f2x1 = e.touches[1].clientX - offsetLeft;
      f2y1 = e.touches[1].clientY - offsetTop;

      twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;

      var pan = cy.pan();
      var zoom = cy.zoom();

      distance1 = distance(f1x1, f1y1, f2x1, f2y1);
      distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);
      center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];
      modelCenter1 = [(center1[0] - pan.x) / zoom, (center1[1] - pan.y) / zoom];

      // consider context tap
      var cxtDistThreshold = 200;
      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
      if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {

        var near1 = r.findNearestElement(now[0], now[1], true, true);
        var near2 = r.findNearestElement(now[2], now[3], true, true);

        if (near1 && near1.isNode()) {
          near1.activate().emit({
            originalEvent: e,
            type: 'cxttapstart',
            position: { x: now[0], y: now[1] }
          });
          r.touchData.start = near1;
        } else if (near2 && near2.isNode()) {
          near2.activate().emit({
            originalEvent: e,
            type: 'cxttapstart',
            position: { x: now[0], y: now[1] }
          });
          r.touchData.start = near2;
        } else {
          cy.emit({
            originalEvent: e,
            type: 'cxttapstart',
            position: { x: now[0], y: now[1] }
          });
        }

        if (r.touchData.start) {
          r.touchData.start._private.grabbed = false;
        }
        r.touchData.cxt = true;
        r.touchData.cxtDragged = false;
        r.data.bgActivePosistion = undefined;

        r.redraw();
        return;
      }
    }

    if (e.touches[2]) {
      // ignore
    } else if (e.touches[1]) {
      // ignore
    } else if (e.touches[0]) {
      var nears = r.findNearestElements(now[0], now[1], true, true);
      var near = nears[0];

      if (near != null) {
        near.activate();

        r.touchData.start = near;
        r.touchData.starts = nears;

        if (r.nodeIsGrabbable(near)) {

          var draggedEles = r.dragData.touchDragEles = [];
          var selectedNodes = null;

          r.redrawHint('eles', true);
          r.redrawHint('drag', true);

          if (near.selected()) {
            // reset drag elements, since near will be added again

            selectedNodes = cy.$(function (ele) {
              return ele.selected() && r.nodeIsGrabbable(ele);
            });

            addNodesToDrag(selectedNodes, { addToList: draggedEles });
          } else {
            addNodeToDrag(near, { addToList: draggedEles });
          }

          setGrabTarget(near);

          var makeEvent = function makeEvent(type) {
            return {
              originalEvent: e,
              type: type,
              position: { x: now[0], y: now[1] }
            };
          };

          near.emit(makeEvent('grabon'));

          if (selectedNodes) {
            selectedNodes.forEach(function (n) {
              n.emit(makeEvent('grab'));
            });
          } else {
            near.emit(makeEvent('grab'));
          }
        }
      }

      triggerEvents(near, ['touchstart', 'tapstart', 'vmousedown'], e, {
        position: { x: now[0], y: now[1] }
      });

      if (near == null) {
        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };

        r.redrawHint('select', true);
        r.redraw();
      }

      // Tap, taphold
      // -----

      r.touchData.singleTouchMoved = false;
      r.touchData.singleTouchStartTime = +new Date();

      clearTimeout(r.touchData.tapholdTimeout);
      r.touchData.tapholdTimeout = setTimeout(function () {
        if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect
        && !r.touchData.selecting // box selection shouldn't allow taphold through
        ) {
            triggerEvents(r.touchData.start, ['taphold'], e, {
              position: { x: now[0], y: now[1] }
            });

            if (!r.touchData.start) {
              cy.$(':selected').unselect();
            }
          }
      }, r.tapholdDuration);
    }

    if (e.touches.length >= 1) {
      var sPos = r.touchData.startPosition = [];

      for (var i = 0; i < now.length; i++) {
        sPos[i] = earlier[i] = now[i];
      }

      var touch0 = e.touches[0];

      r.touchData.startGPosition = [touch0.clientX, touch0.clientY];
    }
  }, false);

  var touchmoveHandler;
  r.registerBinding(window, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {
    // eslint-disable-line no-undef
    var capture = r.touchData.capture;

    if (!capture && !eventInContainer(e)) {
      return;
    }

    var select = r.selection;
    var cy = r.cy;
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;
    var zoom = cy.zoom();

    if (e.touches[0]) {
      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];
    }
    if (e.touches[1]) {
      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];
    }
    if (e.touches[2]) {
      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];
    }

    var startGPos = r.touchData.startGPosition;
    var isOverThresholdDrag;

    if (capture && e.touches[0] && startGPos) {
      var disp = [];for (var j = 0; j < now.length; j++) {
        disp[j] = now[j] - earlier[j];
      }
      var dx = e.touches[0].clientX - startGPos[0];
      var dx2 = dx * dx;
      var dy = e.touches[0].clientY - startGPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;

      isOverThresholdDrag = dist2 >= r.touchTapThreshold2;
    }

    // context swipe cancelling
    if (capture && r.touchData.cxt) {
      e.preventDefault();

      var f1x2 = e.touches[0].clientX - offsetLeft,
          f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft,
          f2y2 = e.touches[1].clientY - offsetTop;
      // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
      var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);
      var factorSq = distance2Sq / distance1Sq;

      var distThreshold = 150;
      var distThresholdSq = distThreshold * distThreshold;
      var factorThreshold = 1.5;
      var factorThresholdSq = factorThreshold * factorThreshold;

      // cancel ctx gestures if the distance b/t the fingers increases
      if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {
        r.touchData.cxt = false;

        r.data.bgActivePosistion = undefined;

        r.redrawHint('select', true);

        var cxtEvt = {
          originalEvent: e,
          type: 'cxttapend',
          position: { x: now[0], y: now[1] }
        };

        if (r.touchData.start) {
          r.touchData.start.unactivate().emit(cxtEvt);

          r.touchData.start = null;
        } else {
          cy.emit(cxtEvt);
        }
      }
    }

    // context swipe
    if (capture && r.touchData.cxt) {
      var cxtEvt = {
        originalEvent: e,
        type: 'cxtdrag',
        position: { x: now[0], y: now[1] }
      };
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);

      if (r.touchData.start) {
        r.touchData.start.emit(cxtEvt);
      } else {
        cy.emit(cxtEvt);
      }

      if (r.touchData.start) {
        r.touchData.start._private.grabbed = false;
      }
      r.touchData.cxtDragged = true;

      var near = r.findNearestElement(now[0], now[1], true, true);

      if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {

        if (r.touchData.cxtOver) {
          r.touchData.cxtOver.emit({
            originalEvent: e,
            type: 'cxtdragout',
            position: { x: now[0], y: now[1] }
          });
        }

        r.touchData.cxtOver = near;

        if (near) {
          near.emit({
            originalEvent: e,
            type: 'cxtdragover',
            position: { x: now[0], y: now[1] }
          });
        }
      }

      // box selection
    } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {
      e.preventDefault();

      r.data.bgActivePosistion = undefined;

      this.lastThreeTouch = +new Date();

      if (!r.touchData.selecting) {
        cy.emit('boxstart');
      }

      r.touchData.selecting = true;

      r.redrawHint('select', true);

      if (!select || select.length === 0 || select[0] === undefined) {
        select[0] = (now[0] + now[2] + now[4]) / 3;
        select[1] = (now[1] + now[3] + now[5]) / 3;
        select[2] = (now[0] + now[2] + now[4]) / 3 + 1;
        select[3] = (now[1] + now[3] + now[5]) / 3 + 1;
      } else {
        select[2] = (now[0] + now[2] + now[4]) / 3;
        select[3] = (now[1] + now[3] + now[5]) / 3;
      }

      select[4] = 1;
      r.touchData.selecting = true;

      r.redraw();

      // pinch to zoom
    } else if (capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {
      // two fingers => pinch to zoom
      e.preventDefault();

      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);

      var draggedEles = r.dragData.touchDragEles;
      if (draggedEles) {
        r.redrawHint('drag', true);

        for (var i = 0; i < draggedEles.length; i++) {
          var de_p = draggedEles[i]._private;

          de_p.grabbed = false;
          de_p.rscratch.inDragLayer = false;
        }
      }

      // (x2, y2) for fingers 1 and 2
      var f1x2 = e.touches[0].clientX - offsetLeft,
          f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft,
          f2y2 = e.touches[1].clientY - offsetTop;

      var distance2 = distance(f1x2, f1y2, f2x2, f2y2);
      // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
      var factor = distance2 / distance1;

      if (twoFingersStartInside) {
        // delta finger1
        var df1x = f1x2 - f1x1;
        var df1y = f1y2 - f1y1;

        // delta finger 2
        var df2x = f2x2 - f2x1;
        var df2y = f2y2 - f2y1;

        // translation is the normalised vector of the two fingers movement
        // i.e. so pinching cancels out and moving together pans
        var tx = (df1x + df2x) / 2;
        var ty = (df1y + df2y) / 2;

        // adjust factor by the speed multiplier
        // var speed = 1.5;
        // if( factor > 1 ){
        //   factor = (factor - 1) * speed + 1;
        // } else {
        //   factor = 1 - (1 - factor) * speed;
        // }

        // now calculate the zoom
        var zoom1 = cy.zoom();
        var zoom2 = zoom1 * factor;
        var pan1 = cy.pan();

        // the model center point converted to the current rendered pos
        var ctrx = modelCenter1[0] * zoom1 + pan1.x;
        var ctry = modelCenter1[1] * zoom1 + pan1.y;

        var pan2 = {
          x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,
          y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry
        };

        // remove dragged eles
        if (r.touchData.start && r.touchData.start.active()) {
          var draggedEles = r.dragData.touchDragEles;

          freeDraggedElements(draggedEles);

          r.redrawHint('drag', true);
          r.redrawHint('eles', true);

          r.touchData.start.unactivate().emit('free');
        }

        cy.viewport({
          zoom: zoom2,
          pan: pan2,
          cancelOnFailedZoom: true
        });

        distance1 = distance2;
        f1x1 = f1x2;
        f1y1 = f1y2;
        f2x1 = f2x2;
        f2y1 = f2y2;

        r.pinching = true;
      }

      // Re-project
      if (e.touches[0]) {
        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];
      }
      if (e.touches[1]) {
        var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];
      }
      if (e.touches[2]) {
        var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];
      }
    } else if (e.touches[0]) {
      var start = r.touchData.start;
      var last = r.touchData.last;
      var near;

      if (!r.hoverData.draggingEles && !r.swipePanning) {
        near = r.findNearestElement(now[0], now[1], true, true);
      }

      if (capture && start != null) {
        e.preventDefault();
      }

      // dragging nodes
      if (capture && start != null && r.nodeIsDraggable(start)) {

        if (isOverThresholdDrag) {
          // then dragging can happen
          var draggedEles = r.dragData.touchDragEles;
          var justStartedDrag = !r.dragData.didDrag;

          if (justStartedDrag) {
            addNodesToDrag(cy.collection(draggedEles), { inDragLayer: true });
          }

          for (var k = 0; k < draggedEles.length; k++) {
            var draggedEle = draggedEles[k];

            if (r.nodeIsDraggable(draggedEle) && draggedEle.grabbed()) {
              r.dragData.didDrag = true;
              var dPos = draggedEle.position();

              if (is.number(disp[0]) && is.number(disp[1])) {
                dPos.x += disp[0];
                dPos.y += disp[1];
              }

              if (justStartedDrag) {
                r.redrawHint('eles', true);

                var dragDelta = r.touchData.dragDelta;

                if (dragDelta && is.number(dragDelta[0]) && is.number(dragDelta[1])) {
                  dPos.x += dragDelta[0];
                  dPos.y += dragDelta[1];
                }
              }
            }
          }

          var tcol = cy.collection(draggedEles);

          tcol.dirtyCompoundBoundsCache();
          tcol.emit('position drag');

          r.hoverData.draggingEles = true;

          r.redrawHint('drag', true);

          if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {

            r.redrawHint('eles', true);
          }

          r.redraw();
        } else {
          // otherise keep track of drag delta for later
          var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

          if (dragDelta.length === 0) {
            dragDelta.push(disp[0]);
            dragDelta.push(disp[1]);
          } else {
            dragDelta[0] += disp[0];
            dragDelta[1] += disp[1];
          }
        }
      }

      // touchmove
      {
        triggerEvents(start || near, ['touchmove', 'tapdrag', 'vmousemove'], e, {
          position: { x: now[0], y: now[1] }
        });

        if ((!start || !start.grabbed()) && near != last) {
          if (last) {
            last.emit({ originalEvent: e, type: 'tapdragout', position: { x: now[0], y: now[1] } });
          }
          if (near) {
            near.emit({ originalEvent: e, type: 'tapdragover', position: { x: now[0], y: now[1] } });
          }
        }

        r.touchData.last = near;
      }

      // check to cancel taphold
      if (capture) {
        for (var i = 0; i < now.length; i++) {
          if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {

            r.touchData.singleTouchMoved = true;
          }
        }
      }

      // panning
      if (capture && (start == null || start.isEdge()) && cy.panningEnabled() && cy.userPanningEnabled()) {

        var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);

        if (allowPassthrough) {
          e.preventDefault();

          if (r.swipePanning) {
            cy.panBy({
              x: disp[0] * zoom,
              y: disp[1] * zoom
            });
          } else if (isOverThresholdDrag) {
            r.swipePanning = true;

            cy.panBy({
              x: dx * zoom,
              y: dy * zoom
            });

            if (start) {
              start.unactivate();

              if (!r.data.bgActivePosistion) {
                r.data.bgActivePosistion = math.array2point(r.touchData.startPosition);
              }

              r.redrawHint('select', true);

              r.touchData.start = null;
            }
          }
        }

        // Re-project
        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
        now[0] = pos[0];now[1] = pos[1];
      }
    }

    for (var j = 0; j < now.length; j++) {
      earlier[j] = now[j];
    }
    //r.redraw();
  }, false);

  var touchcancelHandler;
  r.registerBinding(window, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {
    // eslint-disable-line no-undef
    var start = r.touchData.start;

    r.touchData.capture = false;

    if (start) {
      start.unactivate();
    }
  });

  var touchendHandler;
  r.registerBinding(window, 'touchend', touchendHandler = function touchendHandler(e) {
    // eslint-disable-line no-undef
    var start = r.touchData.start;

    var capture = r.touchData.capture;

    if (capture) {
      r.touchData.capture = false;

      e.preventDefault();
    } else {
      return;
    }

    var select = r.selection;

    r.swipePanning = false;
    r.hoverData.draggingEles = false;

    var cy = r.cy;
    var zoom = cy.zoom();
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if (e.touches[0]) {
      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];
    }
    if (e.touches[1]) {
      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];
    }
    if (e.touches[2]) {
      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];
    }

    if (start) {
      start.unactivate();
    }

    var ctxTapend;
    if (r.touchData.cxt) {
      ctxTapend = {
        originalEvent: e,
        type: 'cxttapend',
        position: { x: now[0], y: now[1] }
      };

      if (start) {
        start.emit(ctxTapend);
      } else {
        cy.emit(ctxTapend);
      }

      if (!r.touchData.cxtDragged) {
        var ctxTap = {
          originalEvent: e,
          type: 'cxttap',
          position: { x: now[0], y: now[1] }
        };

        if (start) {
          start.emit(ctxTap);
        } else {
          cy.emit(ctxTap);
        }
      }

      if (r.touchData.start) {
        r.touchData.start._private.grabbed = false;
      }
      r.touchData.cxt = false;
      r.touchData.start = null;

      r.redraw();
      return;
    }

    // no more box selection if we don't have three fingers
    if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {
      r.touchData.selecting = false;

      var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));

      select[0] = undefined;
      select[1] = undefined;
      select[2] = undefined;
      select[3] = undefined;
      select[4] = 0;

      r.redrawHint('select', true);

      cy.emit('boxend');

      var eleWouldBeSelected = function eleWouldBeSelected(ele) {
        return ele.selectable() && !ele.selected();
      };

      box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');

      if (box.nonempty()) {
        r.redrawHint('eles', true);
      }

      r.redraw();
    }

    if (start != null) {
      start.unactivate();
    }

    if (e.touches[2]) {
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
    } else if (e.touches[1]) {
      // ignore
    } else if (e.touches[0]) {
      // ignore

      // Last touch released
    } else if (!e.touches[0]) {

      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);

      var draggedEles = r.dragData.touchDragEles;

      if (start != null) {

        var startWasGrabbed = start._private.grabbed;

        freeDraggedElements(draggedEles);

        r.redrawHint('drag', true);
        r.redrawHint('eles', true);

        if (startWasGrabbed) {
          start.emit('free');
        }

        triggerEvents(start, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
          position: { x: now[0], y: now[1] }
        });

        start.unactivate();

        r.touchData.start = null;
      } else {
        var near = r.findNearestElement(now[0], now[1], true, true);

        triggerEvents(near, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
          position: { x: now[0], y: now[1] }
        });
      }

      var dx = r.touchData.startPosition[0] - now[0];
      var dx2 = dx * dx;
      var dy = r.touchData.startPosition[1] - now[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
      if (start != null && !r.dragData.didDrag // didn't drag nodes around
      && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection
      ) {

          if (cy.selectionType() === 'single') {
            cy.$(':selected').unmerge(start).unselect();
            start.select();
          } else {
            if (start.selected()) {
              start.unselect();
            } else {
              start.select();
            }
          }

          r.redrawHint('eles', true);
        }

      // Tap event, roughly same as mouse click event for touch
      if (!r.touchData.singleTouchMoved) {
        triggerEvents(start, ['tap', 'vclick'], e, {
          position: { x: now[0], y: now[1] }
        });
      }

      r.touchData.singleTouchMoved = true;
    }

    for (var j = 0; j < now.length; j++) {
      earlier[j] = now[j];
    }

    r.dragData.didDrag = false; // reset for next mousedown

    if (e.touches.length === 0) {
      r.touchData.dragDelta = [];
      r.touchData.startPosition = null;
      r.touchData.startGPosition = null;
    }

    if (e.touches.length < 2) {
      r.pinching = false;
      r.redrawHint('eles', true);
      r.redraw();
    }

    //r.redraw();
  }, false);

  // fallback compatibility layer for ms pointer events
  if (typeof TouchEvent === 'undefined') {

    var pointers = [];

    var makeTouch = function makeTouch(e) {
      return {
        clientX: e.clientX,
        clientY: e.clientY,
        force: 1,
        identifier: e.pointerId,
        pageX: e.pageX,
        pageY: e.pageY,
        radiusX: e.width / 2,
        radiusY: e.height / 2,
        screenX: e.screenX,
        screenY: e.screenY,
        target: e.target
      };
    };

    var makePointer = function makePointer(e) {
      return {
        event: e,
        touch: makeTouch(e)
      };
    };

    var addPointer = function addPointer(e) {
      pointers.push(makePointer(e));
    };

    var removePointer = function removePointer(e) {
      for (var i = 0; i < pointers.length; i++) {
        var p = pointers[i];

        if (p.event.pointerId === e.pointerId) {
          pointers.splice(i, 1);
          return;
        }
      }
    };

    var updatePointer = function updatePointer(e) {
      var p = pointers.filter(function (p) {
        return p.event.pointerId === e.pointerId;
      })[0];

      p.event = e;
      p.touch = makeTouch(e);
    };

    var addTouchesToEvent = function addTouchesToEvent(e) {
      e.touches = pointers.map(function (p) {
        return p.touch;
      });
    };

    var pointerIsMouse = function pointerIsMouse(e) {
      return e.pointerType === 'mouse' || e.pointerType === 4;
    };

    r.registerBinding(r.container, 'pointerdown', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled

      e.preventDefault();

      addPointer(e);

      addTouchesToEvent(e);
      touchstartHandler(e);
    });

    r.registerBinding(r.container, 'pointerup', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled

      removePointer(e);

      addTouchesToEvent(e);
      touchendHandler(e);
    });

    r.registerBinding(r.container, 'pointercancel', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled

      removePointer(e);

      addTouchesToEvent(e);
      touchcancelHandler(e);
    });

    r.registerBinding(r.container, 'pointermove', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled

      e.preventDefault();

      updatePointer(e);

      addTouchesToEvent(e);
      touchmoveHandler(e);
    });
  }
};

module.exports = BRp;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);

var BRp = {};

BRp.generatePolygon = function (name, points) {
  return this.nodeShapes[name] = {
    renderer: this,

    name: name,

    points: points,

    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);
    },

    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return math.polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);
    },

    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      return math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [0, -1], padding);
    }
  };
};

BRp.generateEllipse = function () {
  return this.nodeShapes['ellipse'] = {
    renderer: this,

    name: 'ellipse',

    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },

    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return math.intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);
    },

    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      return math.checkInEllipse(x, y, width, height, centerX, centerY, padding);
    }
  };
};

BRp.generateRoundRectangle = function () {
  return this.nodeShapes['roundrectangle'] = {
    renderer: this,

    name: 'roundrectangle',

    points: math.generateUnitNgonPointsFitToSquare(4, 0),

    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },

    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return math.roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
    },

    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {

      var cornerRadius = math.getRoundRectangleRadius(width, height);
      var diam = cornerRadius * 2;

      // Check hBox
      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
        return true;
      }

      // Check vBox
      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
        return true;
      }

      // Check top left quarter circle
      if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY - height / 2 + cornerRadius, padding)) {

        return true;
      }

      // Check top right quarter circle
      if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY - height / 2 + cornerRadius, padding)) {

        return true;
      }

      // Check bottom right quarter circle
      if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {

        return true;
      }

      // Check bottom left quarter circle
      if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {

        return true;
      }

      return false;
    }
  };
};

BRp.generateCutRectangle = function () {
  return this.nodeShapes['cutrectangle'] = {
    renderer: this,

    name: 'cutrectangle',

    cornerLength: math.getCutRectangleCornerLength(),

    points: math.generateUnitNgonPointsFitToSquare(4, 0),

    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },

    generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY) {
      var cl = this.cornerLength;
      var hh = height / 2;
      var hw = width / 2;
      var xBegin = centerX - hw;
      var xEnd = centerX + hw;
      var yBegin = centerY - hh;
      var yEnd = centerY + hh;

      // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]
      return {
        topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],
        topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],
        bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],
        bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]
      };
    },

    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);
      var pts = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);

      return math.polygonIntersectLine(x, y, pts, nodeX, nodeY);
    },

    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      // Check hBox
      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * this.cornerLength, [0, -1], padding)) {
        return true;
      }

      // Check vBox
      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * this.cornerLength, height, [0, -1], padding)) {
        return true;
      }
      var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);
      return math.pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);
    }

  };
};

BRp.generateBarrel = function () {
  return this.nodeShapes['barrel'] = {
    renderer: this,

    name: 'barrel',

    points: math.generateUnitNgonPointsFitToSquare(4, 0),

    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },

    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);

      var pts = [].concat(bPts.topLeft, bPts.topRight, bPts.bottomRight, bPts.bottomLeft);

      return math.polygonIntersectLine(x, y, pts, nodeX, nodeY);
    },

    generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {
      var hh = height / 2;
      var hw = width / 2;
      var xBegin = centerX - hw;
      var xEnd = centerX + hw;
      var yBegin = centerY - hh;
      var yEnd = centerY + hh;

      var curveConstants = math.getBarrelCurveConstants(width, height);
      var hOffset = curveConstants.heightOffset;
      var wOffset = curveConstants.widthOffset;
      var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width;

      // points are in clockwise order, inner (imaginary) control pt on [4, 5]
      var pts = {
        topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],
        topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],
        bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],
        bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]
      };

      pts.topLeft.isTop = true;
      pts.topRight.isTop = true;
      pts.bottomLeft.isBottom = true;
      pts.bottomRight.isBottom = true;

      return pts;
    },

    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {

      var curveConstants = math.getBarrelCurveConstants(width, height);
      var hOffset = curveConstants.heightOffset;
      var wOffset = curveConstants.widthOffset;

      // Check hBox
      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [0, -1], padding)) {
        return true;
      }

      // Check vBox
      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [0, -1], padding)) {
        return true;
      }

      var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);

      var getCurveT = function getCurveT(x, y, curvePts) {
        var x0 = curvePts[4];
        var x1 = curvePts[2];
        var x2 = curvePts[0];
        var y0 = curvePts[5];
        // var y1 = curvePts[ 3 ];
        var y2 = curvePts[1];

        var xMin = Math.min(x0, x2);
        var xMax = Math.max(x0, x2);
        var yMin = Math.min(y0, y2);
        var yMax = Math.max(y0, y2);

        if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {
          var coeff = math.bezierPtsToQuadCoeff(x0, x1, x2);
          var roots = math.solveQuadratic(coeff[0], coeff[1], coeff[2], x);

          var validRoots = roots.filter(function (r) {
            return 0 <= r && r <= 1;
          });

          if (validRoots.length > 0) {
            return validRoots[0];
          }
        }
        return null;
      };

      var curveRegions = Object.keys(barrelCurvePts);
      for (var i = 0; i < curveRegions.length; i++) {
        var corner = curveRegions[i];
        var cornerPts = barrelCurvePts[corner];
        var t = getCurveT(x, y, cornerPts);

        if (t == null) {
          continue;
        }

        var y0 = cornerPts[5];
        var y1 = cornerPts[3];
        var y2 = cornerPts[1];
        var bezY = math.qbezierAt(y0, y1, y2, t);

        if (cornerPts.isTop && bezY <= y) {
          return true;
        }
        if (cornerPts.isBottom && y <= bezY) {
          return true;
        }
      }
      return false;
    }
  };
};

BRp.generateBottomRoundrectangle = function () {
  return this.nodeShapes['bottomroundrectangle'] = {
    renderer: this,

    name: 'bottomroundrectangle',

    points: math.generateUnitNgonPointsFitToSquare(4, 0),

    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },

    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      var topStartX = nodeX - (width / 2 + padding);
      var topStartY = nodeY - (height / 2 + padding);
      var topEndY = topStartY;
      var topEndX = nodeX + (width / 2 + padding);

      var topIntersections = math.finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
      if (topIntersections.length > 0) {
        return topIntersections;
      }

      return math.roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
    },

    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {

      var cornerRadius = math.getRoundRectangleRadius(width, height);
      var diam = 2 * cornerRadius;

      // Check hBox
      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
        return true;
      }

      // Check vBox
      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
        return true;
      }

      // check non-rounded top side
      var outerWidth = width / 2 + 2 * padding;
      var outerHeight = height / 2 + 2 * padding;
      var points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];
      if (math.pointInsidePolygonPoints(x, y, points)) {
        return true;
      }

      // Check bottom right quarter circle
      if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {

        return true;
      }

      // Check bottom left quarter circle
      if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {

        return true;
      }

      return false;
    }
  };
};

BRp.registerNodeShapes = function () {
  var nodeShapes = this.nodeShapes = {};
  var renderer = this;

  this.generateEllipse();

  this.generatePolygon('triangle', math.generateUnitNgonPointsFitToSquare(3, 0));

  this.generatePolygon('rectangle', math.generateUnitNgonPointsFitToSquare(4, 0));
  nodeShapes['square'] = nodeShapes['rectangle'];

  this.generateRoundRectangle();

  this.generateCutRectangle();

  this.generateBarrel();

  this.generateBottomRoundrectangle();

  this.generatePolygon('diamond', [0, 1, 1, 0, 0, -1, -1, 0]);

  this.generatePolygon('pentagon', math.generateUnitNgonPointsFitToSquare(5, 0));

  this.generatePolygon('hexagon', math.generateUnitNgonPointsFitToSquare(6, 0));

  this.generatePolygon('heptagon', math.generateUnitNgonPointsFitToSquare(7, 0));

  this.generatePolygon('octagon', math.generateUnitNgonPointsFitToSquare(8, 0));

  var star5Points = new Array(20);
  {
    var outerPoints = math.generateUnitNgonPoints(5, 0);
    var innerPoints = math.generateUnitNgonPoints(5, Math.PI / 5);

    // Outer radius is 1; inner radius of star is smaller
    var innerRadius = 0.5 * (3 - Math.sqrt(5));
    innerRadius *= 1.57;

    for (var i = 0; i < innerPoints.length / 2; i++) {
      innerPoints[i * 2] *= innerRadius;
      innerPoints[i * 2 + 1] *= innerRadius;
    }

    for (var i = 0; i < 20 / 4; i++) {
      star5Points[i * 4] = outerPoints[i * 2];
      star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];

      star5Points[i * 4 + 2] = innerPoints[i * 2];
      star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];
    }
  }

  star5Points = math.fitPolygonToSquare(star5Points);

  this.generatePolygon('star', star5Points);

  this.generatePolygon('vee', [-1, -1, 0, -0.333, 1, -1, 0, 1]);

  this.generatePolygon('rhomboid', [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);

  this.generatePolygon('concavehexagon', [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);

  this.generatePolygon('tag', [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1]);

  nodeShapes.makePolygon = function (points) {

    // use caching on user-specified polygons so they are as fast as native shapes

    var key = points.join('$');
    var name = 'polygon-' + key;
    var shape;

    if (shape = this[name]) {
      // got cached shape
      return shape;
    }

    // create and cache new shape
    return renderer.generatePolygon(name, points);
  };
};

module.exports = BRp;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

var BRp = {};

BRp.timeToRender = function () {
  return this.redrawTotalTime / this.redrawCount;
};

BRp.redraw = function (options) {
  options = options || util.staticEmptyObject();

  var r = this;

  if (r.averageRedrawTime === undefined) {
    r.averageRedrawTime = 0;
  }
  if (r.lastRedrawTime === undefined) {
    r.lastRedrawTime = 0;
  }
  if (r.lastDrawTime === undefined) {
    r.lastDrawTime = 0;
  }

  r.requestedFrame = true;
  r.renderOptions = options;
};

BRp.beforeRender = function (fn, priority) {
  // the renderer can't add tick callbacks when destroyed
  if (this.destroyed) {
    return;
  }

  priority = priority || 0;

  var cbs = this.beforeRenderCallbacks;

  cbs.push({ fn: fn, priority: priority });

  // higher priority callbacks executed first
  cbs.sort(function (a, b) {
    return b.priority - a.priority;
  });
};

var beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {
  var cbs = r.beforeRenderCallbacks;

  for (var i = 0; i < cbs.length; i++) {
    cbs[i].fn(willDraw, startTime);
  }
};

BRp.startRenderLoop = function () {
  var r = this;

  if (r.renderLoopStarted) {
    return;
  } else {
    r.renderLoopStarted = true;
  }

  var renderFn = function renderFn(requestTime) {
    if (r.destroyed) {
      return;
    }

    if (r.requestedFrame && !r.skipFrame) {
      beforeRenderCallbacks(r, true, requestTime);

      var startTime = util.performanceNow();

      r.render(r.renderOptions);

      var endTime = r.lastDrawTime = util.performanceNow();

      if (r.averageRedrawTime === undefined) {
        r.averageRedrawTime = endTime - startTime;
      }

      if (r.redrawCount === undefined) {
        r.redrawCount = 0;
      }

      r.redrawCount++;

      if (r.redrawTotalTime === undefined) {
        r.redrawTotalTime = 0;
      }

      var duration = endTime - startTime;

      r.redrawTotalTime += duration;
      r.lastRedrawTime = duration;

      // use a weighted average with a bias from the previous average so we don't spike so easily
      r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;

      r.requestedFrame = false;
    } else {
      beforeRenderCallbacks(r, false, requestTime);
    }

    r.skipFrame = false;

    util.requestAnimationFrame(renderFn);
  };

  util.requestAnimationFrame(renderFn);
};

module.exports = BRp;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CRp = {};

var impl;

CRp.arrowShapeImpl = function (name) {
  return (impl || (impl = {
    'polygon': function polygon(context, points) {
      for (var i = 0; i < points.length; i++) {
        var pt = points[i];

        context.lineTo(pt.x, pt.y);
      }
    },

    'triangle-backcurve': function triangleBackcurve(context, points, controlPoint) {
      var firstPt;

      for (var i = 0; i < points.length; i++) {
        var pt = points[i];

        if (i === 0) {
          firstPt = pt;
        }

        context.lineTo(pt.x, pt.y);
      }

      context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);
    },

    'triangle-tee': function triangleTee(context, trianglePoints, teePoints) {
      if (context.beginPath) {
        context.beginPath();
      }

      var triPts = trianglePoints;
      for (var i = 0; i < triPts.length; i++) {
        var pt = triPts[i];

        context.lineTo(pt.x, pt.y);
      }

      if (context.closePath) {
        context.closePath();
      }

      if (context.beginPath) {
        context.beginPath();
      }

      var teePts = teePoints;
      var firstTeePt = teePoints[0];
      context.moveTo(firstTeePt.x, firstTeePt.y);

      for (var i = 0; i < teePts.length; i++) {
        var pt = teePts[i];

        context.lineTo(pt.x, pt.y);
      }
      if (context.closePath) {
        context.closePath();
      }
    },

    'triangle-cross': function triangleCross(context, trianglePoints, crossLinePoints) {
      if (context.beginPath) {
        context.beginPath();
      }

      var triPts = trianglePoints;
      for (var i = 0; i < triPts.length; i++) {
        var pt = triPts[i];

        context.lineTo(pt.x, pt.y);
      }

      if (context.closePath) {
        context.closePath();
      }

      if (context.beginPath) {
        context.beginPath();
      }

      var teePts = crossLinePoints;
      var firstTeePt = crossLinePoints[0];
      context.moveTo(firstTeePt.x, firstTeePt.y);

      for (var i = 0; i < teePts.length; i++) {
        var pt = teePts[i];

        context.lineTo(pt.x, pt.y);
      }
      if (context.closePath) {
        context.closePath();
      }
    },

    'circle': function circle(context, rx, ry, r) {
      context.arc(rx, ry, r, 0, Math.PI * 2, false);
    }
  }))[name];
};

module.exports = CRp;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CRp = {};

CRp.drawEdge = function (context, edge, shiftToOriginWithBb, drawLabel) {
  var r = this;
  var rs = edge._private.rscratch;
  var usePaths = r.usePaths();

  // if bezier ctrl pts can not be calculated, then die
  if (rs.badLine || isNaN(rs.allpts[0])) {
    // isNaN in case edge is impossible and browser bugs (e.g. safari)
    return;
  }

  if (!edge.visible()) {
    return;
  }

  var bb = void 0;
  if (shiftToOriginWithBb) {
    bb = shiftToOriginWithBb;

    context.translate(-bb.x1, -bb.y1);
  }

  var overlayPadding = edge.pstyle('overlay-padding').pfValue;
  var overlayWidth = 2 * overlayPadding;
  var overlayOpacity = edge.pstyle('overlay-opacity').value;
  var overlayColor = edge.pstyle('overlay-color').value;
  var lineColor = edge.pstyle('line-color').value;
  var opacity = edge.pstyle('opacity').value;
  var lineStyle = edge.pstyle('line-style').value;
  var edgeWidth = edge.pstyle('width').pfValue;

  var drawLine = function drawLine() {
    var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;

    context.lineWidth = edgeWidth;
    context.lineCap = 'butt';

    r.strokeStyle(context, lineColor[0], lineColor[1], lineColor[2], strokeOpacity);

    r.drawEdgePath(edge, context, rs.allpts, lineStyle);
  };

  var drawOverlay = function drawOverlay() {
    var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : overlayOpacity;

    context.lineWidth = overlayWidth;

    if (rs.edgeType === 'self' && !usePaths) {
      context.lineCap = 'butt';
    } else {
      context.lineCap = 'round';
    }

    r.strokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], strokeOpacity);

    r.drawEdgePath(edge, context, rs.allpts, 'solid');
  };

  var drawArrows = function drawArrows() {
    var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;

    r.drawArrowheads(context, edge, arrowOpacity);
  };

  var drawText = function drawText() {
    r.drawElementText(context, edge, drawLabel);
  };

  context.lineJoin = 'round';

  var ghost = edge.pstyle('ghost').value === 'yes';

  if (ghost) {
    var gx = edge.pstyle('ghost-offset-x').pfValue;
    var gy = edge.pstyle('ghost-offset-y').pfValue;
    var ghostOpacity = edge.pstyle('ghost-opacity').value;
    var effectiveGhostOpacity = opacity * ghostOpacity;

    context.translate(gx, gy);

    drawLine(effectiveGhostOpacity);
    drawArrows(effectiveGhostOpacity);

    context.translate(-gx, -gy);
  }

  drawLine();
  drawArrows();
  drawOverlay();
  drawText();

  if (shiftToOriginWithBb) {
    context.translate(bb.x1, bb.y1);
  }
};

CRp.drawEdgePath = function (edge, context, pts, type) {
  var rs = edge._private.rscratch;
  var canvasCxt = context;
  var path = void 0;
  var pathCacheHit = false;
  var usePaths = this.usePaths();

  if (usePaths) {
    var pathCacheKey = pts.join('$');
    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;

    if (keyMatches) {
      path = context = rs.pathCache;
      pathCacheHit = true;
    } else {
      path = context = new Path2D(); // eslint-disable-line no-undef
      rs.pathCacheKey = pathCacheKey;
      rs.pathCache = path;
    }
  }

  if (canvasCxt.setLineDash) {
    // for very outofdate browsers
    switch (type) {
      case 'dotted':
        canvasCxt.setLineDash([1, 1]);
        break;

      case 'dashed':
        canvasCxt.setLineDash([6, 3]);
        break;

      case 'solid':
        canvasCxt.setLineDash([]);
        break;
    }
  }

  if (!pathCacheHit && !rs.badLine) {
    if (context.beginPath) {
      context.beginPath();
    }
    context.moveTo(pts[0], pts[1]);

    switch (rs.edgeType) {
      case 'bezier':
      case 'self':
      case 'compound':
      case 'multibezier':
        for (var i = 2; i + 3 < pts.length; i += 4) {
          context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);
        }
        break;

      case 'straight':
      case 'segments':
      case 'haystack':
        for (var _i = 2; _i + 1 < pts.length; _i += 2) {
          context.lineTo(pts[_i], pts[_i + 1]);
        }
        break;
    }
  }

  context = canvasCxt;
  if (usePaths) {
    context.stroke(path);
  } else {
    context.stroke();
  }

  // reset any line dashes
  if (context.setLineDash) {
    // for very outofdate browsers
    context.setLineDash([]);
  }
};

CRp.drawArrowheads = function (context, edge, opacity) {
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';

  if (!isHaystack) {
    this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);
  }

  this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);

  this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);

  if (!isHaystack) {
    this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);
  }
};

CRp.drawArrowhead = function (context, edge, prefix, x, y, angle, opacity) {
  if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {
    return;
  }

  var self = this;
  var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;
  if (arrowShape === 'none') {
    return;
  }

  var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';
  var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;
  var edgeWidth = edge.pstyle('width').pfValue;
  var edgeOpacity = edge.pstyle('opacity').value;

  if (opacity === undefined) {
    opacity = edgeOpacity;
  }

  var gco = context.globalCompositeOperation;

  if (opacity !== 1 || arrowFill === 'hollow') {
    // then extra clear is needed
    context.globalCompositeOperation = 'destination-out';

    self.fillStyle(context, 255, 255, 255, 1);
    self.strokeStyle(context, 255, 255, 255, 1);

    self.drawArrowShape(edge, prefix, context, arrowClearFill, edgeWidth, arrowShape, x, y, angle);

    context.globalCompositeOperation = gco;
  } // otherwise, the opaque arrow clears it for free :)

  var color = edge.pstyle(prefix + '-arrow-color').value;
  self.fillStyle(context, color[0], color[1], color[2], opacity);
  self.strokeStyle(context, color[0], color[1], color[2], opacity);

  self.drawArrowShape(edge, prefix, context, arrowFill, edgeWidth, arrowShape, x, y, angle);
};

CRp.drawArrowShape = function (edge, arrowType, context, fill, edgeWidth, shape, x, y, angle) {
  var r = this;
  var usePaths = this.usePaths();
  var rs = edge._private.rscratch;
  var pathCacheHit = false;
  var path = void 0;
  var canvasContext = context;
  var translation = { x: x, y: y };
  var scale = edge.pstyle('arrow-scale').value;
  var size = this.getArrowWidth(edgeWidth, scale);
  var shapeImpl = r.arrowShapes[shape];

  if (usePaths) {
    var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;
    rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};
    rs.arrowPathCache = rs.arrowPathCache || {};

    var alreadyCached = rs.arrowPathCacheKey[arrowType] === pathCacheKey;
    if (alreadyCached) {
      path = context = rs.arrowPathCache[arrowType];
      pathCacheHit = true;
    } else {
      path = context = new Path2D(); // eslint-disable-line no-undef
      rs.arrowPathCacheKey[arrowType] = pathCacheKey;
      rs.arrowPathCache[arrowType] = path;
    }
  }

  if (context.beginPath) {
    context.beginPath();
  }

  if (!pathCacheHit) {
    shapeImpl.draw(context, size, angle, translation, edgeWidth);
  }

  if (!shapeImpl.leavePathOpen && context.closePath) {
    context.closePath();
  }

  context = canvasContext;

  if (fill === 'filled' || fill === 'both') {
    if (usePaths) {
      context.fill(path);
    } else {
      context.fill();
    }
  }

  if (fill === 'hollow' || fill === 'both') {
    context.lineWidth = shapeImpl.matchEdgeWidth ? edgeWidth : 1;
    context.lineJoin = 'miter';

    if (usePaths) {
      context.stroke(path);
    } else {
      context.stroke();
    }
  }
};

module.exports = CRp;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);

var CRp = {};

CRp.drawElement = function (context, ele, shiftToOriginWithBb, showLabel) {
  var r = this;

  if (ele.isNode()) {
    r.drawNode(context, ele, shiftToOriginWithBb, showLabel);
  } else {
    r.drawEdge(context, ele, shiftToOriginWithBb, showLabel);
  }
};

CRp.drawCachedElement = function (context, ele, pxRatio, extent) {
  var r = this;
  var bb = ele.boundingBox();

  if (bb.w === 0 || bb.h === 0) {
    return;
  }

  if (!extent || math.boundingBoxesIntersect(bb, extent)) {
    var cache = r.data.eleTxrCache.getElement(ele, bb, pxRatio);

    if (cache != null) {
      context.drawImage(cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h);
    } else {
      // if the element is not cacheable, then draw directly
      r.drawElement(context, ele);
    }
  }
};

CRp.drawElements = function (context, eles) {
  var r = this;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    r.drawElement(context, ele);
  }
};

CRp.drawCachedElements = function (context, eles, pxRatio, extent) {
  var r = this;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    r.drawCachedElement(context, ele, pxRatio, extent);
  }
};

CRp.drawCachedNodes = function (context, eles, pxRatio, extent) {
  var r = this;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (!ele.isNode()) {
      continue;
    }

    r.drawCachedElement(context, ele, pxRatio, extent);
  }
};

CRp.drawLayeredElements = function (context, eles, pxRatio, extent) {
  var r = this;

  var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);

  if (layers) {
    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      var bb = layer.bb;

      if (bb.w === 0 || bb.h === 0) {
        continue;
      }

      context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);
    }
  } else {
    // fall back on plain caching if no layers
    r.drawCachedElements(context, eles, pxRatio, extent);
  }
};

CRp.drawDebugPoints = function (context, eles) {
  var draw = function draw(x, y, color) {
    context.fillStyle = color;
    context.fillRect(x - 1, y - 1, 3, 3);
  };

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var rs = ele._private.rscratch;

    if (ele.isNode()) {
      var p = ele.position();

      draw(p.x, p.y, 'magenta');
    } else {
      var pts = rs.allpts;

      for (var j = 0; j + 1 < pts.length; j += 2) {
        var x = pts[j];
        var y = pts[j + 1];

        draw(x, y, 'cyan');
      }

      draw(rs.midX, rs.midY, 'yellow');
    }
  }
};

module.exports = CRp;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CRp = {};

CRp.safeDrawImage = function (context, img, ix, iy, iw, ih, x, y, w, h) {
  var r = this;

  // detect problematic cases for old browsers with bad images (cheaper than try-catch)
  if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {
    return;
  }

  context.drawImage(img, ix, iy, iw, ih, x, y, w, h);
};

CRp.drawInscribedImage = function (context, img, node, index, nodeOpacity) {
  var r = this;
  var pos = node.position();
  var nodeX = pos.x;
  var nodeY = pos.y;
  var styleObj = node.cy().style();
  var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);
  var fit = getIndexedStyle(node, 'background-fit', 'value', index);
  var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);
  var nodeW = node.width();
  var nodeH = node.height();
  var paddingX2 = node.padding() * 2;
  var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
  var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
  var rs = node._private.rscratch;
  var clip = node.pstyle('background-clip').value;
  var shouldClip = clip === 'node';
  var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;

  var imgW = img.width || img.cachedW;
  var imgH = img.height || img.cachedH;

  // workaround for broken browsers like ie
  if (null == imgW || null == imgH) {
    document.body.appendChild(img); // eslint-disable-line no-undef

    imgW = img.cachedW = img.width || img.offsetWidth;
    imgH = img.cachedH = img.height || img.offsetHeight;

    document.body.removeChild(img); // eslint-disable-line no-undef
  }

  var w = imgW;
  var h = imgH;

  if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {
    if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {
      w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;
    } else {
      w = getIndexedStyle(node, 'background-width', 'pfValue', index);
    }
  }

  if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {
    if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {
      h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;
    } else {
      h = getIndexedStyle(node, 'background-height', 'pfValue', index);
    }
  }

  if (w === 0 || h === 0) {
    return; // no point in drawing empty image (and chrome is broken in this case)
  }

  if (fit === 'contain') {
    var scale = Math.min(nodeTW / w, nodeTH / h);

    w *= scale;
    h *= scale;
  } else if (fit === 'cover') {
    var scale = Math.max(nodeTW / w, nodeTH / h);

    w *= scale;
    h *= scale;
  }

  var x = nodeX - nodeTW / 2; // left
  if (getIndexedStyle(node, 'background-position-x', 'units', index) === '%') {
    x += (nodeTW - w) * getIndexedStyle(node, 'background-position-x', 'pfValue', index);
  } else {
    x += getIndexedStyle(node, 'background-position-x', 'pfValue', index);
  }

  var y = nodeY - nodeTH / 2; // top
  if (getIndexedStyle(node, 'background-position-y', 'units', index) === '%') {
    y += (nodeTH - h) * getIndexedStyle(node, 'background-position-y', 'pfValue', index);
  } else {
    y += getIndexedStyle(node, 'background-position-y', 'pfValue', index);
  }

  if (rs.pathCache) {
    x -= nodeX;
    y -= nodeY;

    nodeX = 0;
    nodeY = 0;
  }

  var gAlpha = context.globalAlpha;

  context.globalAlpha = imgOpacity;

  if (repeat === 'no-repeat') {

    if (shouldClip) {
      context.save();

      if (rs.pathCache) {
        context.clip(rs.pathCache);
      } else {
        r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);

        context.clip();
      }
    }

    r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);

    if (shouldClip) {
      context.restore();
    }
  } else {
    var pattern = context.createPattern(img, repeat);
    context.fillStyle = pattern;

    r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);

    context.translate(x, y);
    context.fill();
    context.translate(-x, -y);
  }

  context.globalAlpha = gAlpha;
};

module.exports = CRp;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var math = __webpack_require__(2);

var CRp = {};

CRp.eleTextBiggerThanMin = function (ele, scale) {
  if (!scale) {
    var zoom = ele.cy().zoom();
    var pxRatio = this.getPixelRatio();
    var lvl = Math.ceil(math.log2(zoom * pxRatio)); // the effective texture level

    scale = Math.pow(2, lvl);
  }

  var computedSize = ele.pstyle('font-size').pfValue * scale;
  var minSize = ele.pstyle('min-zoomed-font-size').pfValue;

  if (computedSize < minSize) {
    return false;
  }

  return true;
};

CRp.drawElementText = function (context, ele, force) {
  var r = this;

  if (force === undefined) {
    if (!r.eleTextBiggerThanMin(ele)) {
      return;
    }
  } else {
    if (!force) {
      return;
    }
  }

  if (ele.isNode()) {
    var label = ele.pstyle('label');

    if (!label || !label.value) {
      return;
    }

    var textHalign = ele.pstyle('text-halign').strValue;
    var textValign = ele.pstyle('text-valign').strValue;

    switch (textHalign) {
      case 'left':
        context.textAlign = 'right';
        break;

      case 'right':
        context.textAlign = 'left';
        break;

      default:
        // e.g. center
        context.textAlign = 'center';
    }

    context.textBaseline = 'bottom';
  } else {
    var label = ele.pstyle('label');
    var srcLabel = ele.pstyle('source-label');
    var tgtLabel = ele.pstyle('target-label');

    if ((!label || !label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {
      return;
    }

    context.textAlign = 'center';
    context.textBaseline = 'bottom';
  }

  r.drawText(context, ele);

  if (ele.isEdge()) {
    r.drawText(context, ele, 'source');

    r.drawText(context, ele, 'target');
  }
};

CRp.drawNodeText = CRp.drawEdgeText = CRp.drawElementText;

CRp.getFontCache = function (context) {
  var cache;

  this.fontCaches = this.fontCaches || [];

  for (var i = 0; i < this.fontCaches.length; i++) {
    cache = this.fontCaches[i];

    if (cache.context === context) {
      return cache;
    }
  }

  cache = {
    context: context
  };
  this.fontCaches.push(cache);

  return cache;
};

// set up canvas context with font
// returns transformed text string
CRp.setupTextStyle = function (context, ele) {
  // Font style
  var parentOpacity = ele.effectiveOpacity();
  var labelStyle = ele.pstyle('font-style').strValue;
  var labelSize = ele.pstyle('font-size').pfValue + 'px';
  var labelFamily = ele.pstyle('font-family').strValue;
  var labelWeight = ele.pstyle('font-weight').strValue;
  var opacity = ele.pstyle('text-opacity').value * ele.pstyle('opacity').value * parentOpacity;
  var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;
  var color = ele.pstyle('color').value;
  var outlineColor = ele.pstyle('text-outline-color').value;

  var fontCacheKey = ele._private.fontKey;
  var cache = this.getFontCache(context);

  if (cache.key !== fontCacheKey) {
    context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;

    cache.key = fontCacheKey;
  }

  // Calculate text draw position based on text alignment

  // so text outlines aren't jagged
  context.lineJoin = 'round';

  this.fillStyle(context, color[0], color[1], color[2], opacity);

  this.strokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);
};

function roundRect(ctx, x, y, width, height, radius) {
  var radius = radius || 5;
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
  ctx.fill();
}

// Draw text
CRp.drawText = function (context, ele, prefix) {
  var _p = ele._private;
  var rscratch = _p.rscratch;
  var parentOpacity = ele.effectiveOpacity();
  if (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0) {
    return;
  }

  var textX = util.getPrefixedProperty(rscratch, 'labelX', prefix);
  var textY = util.getPrefixedProperty(rscratch, 'labelY', prefix);
  var text = this.getLabelText(ele, prefix);

  if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {
    this.setupTextStyle(context, ele);

    var pdash = prefix ? prefix + '-' : '';
    var textW = util.getPrefixedProperty(rscratch, 'labelWidth', prefix);
    var textH = util.getPrefixedProperty(rscratch, 'labelHeight', prefix);
    var textAngle = util.getPrefixedProperty(rscratch, 'labelAngle', prefix);
    var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;
    var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;

    var isEdge = ele.isEdge();
    var isNode = ele.isNode();

    var halign = ele.pstyle('text-halign').value;
    var valign = ele.pstyle('text-valign').value;

    if (isEdge) {
      halign = 'center';
      valign = 'center';
    }

    textX += marginX;
    textY += marginY;

    var rotation = ele.pstyle('text-rotation');
    var theta;

    if (rotation.strValue === 'autorotate') {
      theta = isEdge ? textAngle : 0;
    } else if (rotation.strValue === 'none') {
      theta = 0;
    } else {
      theta = rotation.pfValue;
    }

    if (theta !== 0) {
      var orgTextX = textX;
      var orgTextY = textY;

      context.translate(orgTextX, orgTextY);
      context.rotate(theta);

      textX = 0;
      textY = 0;
    }

    switch (valign) {
      case 'top':
        break;
      case 'center':
        textY += textH / 2;
        break;
      case 'bottom':
        textY += textH;
        break;
    }

    var backgroundOpacity = ele.pstyle('text-background-opacity').value;
    var borderOpacity = ele.pstyle('text-border-opacity').value;
    var textBorderWidth = ele.pstyle('text-border-width').pfValue;
    var backgroundPadding = ele.pstyle('text-background-padding').pfValue;

    if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {
      var bgX = textX - backgroundPadding;

      switch (halign) {
        case 'left':
          bgX -= textW;
          break;
        case 'center':
          bgX -= textW / 2;
          break;
        case 'right':
          break;
      }

      var bgY = textY - textH - backgroundPadding;
      var bgW = textW + 2 * backgroundPadding;
      var bgH = textH + 2 * backgroundPadding;

      if (backgroundOpacity > 0) {
        var textFill = context.fillStyle;
        var textBackgroundColor = ele.pstyle('text-background-color').value;

        context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';
        var styleShape = ele.pstyle('text-background-shape').strValue;
        if (styleShape == 'roundrectangle') {
          roundRect(context, bgX, bgY, bgW, bgH, 2);
        } else {
          context.fillRect(bgX, bgY, bgW, bgH);
        }
        context.fillStyle = textFill;
      }

      if (textBorderWidth > 0 && borderOpacity > 0) {
        var textStroke = context.strokeStyle;
        var textLineWidth = context.lineWidth;
        var textBorderColor = ele.pstyle('text-border-color').value;
        var textBorderStyle = ele.pstyle('text-border-style').value;

        context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';
        context.lineWidth = textBorderWidth;

        if (context.setLineDash) {
          // for very outofdate browsers
          switch (textBorderStyle) {
            case 'dotted':
              context.setLineDash([1, 1]);
              break;
            case 'dashed':
              context.setLineDash([4, 2]);
              break;
            case 'double':
              context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders
              context.setLineDash([]);
              break;
            case 'solid':
              context.setLineDash([]);
              break;
          }
        }

        context.strokeRect(bgX, bgY, bgW, bgH);

        if (textBorderStyle === 'double') {
          var whiteWidth = textBorderWidth / 2;

          context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);
        }

        if (context.setLineDash) {
          // for very outofdate browsers
          context.setLineDash([]);
        }
        context.lineWidth = textLineWidth;
        context.strokeStyle = textStroke;
      }
    }

    var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle

    if (lineWidth > 0) {
      context.lineWidth = lineWidth;
    }

    if (ele.pstyle('text-wrap').value === 'wrap') {
      var lines = util.getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);
      var lineHeight = textH / lines.length;

      switch (valign) {
        case 'top':
          textY -= (lines.length - 1) * lineHeight;
          break;
        case 'center':
        case 'bottom':
          textY -= (lines.length - 1) * lineHeight;
          break;
      }

      for (var l = 0; l < lines.length; l++) {
        if (lineWidth > 0) {
          context.strokeText(lines[l], textX, textY);
        }

        context.fillText(lines[l], textX, textY);

        textY += lineHeight;
      }
    } else {
      if (lineWidth > 0) {
        context.strokeText(text, textX, textY);
      }

      context.fillText(text, textX, textY);
    }

    if (theta !== 0) {
      context.rotate(-theta);
      context.translate(-orgTextX, -orgTextY);
    }
  }
};

module.exports = CRp;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global Path2D */

var is = __webpack_require__(0);

var CRp = {};

CRp.drawNode = function (context, node, shiftToOriginWithBb, drawLabel) {
  var r = this;
  var nodeWidth = void 0,
      nodeHeight = void 0;
  var _p = node._private;
  var rs = _p.rscratch;
  var pos = node.position();

  if (!is.number(pos.x) || !is.number(pos.y)) {
    return; // can't draw node with undefined position
  }

  if (!node.visible()) {
    return;
  }

  var parentOpacity = node.effectiveOpacity();

  var usePaths = r.usePaths();
  var path = void 0;
  var pathCacheHit = false;

  var padding = node.padding();

  nodeWidth = node.width() + 2 * padding;
  nodeHeight = node.height() + 2 * padding;

  //
  // setup shift

  var bb = void 0;
  if (shiftToOriginWithBb) {
    bb = shiftToOriginWithBb;

    context.translate(-bb.x1, -bb.y1);
  }

  //
  // load bg image

  var bgImgProp = node.pstyle('background-image');
  var urls = bgImgProp.value;
  var urlDefined = new Array(urls.length);
  var image = new Array(urls.length);
  var numImages = 0;
  for (var i = 0; i < urls.length; i++) {
    var url = urls[i];
    var defd = urlDefined[i] = url != null && url !== 'none';

    if (defd) {
      var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);

      numImages++;

      // get image, and if not loaded then ask to redraw when later loaded
      image[i] = r.getCachedImage(url, bgImgCrossOrigin, function () {
        node.emitAndNotify('background');
      });
    }
  }

  //
  // setup styles

  var darkness = node.pstyle('background-blacken').value;
  var borderWidth = node.pstyle('border-width').pfValue;
  var bgColor = node.pstyle('background-color').value;
  var bgOpacity = node.pstyle('background-opacity').value * parentOpacity;
  var borderColor = node.pstyle('border-color').value;
  var borderStyle = node.pstyle('border-style').value;
  var borderOpacity = node.pstyle('border-opacity').value * parentOpacity;

  context.lineJoin = 'miter'; // so borders are square with the node shape

  var setupShapeColor = function setupShapeColor() {
    var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;

    r.fillStyle(context, bgColor[0], bgColor[1], bgColor[2], bgOpy);
  };

  var setupBorderColor = function setupBorderColor() {
    var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;

    r.strokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);
  };

  //
  // setup shape

  var styleShape = node.pstyle('shape').strValue;
  var shapePts = node.pstyle('shape-polygon-points').pfValue;

  if (usePaths) {
    var pathCacheKey = styleShape + '$' + nodeWidth + '$' + nodeHeight + (styleShape === 'polygon' ? '$' + shapePts.join('$') : '');

    context.translate(pos.x, pos.y);

    if (rs.pathCacheKey === pathCacheKey) {
      path = rs.pathCache;
      pathCacheHit = true;
    } else {
      path = new Path2D();
      rs.pathCacheKey = pathCacheKey;
      rs.pathCache = path;
    }
  }

  var drawShape = function drawShape() {
    if (!pathCacheHit) {

      var npos = pos;

      if (usePaths) {
        npos = {
          x: 0,
          y: 0
        };
      }

      r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight);
    }

    if (usePaths) {
      context.fill(path);
    } else {
      context.fill();
    }
  };

  var drawImages = function drawImages() {
    var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : parentOpacity;

    var prevBging = _p.backgrounding;
    var totalCompleted = 0;

    for (var _i = 0; _i < image.length; _i++) {
      if (urlDefined[_i] && image[_i].complete && !image[_i].error) {
        totalCompleted++;
        r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);
      }
    }

    _p.backgrounding = !(totalCompleted === numImages);
    if (prevBging !== _p.backgrounding) {
      // update style b/c :backgrounding state changed
      node.updateStyle(false);
    }
  };

  var drawPie = function drawPie() {
    var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parentOpacity;

    if (r.hasPie(node)) {
      r.drawPie(context, node, pieOpacity);

      // redraw/restore path if steps after pie need it
      if (redrawShape) {

        if (!usePaths) {
          r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight);
        }
      }
    }
  };

  var darken = function darken() {
    var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : parentOpacity;

    var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;
    var c = darkness > 0 ? 0 : 255;

    if (darkness !== 0) {
      r.fillStyle(context, c, c, c, opacity);

      if (usePaths) {
        context.fill(path);
      } else {
        context.fill();
      }
    }
  };

  var drawBorder = function drawBorder() {
    if (borderWidth > 0) {

      context.lineWidth = borderWidth;
      context.lineCap = 'butt';

      if (context.setLineDash) {
        // for very outofdate browsers
        switch (borderStyle) {
          case 'dotted':
            context.setLineDash([1, 1]);
            break;

          case 'dashed':
            context.setLineDash([4, 2]);
            break;

          case 'solid':
          case 'double':
            context.setLineDash([]);
            break;
        }
      }

      if (usePaths) {
        context.stroke(path);
      } else {
        context.stroke();
      }

      if (borderStyle === 'double') {
        context.lineWidth = borderWidth / 3;

        var gco = context.globalCompositeOperation;
        context.globalCompositeOperation = 'destination-out';

        if (usePaths) {
          context.stroke(path);
        } else {
          context.stroke();
        }

        context.globalCompositeOperation = gco;
      }

      // reset in case we changed the border style
      if (context.setLineDash) {
        // for very outofdate browsers
        context.setLineDash([]);
      }
    }
  };

  var drawOverlay = function drawOverlay() {
    var overlayPadding = node.pstyle('overlay-padding').pfValue;
    var overlayOpacity = node.pstyle('overlay-opacity').value;
    var overlayColor = node.pstyle('overlay-color').value;

    if (overlayOpacity > 0) {
      r.fillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);

      r.nodeShapes['roundrectangle'].draw(context, pos.x, pos.y, nodeWidth + overlayPadding * 2, nodeHeight + overlayPadding * 2);

      context.fill();
    }
  };

  var drawText = function drawText() {
    r.drawElementText(context, node, drawLabel);
  };

  var ghost = node.pstyle('ghost').value === 'yes';

  if (ghost) {
    var gx = node.pstyle('ghost-offset-x').pfValue;
    var gy = node.pstyle('ghost-offset-y').pfValue;
    var ghostOpacity = node.pstyle('ghost-opacity').value;
    var effGhostOpacity = ghostOpacity * parentOpacity;

    context.translate(gx, gy);

    setupShapeColor(ghostOpacity * bgOpacity);
    drawShape();
    drawImages(effGhostOpacity);
    drawPie(darkness !== 0 || borderWidth !== 0);
    darken(effGhostOpacity);
    setupBorderColor(ghostOpacity * borderOpacity);
    drawBorder();

    context.translate(-gx, -gy);
  }

  setupShapeColor();
  drawShape();
  drawImages();
  drawPie(darkness !== 0 || borderWidth !== 0);
  darken();
  setupBorderColor();
  drawBorder();

  if (usePaths) {
    context.translate(-pos.x, -pos.y);
  }

  drawText();
  drawOverlay();

  //
  // clean up shift

  if (shiftToOriginWithBb) {
    context.translate(bb.x1, bb.y1);
  }
};

// does the node have at least one pie piece?
CRp.hasPie = function (node) {
  node = node[0]; // ensure ele ref

  return node._private.hasPie;
};

CRp.drawPie = function (context, node, nodeOpacity, pos) {
  node = node[0]; // ensure ele ref
  pos = pos || node.position();

  var cyStyle = node.cy().style();
  var pieSize = node.pstyle('pie-size');
  var x = pos.x;
  var y = pos.y;
  var nodeW = node.width();
  var nodeH = node.height();
  var radius = Math.min(nodeW, nodeH) / 2; // must fit in node
  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
  var usePaths = this.usePaths();

  if (usePaths) {
    x = 0;
    y = 0;
  }

  if (pieSize.units === '%') {
    radius = radius * pieSize.pfValue;
  } else if (pieSize.pfValue !== undefined) {
    radius = pieSize.pfValue / 2;
  }

  for (var i = 1; i <= cyStyle.pieBackgroundN; i++) {
    // 1..N
    var size = node.pstyle('pie-' + i + '-background-size').value;
    var color = node.pstyle('pie-' + i + '-background-color').value;
    var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;
    var percent = size / 100; // map integer range [0, 100] to [0, 1]

    // percent can't push beyond 1
    if (percent + lastPercent > 1) {
      percent = 1 - lastPercent;
    }

    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
    var angleDelta = 2 * Math.PI * percent;
    var angleEnd = angleStart + angleDelta;

    // ignore if
    // - zero size
    // - we're already beyond the full circle
    // - adding the current slice would go beyond the full circle
    if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {
      continue;
    }

    context.beginPath();
    context.moveTo(x, y);
    context.arc(x, y, radius, angleStart, angleEnd);
    context.closePath();

    this.fillStyle(context, color[0], color[1], color[2], opacity);

    context.fill();

    lastPercent += percent;
  }
};

module.exports = CRp;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CRp = {};

var util = __webpack_require__(1);

var motionBlurDelay = 100;

// var isFirefox = typeof InstallTrigger !== 'undefined';

CRp.getPixelRatio = function () {
  var context = this.data.contexts[0];

  if (this.forcedPixelRatio != null) {
    return this.forcedPixelRatio;
  }

  var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;

  return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef
};

CRp.paintCache = function (context) {
  var caches = this.paintCaches = this.paintCaches || [];
  var needToCreateCache = true;
  var cache;

  for (var i = 0; i < caches.length; i++) {
    cache = caches[i];

    if (cache.context === context) {
      needToCreateCache = false;
      break;
    }
  }

  if (needToCreateCache) {
    cache = {
      context: context
    };
    caches.push(cache);
  }

  return cache;
};

CRp.fillStyle = function (context, r, g, b, a) {
  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // turn off for now, seems context does its own caching

  // var cache = this.paintCache(context);

  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // if( cache.fillStyle !== fillStyle ){
  //   context.fillStyle = cache.fillStyle = fillStyle;
  // }
};

CRp.strokeStyle = function (context, r, g, b, a) {
  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // turn off for now, seems context does its own caching

  // var cache = this.paintCache(context);

  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // if( cache.strokeStyle !== strokeStyle ){
  //   context.strokeStyle = cache.strokeStyle = strokeStyle;
  // }
};

// Resize canvas
CRp.matchCanvasSize = function (container) {
  var r = this;
  var data = r.data;
  var bb = r.findContainerClientCoords();
  var width = bb[2];
  var height = bb[3];
  var pixelRatio = r.getPixelRatio();
  var mbPxRatio = r.motionBlurPxRatio;

  if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {
    pixelRatio = mbPxRatio;
  }

  var canvasWidth = width * pixelRatio;
  var canvasHeight = height * pixelRatio;
  var canvas;

  if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {
    return; // save cycles if same
  }

  r.fontCaches = null; // resizing resets the style

  var canvasContainer = data.canvasContainer;
  canvasContainer.style.width = width + 'px';
  canvasContainer.style.height = height + 'px';

  for (var i = 0; i < r.CANVAS_LAYERS; i++) {
    canvas = data.canvases[i];

    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }

  for (var i = 0; i < r.BUFFER_COUNT; i++) {
    canvas = data.bufferCanvases[i];

    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }

  r.textureMult = 1;
  if (pixelRatio <= 1) {
    canvas = data.bufferCanvases[r.TEXTURE_BUFFER];

    r.textureMult = 2;
    canvas.width = canvasWidth * r.textureMult;
    canvas.height = canvasHeight * r.textureMult;
  }

  r.canvasWidth = canvasWidth;
  r.canvasHeight = canvasHeight;
};

CRp.renderTo = function (cxt, zoom, pan, pxRatio) {
  this.render({
    forcedContext: cxt,
    forcedZoom: zoom,
    forcedPan: pan,
    drawAllLayers: true,
    forcedPxRatio: pxRatio
  });
};

CRp.render = function (options) {
  options = options || util.staticEmptyObject();

  var forcedContext = options.forcedContext;
  var drawAllLayers = options.drawAllLayers;
  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
  var forcedZoom = options.forcedZoom;
  var forcedPan = options.forcedPan;
  var r = this;
  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
  var cy = r.cy;var data = r.data;
  var needDraw = data.canvasNeedsRedraw;
  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
  var mbPxRatio = r.motionBlurPxRatio;
  var hasCompoundNodes = cy.hasCompoundNodes();
  var inNodeDragGesture = r.hoverData.draggingEles;
  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
  var motionBlurFadeEffect = motionBlur;

  if (!forcedContext) {
    if (r.prevPxRatio !== pixelRatio) {
      r.invalidateContainerClientCoordsCache();
      r.matchCanvasSize(r.container);

      r.redrawHint('eles', true);
      r.redrawHint('drag', true);
    }

    r.prevPxRatio = pixelRatio;
  }

  if (!forcedContext && r.motionBlurTimeout) {
    clearTimeout(r.motionBlurTimeout);
  }

  if (motionBlur) {
    if (r.mbFrames == null) {
      r.mbFrames = 0;
    }

    r.mbFrames++;

    if (r.mbFrames < 3) {
      // need several frames before even high quality motionblur
      motionBlurFadeEffect = false;
    }

    // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)
    if (r.mbFrames > r.minMbLowQualFrames) {
      //r.fullQualityMb = false;
      r.motionBlurPxRatio = r.mbPxRBlurry;
    }
  }

  if (r.clearingMotionBlur) {
    r.motionBlurPxRatio = 1;
  }

  // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
  // because a rogue async texture frame would clear needDraw
  if (r.textureDrawLastFrame && !textureDraw) {
    needDraw[r.NODE] = true;
    needDraw[r.SELECT_BOX] = true;
  }

  var coreStyle = cy.style()._private.coreStyle;

  var zoom = cy.zoom();
  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
  var pan = cy.pan();
  var effectivePan = {
    x: pan.x,
    y: pan.y
  };

  var vp = {
    zoom: zoom,
    pan: {
      x: pan.x,
      y: pan.y
    }
  };
  var prevVp = r.prevViewport;
  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;

  // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)
  if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {
    r.motionBlurPxRatio = 1;
  }

  if (forcedPan) {
    effectivePan = forcedPan;
  }

  // apply pixel ratio

  effectiveZoom *= pixelRatio;
  effectivePan.x *= pixelRatio;
  effectivePan.y *= pixelRatio;

  var eles = r.getCachedZSortedEles();

  function mbclear(context, x, y, w, h) {
    var gco = context.globalCompositeOperation;

    context.globalCompositeOperation = 'destination-out';
    r.fillStyle(context, 255, 255, 255, r.motionBlurTransparency);
    context.fillRect(x, y, w, h);

    context.globalCompositeOperation = gco;
  }

  function setContextTransform(context, clear) {
    var ePan, eZoom, w, h;

    if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {
      ePan = {
        x: pan.x * mbPxRatio,
        y: pan.y * mbPxRatio
      };

      eZoom = zoom * mbPxRatio;

      w = r.canvasWidth * mbPxRatio;
      h = r.canvasHeight * mbPxRatio;
    } else {
      ePan = effectivePan;
      eZoom = effectiveZoom;

      w = r.canvasWidth;
      h = r.canvasHeight;
    }

    context.setTransform(1, 0, 0, 1, 0, 0);

    if (clear === 'motionBlur') {
      mbclear(context, 0, 0, w, h);
    } else if (!forcedContext && (clear === undefined || clear)) {
      context.clearRect(0, 0, w, h);
    }

    if (!drawAllLayers) {
      context.translate(ePan.x, ePan.y);
      context.scale(eZoom, eZoom);
    }
    if (forcedPan) {
      context.translate(forcedPan.x, forcedPan.y);
    }
    if (forcedZoom) {
      context.scale(forcedZoom, forcedZoom);
    }
  }

  if (!textureDraw) {
    r.textureDrawLastFrame = false;
  }

  if (textureDraw) {
    r.textureDrawLastFrame = true;

    var bb;

    if (!r.textureCache) {
      r.textureCache = {};

      bb = r.textureCache.bb = cy.mutableElements().boundingBox();

      r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];

      var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];

      cxt.setTransform(1, 0, 0, 1, 0, 0);
      cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);

      r.render({
        forcedContext: cxt,
        drawOnlyNodeLayer: true,
        forcedPxRatio: pixelRatio * r.textureMult
      });

      var vp = r.textureCache.viewport = {
        zoom: cy.zoom(),
        pan: cy.pan(),
        width: r.canvasWidth,
        height: r.canvasHeight
      };

      vp.mpan = {
        x: (0 - vp.pan.x) / vp.zoom,
        y: (0 - vp.pan.y) / vp.zoom
      };
    }

    needDraw[r.DRAG] = false;
    needDraw[r.NODE] = false;

    var context = data.contexts[r.NODE];

    var texture = r.textureCache.texture;
    var vp = r.textureCache.viewport;
    bb = r.textureCache.bb;

    context.setTransform(1, 0, 0, 1, 0, 0);

    if (motionBlur) {
      mbclear(context, 0, 0, vp.width, vp.height);
    } else {
      context.clearRect(0, 0, vp.width, vp.height);
    }

    var outsideBgColor = coreStyle['outside-texture-bg-color'].value;
    var outsideBgOpacity = coreStyle['outside-texture-bg-opacity'].value;
    r.fillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);
    context.fillRect(0, 0, vp.width, vp.height);

    var zoom = cy.zoom();

    setContextTransform(context, false);

    context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
    context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
  } else if (r.textureOnViewport && !forcedContext) {
    // clear the cache since we don't need it
    r.textureCache = null;
  }

  var extent = cy.extent();
  var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles;
  var hideEdges = r.hideEdgesOnViewport && vpManip;

  var needMbClear = [];

  needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;
  if (needMbClear[r.NODE]) {
    r.clearedForMotionBlur[r.NODE] = true;
  }

  needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;
  if (needMbClear[r.DRAG]) {
    r.clearedForMotionBlur[r.DRAG] = true;
  }

  if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {
    var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;
    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);
    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;

    setContextTransform(context, clear);

    if (hideEdges) {
      r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);
    } else {
      r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);
    }

    if (r.debug) {
      r.drawDebugPoints(context, eles.nondrag);
    }

    if (!drawAllLayers && !motionBlur) {
      needDraw[r.NODE] = false;
    }
  }

  if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {
    var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;
    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);

    setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);

    if (hideEdges) {
      r.drawCachedNodes(context, eles.drag, pixelRatio, extent);
    } else {
      r.drawCachedElements(context, eles.drag, pixelRatio, extent);
    }

    if (r.debug) {
      r.drawDebugPoints(context, eles.drag);
    }

    if (!drawAllLayers && !motionBlur) {
      needDraw[r.DRAG] = false;
    }
  }

  if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {
    var context = forcedContext || data.contexts[r.SELECT_BOX];

    setContextTransform(context);

    if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {
      var zoom = r.cy.zoom();
      var borderWidth = coreStyle['selection-box-border-width'].value / zoom;

      context.lineWidth = borderWidth;
      context.fillStyle = 'rgba(' + coreStyle['selection-box-color'].value[0] + ',' + coreStyle['selection-box-color'].value[1] + ',' + coreStyle['selection-box-color'].value[2] + ',' + coreStyle['selection-box-opacity'].value + ')';

      context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);

      if (borderWidth > 0) {
        context.strokeStyle = 'rgba(' + coreStyle['selection-box-border-color'].value[0] + ',' + coreStyle['selection-box-border-color'].value[1] + ',' + coreStyle['selection-box-border-color'].value[2] + ',' + coreStyle['selection-box-opacity'].value + ')';

        context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);
      }
    }

    if (data.bgActivePosistion && !r.hoverData.selecting) {
      var zoom = r.cy.zoom();
      var pos = data.bgActivePosistion;

      context.fillStyle = 'rgba(' + coreStyle['active-bg-color'].value[0] + ',' + coreStyle['active-bg-color'].value[1] + ',' + coreStyle['active-bg-color'].value[2] + ',' + coreStyle['active-bg-opacity'].value + ')';

      context.beginPath();
      context.arc(pos.x, pos.y, coreStyle['active-bg-size'].pfValue / zoom, 0, 2 * Math.PI);
      context.fill();
    }

    var timeToRender = r.lastRedrawTime;
    if (r.showFps && timeToRender) {
      timeToRender = Math.round(timeToRender);
      var fps = Math.round(1000 / timeToRender);

      context.setTransform(1, 0, 0, 1, 0, 0);

      context.fillStyle = 'rgba(255, 0, 0, 0.75)';
      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
      context.lineWidth = 1;
      context.fillText('1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);

      var maxFps = 60;
      context.strokeRect(0, 30, 250, 20);
      context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);
    }

    if (!drawAllLayers) {
      needDraw[r.SELECT_BOX] = false;
    }
  }

  // motionblur: blit rendered blurry frames
  if (motionBlur && mbPxRatio !== 1) {
    var cxtNode = data.contexts[r.NODE];
    var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];

    var cxtDrag = data.contexts[r.DRAG];
    var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];

    var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {
      cxt.setTransform(1, 0, 0, 1, 0, 0);

      if (needClear || !motionBlurFadeEffect) {
        cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);
      } else {
        mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);
      }

      var pxr = mbPxRatio;

      cxt.drawImage(txt, // img
      0, 0, // sx, sy
      r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
      0, 0, // x, y
      r.canvasWidth, r.canvasHeight // w, h
      );
    };

    if (needDraw[r.NODE] || needMbClear[r.NODE]) {
      drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);
      needDraw[r.NODE] = false;
    }

    if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {
      drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);
      needDraw[r.DRAG] = false;
    }
  }

  r.prevViewport = vp;

  if (r.clearingMotionBlur) {
    r.clearingMotionBlur = false;
    r.motionBlurCleared = true;
    r.motionBlur = true;
  }

  if (motionBlur) {
    r.motionBlurTimeout = setTimeout(function () {
      r.motionBlurTimeout = null;

      r.clearedForMotionBlur[r.NODE] = false;
      r.clearedForMotionBlur[r.DRAG] = false;
      r.motionBlur = false;
      r.clearingMotionBlur = !textureDraw;
      r.mbFrames = 0;

      needDraw[r.NODE] = true;
      needDraw[r.DRAG] = true;

      r.redraw();
    }, motionBlurDelay);
  }

  if (!forcedContext) {
    cy.emit('render');
  }
};

module.exports = CRp;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);

var CRp = {};

// @O Polygon drawing
CRp.drawPolygonPath = function (context, x, y, width, height, points) {

  var halfW = width / 2;
  var halfH = height / 2;

  if (context.beginPath) {
    context.beginPath();
  }

  context.moveTo(x + halfW * points[0], y + halfH * points[1]);

  for (var i = 1; i < points.length / 2; i++) {
    context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);
  }

  context.closePath();
};

// Round rectangle drawing
CRp.drawRoundRectanglePath = function (context, x, y, width, height) {

  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerRadius = math.getRoundRectangleRadius(width, height);

  if (context.beginPath) {
    context.beginPath();
  }

  // Start at top middle
  context.moveTo(x, y - halfHeight);
  // Arc from middle top to right side
  context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);
  // Arc from right side to bottom
  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
  // Arc from bottom to left side
  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
  // Arc from left side to topBorder
  context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);
  // Join line
  context.lineTo(x, y - halfHeight);

  context.closePath();
};

CRp.drawBottomRoundRectanglePath = function (context, x, y, width, height) {

  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerRadius = math.getRoundRectangleRadius(width, height);

  if (context.beginPath) {
    context.beginPath();
  }

  // Start at top middle
  context.moveTo(x, y - halfHeight);
  context.lineTo(x + halfWidth, y - halfHeight);
  context.lineTo(x + halfWidth, y);

  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);

  context.lineTo(x - halfWidth, y - halfHeight);
  context.lineTo(x, y - halfHeight);

  context.closePath();
};

CRp.drawCutRectanglePath = function (context, x, y, width, height) {

  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerLength = math.getCutRectangleCornerLength();

  if (context.beginPath) {
    context.beginPath();
  }

  context.moveTo(x - halfWidth + cornerLength, y - halfHeight);

  context.lineTo(x + halfWidth - cornerLength, y - halfHeight);
  context.lineTo(x + halfWidth, y - halfHeight + cornerLength);
  context.lineTo(x + halfWidth, y + halfHeight - cornerLength);
  context.lineTo(x + halfWidth - cornerLength, y + halfHeight);
  context.lineTo(x - halfWidth + cornerLength, y + halfHeight);
  context.lineTo(x - halfWidth, y + halfHeight - cornerLength);
  context.lineTo(x - halfWidth, y - halfHeight + cornerLength);

  context.closePath();
};

CRp.drawBarrelPath = function (context, x, y, width, height) {

  var halfWidth = width / 2;
  var halfHeight = height / 2;

  var xBegin = x - halfWidth;
  var xEnd = x + halfWidth;
  var yBegin = y - halfHeight;
  var yEnd = y + halfHeight;

  var barrelCurveConstants = math.getBarrelCurveConstants(width, height);
  var wOffset = barrelCurveConstants.widthOffset;
  var hOffset = barrelCurveConstants.heightOffset;
  var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;

  if (context.beginPath) {
    context.beginPath();
  }

  context.moveTo(xBegin, yBegin + hOffset);

  context.lineTo(xBegin, yEnd - hOffset);
  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);

  context.lineTo(xEnd - wOffset, yEnd);
  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);

  context.lineTo(xEnd, yBegin + hOffset);
  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);

  context.lineTo(xBegin + wOffset, yBegin);
  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);

  context.closePath();
};

var sin0 = Math.sin(0);
var cos0 = Math.cos(0);

var sin = {};
var cos = {};

var ellipseStepSize = Math.PI / 40;

for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
  sin[i] = Math.sin(i);
  cos[i] = Math.cos(i);
}

CRp.drawEllipsePath = function (context, centerX, centerY, width, height) {
  if (context.beginPath) {
    context.beginPath();
  }

  if (context.ellipse) {
    context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);
  } else {
    var xPos, yPos;
    var rw = width / 2;
    var rh = height / 2;
    for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
      xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;
      yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;

      if (i === 0) {
        context.moveTo(xPos, yPos);
      } else {
        context.lineTo(xPos, yPos);
      }
    }
  }

  context.closePath();
};

module.exports = CRp;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);
var util = __webpack_require__(1);
var Heap = __webpack_require__(8);
var defs = __webpack_require__(16);

var minTxrH = 25; // the size of the texture cache for small height eles (special case)
var txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up
var minLvl = -4; // when scaling smaller than that we don't need to re-render
var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)
var maxZoom = 3.99; // beyond this zoom level, layered textures are not used
var eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps
var defTxrWidth = 1024; // default/minimum texture width
var maxTxrW = 1024; // the maximum width of a texture
var maxTxrH = 1024; // the maximum height of a texture
var minUtility = 0.5; // if usage of texture is less than this, it is retired
var maxFullness = 0.8; // fullness of texture after which queue removal is checked
var maxFullnessChecks = 10; // dequeued after this many checks
var allowEdgeTxrCaching = false; // whether edges can be cached as textures (TODO maybe better on if webgl supported?)
var allowParentTxrCaching = false; // whether parent nodes can be cached as textures (TODO maybe better on if webgl supported?)
var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time
var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
var deqFastCost = 0.9; // % of frame time to be used when >60fps
var deqRedrawThreshold = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch

var getTxrReasons = {
  dequeue: 'dequeue',
  downscale: 'downscale',
  highQuality: 'highQuality'
};

var ElementTextureCache = function ElementTextureCache(renderer) {
  var self = this;

  self.renderer = renderer;
  self.onDequeues = [];

  self.setupDequeueing();
};

var ETCp = ElementTextureCache.prototype;

ETCp.reasons = getTxrReasons;

// the list of textures in which new subtextures for elements can be placed
ETCp.getTextureQueue = function (txrH) {
  var self = this;
  self.eleImgCaches = self.eleImgCaches || {};

  return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];
};

// the list of usused textures which can be recycled (in use in texture queue)
ETCp.getRetiredTextureQueue = function (txrH) {
  var self = this;

  var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};
  var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];

  return rtxtrQ;
};

// queue of element draw requests at different scale levels
ETCp.getElementQueue = function () {
  var self = this;

  var q = self.eleCacheQueue = self.eleCacheQueue || new Heap(function (a, b) {
    return b.reqs - a.reqs;
  });

  return q;
};

// queue of element draw requests at different scale levels (element id lookup)
ETCp.getElementIdToQueue = function () {
  var self = this;

  var id2q = self.eleIdToCacheQueue = self.eleIdToCacheQueue || {};

  return id2q;
};

ETCp.getElement = function (ele, bb, pxRatio, lvl, reason) {
  var self = this;
  var r = this.renderer;
  var rs = ele._private.rscratch;
  var zoom = r.cy.zoom();

  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
    return null;
  }

  if (lvl == null) {
    lvl = Math.ceil(math.log2(zoom * pxRatio));
  }

  if (lvl < minLvl) {
    lvl = minLvl;
  } else if (zoom >= maxZoom || lvl > maxLvl) {
    return null;
  }

  var scale = Math.pow(2, lvl);
  var eleScaledH = bb.h * scale;
  var eleScaledW = bb.w * scale;
  var caches = rs.imgCaches = rs.imgCaches || {};
  var eleCache = caches[lvl];

  if (eleCache) {
    return eleCache;
  }

  var txrH; // which texture height this ele belongs to

  if (eleScaledH <= minTxrH) {
    txrH = minTxrH;
  } else if (eleScaledH <= txrStepH) {
    txrH = txrStepH;
  } else {
    txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;
  }

  if (eleScaledH > maxTxrH || eleScaledW > maxTxrW || !allowEdgeTxrCaching && ele.isEdge() || !allowParentTxrCaching && ele.isParent()) {
    return null; // caching large elements is not efficient
  }

  var txrQ = self.getTextureQueue(txrH);

  // first try the second last one in case it has space at the end
  var txr = txrQ[txrQ.length - 2];

  var addNewTxr = function addNewTxr() {
    return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);
  };

  // try the last one if there is no second last one
  if (!txr) {
    txr = txrQ[txrQ.length - 1];
  }

  // if the last one doesn't exist, we need a first one
  if (!txr) {
    txr = addNewTxr();
  }

  // if there's no room in the current texture, we need a new one
  if (txr.width - txr.usedWidth < eleScaledW) {
    txr = addNewTxr();
  }

  var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);
  var scalableFrom = function scalableFrom(otherCache) {
    return otherCache && otherCache.scaledLabelShown === scaledLabelShown;
  };

  var deqing = reason && reason === getTxrReasons.dequeue;
  var highQualityReq = reason && reason === getTxrReasons.highQuality;
  var downscaleReq = reason && reason === getTxrReasons.downscale;

  var higherCache; // the nearest cache with a higher level
  for (var l = lvl + 1; l <= maxLvl; l++) {
    var c = caches[l];

    if (c) {
      higherCache = c;break;
    }
  }

  var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;

  var downscale = function downscale() {
    txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);
  };

  // reset ele area in texture
  txr.context.setTransform(1, 0, 0, 1, 0, 0);
  txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);

  if (scalableFrom(oneUpCache)) {
    // then we can relatively cheaply rescale the existing image w/o rerendering
    downscale();
  } else if (scalableFrom(higherCache)) {
    // then use the higher cache for now and queue the next level down
    // to cheaply scale towards the smaller level

    if (highQualityReq) {
      for (var l = higherCache.level; l > lvl; l--) {
        oneUpCache = self.getElement(ele, bb, pxRatio, l, getTxrReasons.downscale);
      }

      downscale();
    } else {
      self.queueElement(ele, higherCache.level - 1);

      return higherCache;
    }
  } else {

    var lowerCache; // the nearest cache with a lower level
    if (!deqing && !highQualityReq && !downscaleReq) {
      for (var l = lvl - 1; l >= minLvl; l--) {
        var c = caches[l];

        if (c) {
          lowerCache = c;break;
        }
      }
    }

    if (scalableFrom(lowerCache)) {
      // then use the lower quality cache for now and queue the better one for later

      self.queueElement(ele, lvl);

      return lowerCache;
    }

    txr.context.translate(txr.usedWidth, 0);
    txr.context.scale(scale, scale);

    r.drawElement(txr.context, ele, bb, scaledLabelShown);

    txr.context.scale(1 / scale, 1 / scale);
    txr.context.translate(-txr.usedWidth, 0);
  }

  eleCache = caches[lvl] = {
    ele: ele,
    x: txr.usedWidth,
    texture: txr,
    level: lvl,
    scale: scale,
    width: eleScaledW,
    height: eleScaledH,
    scaledLabelShown: scaledLabelShown
  };

  txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);

  txr.eleCaches.push(eleCache);

  self.checkTextureFullness(txr);

  return eleCache;
};

ETCp.invalidateElement = function (ele) {
  var self = this;
  var caches = ele._private.rscratch.imgCaches;

  if (caches) {
    for (var lvl = minLvl; lvl <= maxLvl; lvl++) {
      var cache = caches[lvl];

      if (cache) {
        var txr = cache.texture;

        // remove space from the texture it belongs to
        txr.invalidatedWidth += cache.width;

        // remove refs with the element
        caches[lvl] = null;
        util.removeFromArray(txr.eleCaches, cache);

        // remove from queue since the old req was for the old state
        self.removeFromQueue(ele);

        // might have to remove the entire texture if it's not efficiently using its space
        self.checkTextureUtility(txr);
      }
    }
  }
};

ETCp.checkTextureUtility = function (txr) {
  // invalidate all entries in the cache if the cache size is small
  if (txr.invalidatedWidth >= minUtility * txr.width) {
    this.retireTexture(txr);
  }
};

ETCp.checkTextureFullness = function (txr) {
  // if texture has been mostly filled and passed over several times, remove
  // it from the queue so we don't need to waste time looking at it to put new things

  var self = this;
  var txrQ = self.getTextureQueue(txr.height);

  if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {
    util.removeFromArray(txrQ, txr);
  } else {
    txr.fullnessChecks++;
  }
};

ETCp.retireTexture = function (txr) {
  var self = this;
  var txrH = txr.height;
  var txrQ = self.getTextureQueue(txrH);

  // retire the texture from the active / searchable queue:

  util.removeFromArray(txrQ, txr);

  txr.retired = true;

  // remove the refs from the eles to the caches:

  var eleCaches = txr.eleCaches;

  for (var i = 0; i < eleCaches.length; i++) {
    var eleCache = eleCaches[i];
    var ele = eleCache.ele;
    var lvl = eleCache.level;
    var imgCaches = ele._private.rscratch.imgCaches;

    if (imgCaches) {
      imgCaches[lvl] = null;
    }
  }

  util.clearArray(eleCaches);

  // add the texture to a retired queue so it can be recycled in future:

  var rtxtrQ = self.getRetiredTextureQueue(txrH);

  rtxtrQ.push(txr);
};

ETCp.addTexture = function (txrH, minW) {
  var self = this;
  var txrQ = self.getTextureQueue(txrH);
  var txr = {};

  txrQ.push(txr);

  txr.eleCaches = [];

  txr.height = txrH;
  txr.width = Math.max(defTxrWidth, minW);
  txr.usedWidth = 0;
  txr.invalidatedWidth = 0;
  txr.fullnessChecks = 0;

  txr.canvas = document.createElement('canvas'); // eslint-disable-line no-undef
  txr.canvas.width = txr.width;
  txr.canvas.height = txr.height;

  txr.context = txr.canvas.getContext('2d');

  return txr;
};

ETCp.recycleTexture = function (txrH, minW) {
  var self = this;
  var txrQ = self.getTextureQueue(txrH);
  var rtxtrQ = self.getRetiredTextureQueue(txrH);

  for (var i = 0; i < rtxtrQ.length; i++) {
    var txr = rtxtrQ[i];

    if (txr.width >= minW) {
      txr.retired = false;

      txr.usedWidth = 0;
      txr.invalidatedWidth = 0;
      txr.fullnessChecks = 0;

      util.clearArray(txr.eleCaches);

      txr.context.setTransform(1, 0, 0, 1, 0, 0);
      txr.context.clearRect(0, 0, txr.width, txr.height);

      util.removeFromArray(rtxtrQ, txr);
      txrQ.push(txr);

      return txr;
    }
  }
};

ETCp.queueElement = function (ele, lvl) {
  var self = this;
  var q = self.getElementQueue();
  var id2q = self.getElementIdToQueue();
  var id = ele.id();
  var existingReq = id2q[id];

  if (existingReq) {
    // use the max lvl b/c in between lvls are cheap to make
    existingReq.level = Math.max(existingReq.level, lvl);
    existingReq.reqs++;

    q.updateItem(existingReq);
  } else {
    var req = {
      ele: ele,
      level: lvl,
      reqs: 1
    };

    q.push(req);

    id2q[id] = req;
  }
};

ETCp.dequeue = function (pxRatio /*, extent*/) {
  var self = this;
  var q = self.getElementQueue();
  var id2q = self.getElementIdToQueue();
  var dequeued = [];

  for (var i = 0; i < maxDeqSize; i++) {
    if (q.size() > 0) {
      var req = q.pop();
      var ele = req.ele;
      var caches = ele._private.rscratch.imgCaches;

      // dequeueing isn't necessary when an existing cache exists
      if (caches[req.level] != null) {
        continue;
      }

      id2q[ele.id()] = null;

      dequeued.push(req);

      var bb = ele.boundingBox();

      self.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);
    } else {
      break;
    }
  }

  return dequeued;
};

ETCp.removeFromQueue = function (ele) {
  var self = this;
  var q = self.getElementQueue();
  var id2q = self.getElementIdToQueue();
  var req = id2q[ele.id()];

  if (req != null) {
    // bring to front of queue
    req.reqs = util.MAX_INT;
    q.updateItem(req);

    q.pop(); // remove from queue

    id2q[ele.id()] = null; // remove from lookup map
  }
};

ETCp.onDequeue = function (fn) {
  this.onDequeues.push(fn);
};
ETCp.offDequeue = function (fn) {
  util.removeFromArray(this.onDequeues, fn);
};

ETCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold,
  deqCost: deqCost,
  deqAvgCost: deqAvgCost,
  deqNoDrawCost: deqNoDrawCost,
  deqFastCost: deqFastCost,
  deq: function deq(self, pxRatio, extent) {
    return self.dequeue(pxRatio, extent);
  },
  onDeqd: function onDeqd(self, deqd) {
    for (var i = 0; i < self.onDequeues.length; i++) {
      var fn = self.onDequeues[i];

      fn(deqd);
    }
  },
  shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {
    for (var i = 0; i < deqd.length; i++) {
      var bb = deqd[i].ele.boundingBox();

      if (math.boundingBoxesIntersect(bb, extent)) {
        return true;
      }
    }

    return false;
  },
  priority: function priority(self) {
    return self.renderer.beforeRenderPriorities.eleTxrDeq;
  }
});

module.exports = ElementTextureCache;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

var CRp = {};

CRp.createBuffer = function (w, h) {
  var buffer = document.createElement('canvas'); // eslint-disable-line no-undef
  buffer.width = w;
  buffer.height = h;

  return [buffer, buffer.getContext('2d')];
};

CRp.bufferCanvasImage = function (options) {
  var cy = this.cy;
  var eles = cy.mutableElements();
  var bb = eles.boundingBox();
  var ctrRect = this.findContainerClientCoords();
  var width = options.full ? Math.ceil(bb.w) : ctrRect[2];
  var height = options.full ? Math.ceil(bb.h) : ctrRect[3];
  var specdMaxDims = is.number(options.maxWidth) || is.number(options.maxHeight);
  var pxRatio = this.getPixelRatio();
  var scale = 1;

  if (options.scale !== undefined) {
    width *= options.scale;
    height *= options.scale;

    scale = options.scale;
  } else if (specdMaxDims) {
    var maxScaleW = Infinity;
    var maxScaleH = Infinity;

    if (is.number(options.maxWidth)) {
      maxScaleW = scale * options.maxWidth / width;
    }

    if (is.number(options.maxHeight)) {
      maxScaleH = scale * options.maxHeight / height;
    }

    scale = Math.min(maxScaleW, maxScaleH);

    width *= scale;
    height *= scale;
  }

  if (!specdMaxDims) {
    width *= pxRatio;
    height *= pxRatio;
    scale *= pxRatio;
  }

  var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef

  buffCanvas.width = width;
  buffCanvas.height = height;

  buffCanvas.style.width = width + 'px';
  buffCanvas.style.height = height + 'px';

  var buffCxt = buffCanvas.getContext('2d');

  // Rasterize the layers, but only if container has nonzero size
  if (width > 0 && height > 0) {

    buffCxt.clearRect(0, 0, width, height);

    buffCxt.globalCompositeOperation = 'source-over';

    var zsortedEles = this.getCachedZSortedEles();

    if (options.full) {
      // draw the full bounds of the graph
      buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);
      buffCxt.scale(scale, scale);

      this.drawElements(buffCxt, zsortedEles);

      buffCxt.scale(1 / scale, 1 / scale);
      buffCxt.translate(bb.x1 * scale, bb.y1 * scale);
    } else {
      // draw the current view
      var pan = cy.pan();

      var translation = {
        x: pan.x * scale,
        y: pan.y * scale
      };

      scale *= cy.zoom();

      buffCxt.translate(translation.x, translation.y);
      buffCxt.scale(scale, scale);

      this.drawElements(buffCxt, zsortedEles);

      buffCxt.scale(1 / scale, 1 / scale);
      buffCxt.translate(-translation.x, -translation.y);
    }

    // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs
    if (options.bg) {
      buffCxt.globalCompositeOperation = 'destination-over';

      buffCxt.fillStyle = options.bg;
      buffCxt.rect(0, 0, width, height);
      buffCxt.fill();
    }
  }

  return buffCanvas;
};

function b64ToBlob(b64, mimeType) {
  var bytes = atob(b64);
  var buff = new ArrayBuffer(bytes.length);
  var buffUint8 = new Uint8Array(buff);

  for (var i = 0; i < bytes.length; i++) {
    buffUint8[i] = bytes.charCodeAt(i);
  }

  return new Blob([buff], { type: mimeType });
}

function b64UriToB64(b64uri) {
  var i = b64uri.indexOf(',');

  return b64uri.substr(i + 1);
};

function output(options, canvas, mimeType) {
  var b64Uri = canvas.toDataURL(mimeType, options.quality);

  switch (options.output) {
    case 'blob':
      return b64ToBlob(b64UriToB64(b64Uri), mimeType);

    case 'base64':
      return b64UriToB64(b64Uri);

    case 'base64uri':
    default:
      return b64Uri;
  }
}

CRp.png = function (options) {
  return output(options, this.bufferCanvasImage(options), 'image/png');
};

CRp.jpg = function (options) {
  return output(options, this.bufferCanvasImage(options), 'image/jpeg');
};

module.exports = CRp;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
The canvas renderer was written by Yue Dong.

Modifications tracked on Github.
*/

var util = __webpack_require__(1);
var is = __webpack_require__(0);
var ElementTextureCache = __webpack_require__(110);
var LayeredTextureCache = __webpack_require__(113);

var CR = CanvasRenderer;
var CRp = CanvasRenderer.prototype;

CRp.CANVAS_LAYERS = 3;
//
CRp.SELECT_BOX = 0;
CRp.DRAG = 1;
CRp.NODE = 2;

CRp.BUFFER_COUNT = 3;
//
CRp.TEXTURE_BUFFER = 0;
CRp.MOTIONBLUR_BUFFER_NODE = 1;
CRp.MOTIONBLUR_BUFFER_DRAG = 2;

function CanvasRenderer(options) {
  var r = this;

  r.data = {
    canvases: new Array(CRp.CANVAS_LAYERS),
    contexts: new Array(CRp.CANVAS_LAYERS),
    canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),

    bufferCanvases: new Array(CRp.BUFFER_COUNT),
    bufferContexts: new Array(CRp.CANVAS_LAYERS)
  };

  var tapHlOff = '-webkit-tap-highlight-color: rgba(0,0,0,0);';

  r.data.canvasContainer = document.createElement('div'); // eslint-disable-line no-undef
  var containerStyle = r.data.canvasContainer.style;
  r.data.canvasContainer.setAttribute('style', tapHlOff);
  containerStyle.position = 'relative';
  containerStyle.zIndex = '0';
  containerStyle.overflow = 'hidden';

  var container = options.cy.container();
  container.appendChild(r.data.canvasContainer);

  if ((container.getAttribute('style') || '').indexOf(tapHlOff) < 0) {
    container.setAttribute('style', (container.getAttribute('style') || '') + tapHlOff);
  }

  for (var i = 0; i < CRp.CANVAS_LAYERS; i++) {
    var canvas = r.data.canvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef
    r.data.contexts[i] = canvas.getContext('2d');
    canvas.setAttribute('style', '-webkit-user-select: none; -moz-user-select: -moz-none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0); outline-style: none;' + (is.ms() ? ' -ms-touch-action: none; touch-action: none; ' : ''));
    canvas.style.position = 'absolute';
    canvas.setAttribute('data-id', 'layer' + i);
    canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);
    r.data.canvasContainer.appendChild(canvas);

    r.data.canvasNeedsRedraw[i] = false;
  }
  r.data.topCanvas = r.data.canvases[0];

  r.data.canvases[CRp.NODE].setAttribute('data-id', 'layer' + CRp.NODE + '-node');
  r.data.canvases[CRp.SELECT_BOX].setAttribute('data-id', 'layer' + CRp.SELECT_BOX + '-selectbox');
  r.data.canvases[CRp.DRAG].setAttribute('data-id', 'layer' + CRp.DRAG + '-drag');

  for (var i = 0; i < CRp.BUFFER_COUNT; i++) {
    r.data.bufferCanvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef
    r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');
    r.data.bufferCanvases[i].style.position = 'absolute';
    r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
    r.data.bufferCanvases[i].style.zIndex = String(-i - 1);
    r.data.bufferCanvases[i].style.visibility = 'hidden';
    //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);
  }

  r.pathsEnabled = true;

  r.data.eleTxrCache = new ElementTextureCache(r);
  r.data.lyrTxrCache = new LayeredTextureCache(r, r.data.eleTxrCache);

  r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {
    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var rs = ele._private.rstyle;
      var de = rs.dirtyEvents;

      if (ele.isNode() && de && de.length === 1 && de['position']) {
        // then keep cached ele texture
      } else {
        r.data.eleTxrCache.invalidateElement(ele);
      }
    }

    if (eles.length > 0) {
      r.data.lyrTxrCache.invalidateElements(eles);
    }
  });
}

CRp.redrawHint = function (group, bool) {
  var r = this;

  switch (group) {
    case 'eles':
      r.data.canvasNeedsRedraw[CRp.NODE] = bool;
      break;
    case 'drag':
      r.data.canvasNeedsRedraw[CRp.DRAG] = bool;
      break;
    case 'select':
      r.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;
      break;
  }
};

// whether to use Path2D caching for drawing
var pathsImpld = typeof Path2D !== 'undefined';

CRp.path2dEnabled = function (on) {
  if (on === undefined) {
    return this.pathsEnabled;
  }

  this.pathsEnabled = on ? true : false;
};

CRp.usePaths = function () {
  return pathsImpld && this.pathsEnabled;
};

[__webpack_require__(102), __webpack_require__(104), __webpack_require__(103), __webpack_require__(105), __webpack_require__(106), __webpack_require__(107), __webpack_require__(108), __webpack_require__(109), __webpack_require__(111), __webpack_require__(114)].forEach(function (props) {
  util.extend(CRp, props);
});

module.exports = CR;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var math = __webpack_require__(2);
var Heap = __webpack_require__(8);
var is = __webpack_require__(0);
var defs = __webpack_require__(16);

var defNumLayers = 1; // default number of layers to use
var minLvl = -4; // when scaling smaller than that we don't need to re-render
var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)
var maxZoom = 3.99; // beyond this zoom level, layered textures are not used
var deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
var refineEleDebounceTime = 50; // time to debounce sharper ele texture updates
var disableEleImgSmoothing = true; // when drawing eles on layers from an ele cache ; crisper and more performant when true
var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time
var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
var deqFastCost = 0.9; // % of frame time to be used when >60fps
var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch
var invalidThreshold = 250; // time threshold for disabling b/c of invalidations
var maxLayerArea = 4000 * 4000; // layers can't be bigger than this
var alwaysQueue = true; // never draw all the layers in a level on a frame; draw directly until all dequeued
var useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)

var useEleTxrCaching = true; // whether to use individual ele texture caching underneath this cache

// var log = function(){ console.log.apply( console, arguments ); };

var LayeredTextureCache = function LayeredTextureCache(renderer, eleTxrCache) {
  var self = this;

  var r = self.renderer = renderer;

  self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]

  self.firstGet = true;

  self.lastInvalidationTime = util.performanceNow() - 2 * invalidThreshold;

  self.skipping = false;

  r.beforeRender(function (willDraw, now) {
    if (now - self.lastInvalidationTime <= invalidThreshold) {
      self.skipping = true;
    } else {
      self.skipping = false;
    }
  });

  var qSort = function qSort(a, b) {
    return b.reqs - a.reqs;
  };

  self.layersQueue = new Heap(qSort);

  self.eleTxrCache = eleTxrCache;

  self.setupEleCacheInvalidation();

  self.setupDequeueing();
};

var LTCp = LayeredTextureCache.prototype;

var layerIdPool = 0;
var MAX_INT = Math.pow(2, 53) - 1;

LTCp.makeLayer = function (bb, lvl) {
  var scale = Math.pow(2, lvl);

  var w = Math.ceil(bb.w * scale);
  var h = Math.ceil(bb.h * scale);

  var canvas = document.createElement('canvas'); // eslint-disable-line no-undef

  canvas.width = w;
  canvas.height = h;

  var layer = {
    id: layerIdPool = ++layerIdPool % MAX_INT,
    bb: bb,
    level: lvl,
    width: w,
    height: h,
    canvas: canvas,
    context: canvas.getContext('2d'),
    eles: [],
    elesQueue: [],
    reqs: 0
  };

  // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);

  var cxt = layer.context;
  var dx = -layer.bb.x1;
  var dy = -layer.bb.y1;

  // do the transform on creation to save cycles (it's the same for all eles)
  cxt.scale(scale, scale);
  cxt.translate(dx, dy);

  return layer;
};

LTCp.getLayers = function (eles, pxRatio, lvl) {
  var self = this;
  var r = self.renderer;
  var cy = r.cy;
  var zoom = cy.zoom();
  var firstGet = self.firstGet;

  self.firstGet = false;

  // log('--\nget layers with %s eles', eles.length);
  //log eles.map(function(ele){ return ele.id() }) );

  if (lvl == null) {
    lvl = Math.ceil(math.log2(zoom * pxRatio));

    if (lvl < minLvl) {
      lvl = minLvl;
    } else if (zoom >= maxZoom || lvl > maxLvl) {
      return null;
    }
  }

  self.validateLayersElesOrdering(lvl, eles);

  var layersByLvl = self.layersByLevel;
  var scale = Math.pow(2, lvl);
  var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];
  var bb;

  var lvlComplete = self.levelIsComplete(lvl, eles);
  var tmpLayers;

  var checkTempLevels = function checkTempLevels() {
    var canUseAsTmpLvl = function canUseAsTmpLvl(l) {
      self.validateLayersElesOrdering(l, eles);

      if (self.levelIsComplete(l, eles)) {
        tmpLayers = layersByLvl[l];
        return true;
      }
    };

    var checkLvls = function checkLvls(dir) {
      if (tmpLayers) {
        return;
      }

      for (var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir) {
        if (canUseAsTmpLvl(l)) {
          break;
        }
      }
    };

    checkLvls(+1);
    checkLvls(-1);

    // remove the invalid layers; they will be replaced as needed later in this function
    for (var i = layers.length - 1; i >= 0; i--) {
      var layer = layers[i];

      if (layer.invalid) {
        util.removeFromArray(layers, layer);
      }
    }
  };

  if (!lvlComplete) {
    // if the current level is incomplete, then use the closest, best quality layerset temporarily
    // and later queue the current layerset so we can get the proper quality level soon

    checkTempLevels();
  } else {
    // log('level complete, using existing layers\n--');
    return layers;
  }

  var getBb = function getBb() {
    if (!bb) {
      bb = math.makeBoundingBox();

      for (var i = 0; i < eles.length; i++) {
        math.updateBoundingBox(bb, eles[i].boundingBox());
      }
    }

    return bb;
  };

  var makeLayer = function makeLayer(opts) {
    opts = opts || {};

    var after = opts.after;

    getBb();

    var area = bb.w * scale * (bb.h * scale);

    if (area > maxLayerArea) {
      return null;
    }

    var layer = self.makeLayer(bb, lvl);

    if (after != null) {
      var index = layers.indexOf(after) + 1;

      layers.splice(index, 0, layer);
    } else if (opts.insert === undefined || opts.insert) {
      // no after specified => first layer made so put at start
      layers.unshift(layer);
    }

    // if( tmpLayers ){
    //self.queueLayer( layer );
    // }

    return layer;
  };

  if (self.skipping && !firstGet) {
    // log('skip layers');
    return null;
  }

  // log('do layers');

  var layer = null;
  var maxElesPerLayer = eles.length / defNumLayers;
  var allowLazyQueueing = alwaysQueue && !firstGet;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

    // log('look at ele', ele.id());

    var existingLayer = caches[lvl];

    if (existingLayer) {
      // reuse layer for later eles
      // log('reuse layer for', ele.id());
      layer = existingLayer;
      continue;
    }

    if (!layer || layer.eles.length >= maxElesPerLayer || !math.boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {
      // log('make new layer for ele %s', ele.id());

      layer = makeLayer({ insert: true, after: layer });

      // if now layer can be built then we can't use layers at this level
      if (!layer) {
        return null;
      }

      // log('new layer with id %s', layer.id);
    }

    if (tmpLayers || allowLazyQueueing) {
      // log('queue ele %s in layer %s', ele.id(), layer.id);
      self.queueLayer(layer, ele);
    } else {
      // log('draw ele %s in layer %s', ele.id(), layer.id);
      self.drawEleInLayer(layer, ele, lvl, pxRatio);
    }

    layer.eles.push(ele);

    caches[lvl] = layer;
  }

  // log('--');

  if (tmpLayers) {
    // then we only queued the current layerset and can't draw it yet
    return tmpLayers;
  }

  if (allowLazyQueueing) {
    // log('lazy queue level', lvl);
    return null;
  }

  return layers;
};

// a layer may want to use an ele cache of a higher level to avoid blurriness
// so the layer level might not equal the ele level
LTCp.getEleLevelForLayerLevel = function (lvl, pxRatio) {
  return lvl;
};

function imgSmoothing(context, bool) {
  if (context.imageSmoothingEnabled != null) {
    context.imageSmoothingEnabled = bool;
  } else {
    context.webkitImageSmoothingEnabled = bool;
    context.mozImageSmoothingEnabled = bool;
    context.msImageSmoothingEnabled = bool;
  }
}

LTCp.drawEleInLayer = function (layer, ele, lvl, pxRatio) {
  var self = this;
  var r = this.renderer;
  var context = layer.context;
  var bb = ele.boundingBox();

  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
    return;
  }

  var eleCache = self.eleTxrCache;
  var reason = useHighQualityEleTxrReqs ? eleCache.reasons.highQuality : undefined;

  lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);

  var cache = useEleTxrCaching ? eleCache.getElement(ele, bb, null, lvl, reason) : null;

  if (cache) {
    if (disableEleImgSmoothing) {
      imgSmoothing(context, false);
    }

    context.drawImage(cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h);

    if (disableEleImgSmoothing) {
      imgSmoothing(context, true);
    }
  } else {
    // if the element is not cacheable, then draw directly
    r.drawElement(context, ele);
  }
};

LTCp.levelIsComplete = function (lvl, eles) {
  var self = this;
  var layers = self.layersByLevel[lvl];

  if (!layers || layers.length === 0) {
    return false;
  }

  var numElesInLayers = 0;

  for (var i = 0; i < layers.length; i++) {
    var layer = layers[i];

    // if there are any eles needed to be drawn yet, the level is not complete
    if (layer.reqs > 0) {
      return false;
    }

    // if the layer is invalid, the level is not complete
    if (layer.invalid) {
      return false;
    }

    numElesInLayers += layer.eles.length;
  }

  // we should have exactly the number of eles passed in to be complete
  if (numElesInLayers !== eles.length) {
    return false;
  }

  return true;
};

LTCp.validateLayersElesOrdering = function (lvl, eles) {
  var layers = this.layersByLevel[lvl];

  if (!layers) {
    return;
  }

  // if in a layer the eles are not in the same order, then the layer is invalid
  // (i.e. there is an ele in between the eles in the layer)

  for (var i = 0; i < layers.length; i++) {
    var layer = layers[i];
    var offset = -1;

    // find the offset
    for (var j = 0; j < eles.length; j++) {
      if (layer.eles[0] === eles[j]) {
        offset = j;
        break;
      }
    }

    if (offset < 0) {
      // then the layer has nonexistant elements and is invalid
      this.invalidateLayer(layer);
      continue;
    }

    // the eles in the layer must be in the same continuous order, else the layer is invalid

    var o = offset;

    for (var j = 0; j < layer.eles.length; j++) {
      if (layer.eles[j] !== eles[o + j]) {
        // log('invalidate based on ordering', layer.id);

        this.invalidateLayer(layer);
        break;
      }
    }
  }
};

LTCp.updateElementsInLayers = function (eles, update) {
  var self = this;
  var isEles = is.element(eles[0]);

  // collect udpated elements (cascaded from the layers) and update each
  // layer itself along the way
  for (var i = 0; i < eles.length; i++) {
    var req = isEles ? null : eles[i];
    var ele = isEles ? eles[i] : eles[i].ele;
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

    for (var l = minLvl; l <= maxLvl; l++) {
      var layer = caches[l];

      if (!layer) {
        continue;
      }

      // if update is a request from the ele cache, then it affects only
      // the matching level
      if (req && self.getEleLevelForLayerLevel(layer.level) !== req.level) {
        continue;
      }

      update(layer, ele, req);
    }
  }
};

LTCp.haveLayers = function () {
  var self = this;
  var haveLayers = false;

  for (var l = minLvl; l <= maxLvl; l++) {
    var layers = self.layersByLevel[l];

    if (layers && layers.length > 0) {
      haveLayers = true;
      break;
    }
  }

  return haveLayers;
};

LTCp.invalidateElements = function (eles) {
  var self = this;

  self.lastInvalidationTime = util.performanceNow();

  // log('update invalidate layer time from eles');

  if (eles.length === 0 || !self.haveLayers()) {
    return;
  }

  self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {
    self.invalidateLayer(layer);
  });
};

LTCp.invalidateLayer = function (layer) {
  // log('update invalidate layer time');

  this.lastInvalidationTime = util.performanceNow();

  if (layer.invalid) {
    return;
  } // save cycles

  var lvl = layer.level;
  var eles = layer.eles;
  var layers = this.layersByLevel[lvl];

  // log('invalidate layer', layer.id );

  util.removeFromArray(layers, layer);
  // layer.eles = [];

  layer.elesQueue = [];

  layer.invalid = true;

  if (layer.replacement) {
    layer.replacement.invalid = true;
  }

  for (var i = 0; i < eles.length; i++) {
    var caches = eles[i]._private.rscratch.imgLayerCaches;

    if (caches) {
      caches[lvl] = null;
    }
  }
};

LTCp.refineElementTextures = function (eles) {
  var self = this;

  // log('refine', eles.length);

  self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {
    var rLyr = layer.replacement;

    if (!rLyr) {
      rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);
      rLyr.replaces = layer;
      rLyr.eles = layer.eles;

      // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);
    }

    if (!rLyr.reqs) {
      for (var i = 0; i < rLyr.eles.length; i++) {
        self.queueLayer(rLyr, rLyr.eles[i]);
      }

      // log('queue replacement layer refinement', rLyr.id);
    }
  });
};

LTCp.setupEleCacheInvalidation = function () {
  var self = this;
  var eleDeqs = [];

  if (!useEleTxrCaching) {
    return;
  }

  var updatedElesInLayers = util.debounce(function () {
    self.refineElementTextures(eleDeqs);

    eleDeqs = [];
  }, refineEleDebounceTime);

  self.eleTxrCache.onDequeue(function (reqs) {
    for (var i = 0; i < reqs.length; i++) {
      eleDeqs.push(reqs[i]);
    }

    updatedElesInLayers();
  });
};

LTCp.queueLayer = function (layer, ele) {
  var self = this;
  var q = self.layersQueue;
  var elesQ = layer.elesQueue;
  var hasId = elesQ.hasId = elesQ.hasId || {};

  // if a layer is going to be replaced, queuing is a waste of time
  if (layer.replacement) {
    return;
  }

  if (ele) {
    if (hasId[ele.id()]) {
      return;
    }

    elesQ.push(ele);
    hasId[ele.id()] = true;
  }

  if (layer.reqs) {
    layer.reqs++;

    q.updateItem(layer);
  } else {
    layer.reqs = 1;

    q.push(layer);
  }
};

LTCp.dequeue = function (pxRatio) {
  var self = this;
  var q = self.layersQueue;
  var deqd = [];
  var eleDeqs = 0;

  while (eleDeqs < maxDeqSize) {
    if (q.size() === 0) {
      break;
    }

    var layer = q.peek();

    // if a layer has been or will be replaced, then don't waste time with it
    if (layer.replacement) {
      // log('layer %s in queue skipped b/c it already has a replacement', layer.id);
      q.pop();
      continue;
    }

    // if this is a replacement layer that has been superceded, then forget it
    if (layer.replaces && layer !== layer.replaces.replacement) {
      // log('layer is no longer the most uptodate replacement; dequeued', layer.id)
      q.pop();
      continue;
    }

    if (layer.invalid) {
      // log('replacement layer %s is invalid; dequeued', layer.id);
      q.pop();
      continue;
    }

    var ele = layer.elesQueue.shift();

    if (ele) {
      // log('dequeue layer %s', layer.id);

      self.drawEleInLayer(layer, ele, layer.level, pxRatio);

      eleDeqs++;
    }

    if (deqd.length === 0) {
      // we need only one entry in deqd to queue redrawing etc
      deqd.push(true);
    }

    // if the layer has all its eles done, then remove from the queue
    if (layer.elesQueue.length === 0) {
      q.pop();

      layer.reqs = 0;

      // log('dequeue of layer %s complete', layer.id);

      // when a replacement layer is dequeued, it replaces the old layer in the level
      if (layer.replaces) {
        self.applyLayerReplacement(layer);
      }

      self.requestRedraw();
    }
  }

  return deqd;
};

LTCp.applyLayerReplacement = function (layer) {
  var self = this;
  var layersInLevel = self.layersByLevel[layer.level];
  var replaced = layer.replaces;
  var index = layersInLevel.indexOf(replaced);

  // if the replaced layer is not in the active list for the level, then replacing
  // refs would be a mistake (i.e. overwriting the true active layer)
  if (index < 0 || replaced.invalid) {
    // log('replacement layer would have no effect', layer.id);
    return;
  }

  layersInLevel[index] = layer; // replace level ref

  // replace refs in eles
  for (var i = 0; i < layer.eles.length; i++) {
    var _p = layer.eles[i]._private;
    var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};

    if (cache) {
      cache[layer.level] = layer;
    }
  }

  // log('apply replacement layer %s over %s', layer.id, replaced.id);

  self.requestRedraw();
};

LTCp.requestRedraw = util.debounce(function () {
  var r = this.renderer;

  r.redrawHint('eles', true);
  r.redrawHint('drag', true);
  r.redraw();
}, 100);

LTCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold,
  deqCost: deqCost,
  deqAvgCost: deqAvgCost,
  deqNoDrawCost: deqNoDrawCost,
  deqFastCost: deqFastCost,
  deq: function deq(self, pxRatio) {
    return self.dequeue(pxRatio);
  },
  onDeqd: util.noop,
  shouldRedraw: util.trueify,
  priority: function priority(self) {
    return self.renderer.beforeRenderPriorities.lyrTxrDeq;
  }
});

module.exports = LayeredTextureCache;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CRp = {};

CRp.nodeShapeImpl = function (name, context, centerX, centerY, width, height, points) {
  switch (name) {
    case 'ellipse':
      return this.drawEllipsePath(context, centerX, centerY, width, height);
    case 'polygon':
      return this.drawPolygonPath(context, centerX, centerY, width, height, points);
    case 'roundrectangle':
      return this.drawRoundRectanglePath(context, centerX, centerY, width, height);
    case 'cutrectangle':
      return this.drawCutRectanglePath(context, centerX, centerY, width, height);
    case 'bottomroundrectangle':
      return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height);
    case 'barrel':
      return this.drawBarrelPath(context, centerX, centerY, width, height);
  }
};

module.exports = CRp;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [{ name: 'null', impl: __webpack_require__(116) }, { name: 'base', impl: __webpack_require__(98) }, { name: 'canvas', impl: __webpack_require__(112) }];

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function NullRenderer(options) {
  this.options = options;
  this.notifications = 0; // for testing
}

var noop = function noop() {};

NullRenderer.prototype = {
  recalculateRenderedStyle: noop,
  notify: function notify() {
    this.notifications++;
  },
  init: noop
};

module.exports = NullRenderer;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var Core = __webpack_require__(12);
var extension = __webpack_require__(21);
var Stylesheet = __webpack_require__(22);

var cytoscape = function cytoscape(options) {
  // jshint ignore:line
  // if no options specified, use default
  if (options === undefined) {
    options = {};
  }

  // create instance
  if (is.plainObject(options)) {
    return new Core(options);
  }

  // allow for registration of extensions
  else if (is.string(options)) {
      return extension.apply(extension, arguments);
    }
};

// e.g. cytoscape.use( require('cytoscape-foo'), bar )
cytoscape.use = function (ext) {
  var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext

  args.unshift(cytoscape); // cytoscape is first arg to ext

  ext.apply(null, args);

  return this;
};

// replaced by build system
cytoscape.version = __webpack_require__(23);

// expose public apis (mostly for extensions)
cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;

module.exports = cytoscape;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function ObjectMap() {
  this._obj = {};
}

var p = ObjectMap.prototype;

p.set = function (key, val) {
  this._obj[key] = val;
};

p.delete = function (key) {
  this._obj[key] = null;
};

p.has = function (key) {
  return this._obj[key] != null;
};

p.get = function (key) {
  return this._obj[key];
};

// TODO use the stdlib Map in future...
// module.exports = typeof Map !== 'undefined' ? Map : ObjectMap;
module.exports = ObjectMap;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _require = __webpack_require__(17),
    stateSelectorRegex = _require.stateSelectorRegex;

var tokens = __webpack_require__(122);
var util = __webpack_require__(1);
var newQuery = __webpack_require__(11);

// when a token like a variable has escaped meta characters, we need to clean the backslashes out
// so that values get compared properly in Selector.filter()
var cleanMetaChars = function cleanMetaChars(str) {
  return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function (match, $1) {
    return $1;
  });
};

var replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {
  if (examiningQuery === selector[selector.length - 1]) {
    selector[selector.length - 1] = replacementQuery;
  }
};

// NOTE: add new expression syntax here to have it recognised by the parser;
// - a query contains all adjacent (i.e. no separator in between) expressions;
// - the current query is stored in selector[i] --- you can use the reference to `this` in the populate function;
// - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward
// - when you add something here, also add to Selector.toString()
var exprs = [{
  name: 'group',
  query: true,
  regex: '(' + tokens.group + ')',
  populate: function populate(selector, query, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        group = _ref2[0];

    query.group = group === '*' ? group : group + 's';
  }
}, {
  name: 'state',
  query: true,
  regex: stateSelectorRegex,
  populate: function populate(selector, query, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 1),
        state = _ref4[0];

    query.colonSelectors.push(state);
  }
}, {
  name: 'id',
  query: true,
  regex: '\\#(' + tokens.id + ')',
  populate: function populate(selector, query, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
        id = _ref6[0];

    query.ids.push(cleanMetaChars(id));
  }
}, {
  name: 'className',
  query: true,
  regex: '\\.(' + tokens.className + ')',
  populate: function populate(selector, query, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
        className = _ref8[0];

    query.classes.push(cleanMetaChars(className));
  }
}, {
  name: 'dataExists',
  query: true,
  regex: '\\[\\s*(' + tokens.variable + ')\\s*\\]',
  populate: function populate(selector, query, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 1),
        variable = _ref10[0];

    query.data.push({
      field: cleanMetaChars(variable)
    });
  }
}, {
  name: 'dataCompare',
  query: true,
  regex: '\\[\\s*(' + tokens.variable + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.value + ')\\s*\\]',
  populate: function populate(selector, query, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 3),
        variable = _ref12[0],
        comparatorOp = _ref12[1],
        value = _ref12[2];

    var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;

    if (valueIsString) {
      value = value.substring(1, value.length - 1);
    } else {
      value = parseFloat(value);
    }

    query.data.push({
      field: cleanMetaChars(variable),
      operator: comparatorOp,
      value: value
    });
  }
}, {
  name: 'dataBool',
  query: true,
  regex: '\\[\\s*(' + tokens.boolOp + ')\\s*(' + tokens.variable + ')\\s*\\]',
  populate: function populate(selector, query, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 2),
        boolOp = _ref14[0],
        variable = _ref14[1];

    query.data.push({
      field: cleanMetaChars(variable),
      operator: boolOp
    });
  }
}, {
  name: 'metaCompare',
  query: true,
  regex: '\\[\\[\\s*(' + tokens.meta + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.number + ')\\s*\\]\\]',
  populate: function populate(selector, query, _ref15) {
    var _ref16 = _slicedToArray(_ref15, 3),
        meta = _ref16[0],
        comparatorOp = _ref16[1],
        number = _ref16[2];

    query.meta.push({
      field: cleanMetaChars(meta),
      operator: comparatorOp,
      value: parseFloat(number)
    });
  }
}, {
  name: 'nextQuery',
  separator: true,
  regex: tokens.separator,
  populate: function populate(selector) {
    // go on to next query
    var nextQuery = selector[selector.length++] = newQuery();
    selector.currentSubject = null;

    return nextQuery;
  }
}, {
  name: 'directedEdge',
  separator: true,
  regex: tokens.directedEdge,
  populate: function populate(selector, query) {
    var edgeQuery = newQuery();
    var source = query;
    var target = newQuery();

    edgeQuery.group = 'edges';
    edgeQuery.target = target;
    edgeQuery.source = source;
    edgeQuery.subject = selector.currentSubject;

    // the query in the selector should be the edge rather than the source
    replaceLastQuery(selector, query, edgeQuery);

    // we're now populating the target query with expressions that follow
    return target;
  }
}, {
  name: 'undirectedEdge',
  separator: true,
  regex: tokens.undirectedEdge,
  populate: function populate(selector, query) {
    var edgeQuery = newQuery();
    var source = query;
    var target = newQuery();

    edgeQuery.group = 'edges';
    edgeQuery.connectedNodes = [source, target];
    edgeQuery.subject = selector.currentSubject;

    // the query in the selector should be the edge rather than the source
    replaceLastQuery(selector, query, edgeQuery);

    // we're now populating the target query with expressions that follow
    return target;
  }
}, {
  name: 'child',
  separator: true,
  regex: tokens.child,
  populate: function populate(selector, query) {
    // this query is the parent of the following query
    var childQuery = newQuery();
    childQuery.parent = query;
    childQuery.subject = selector.currentSubject;

    // it's cheaper to compare children first and go up so replace the parent
    replaceLastQuery(selector, query, childQuery);

    // we're now populating the child query with expressions that follow
    return childQuery;
  }
}, {
  name: 'descendant',
  separator: true,
  regex: tokens.descendant,
  populate: function populate(selector, query) {
    // this query is the ancestor of the following query
    var descendantQuery = newQuery();
    descendantQuery.ancestor = query;
    descendantQuery.subject = selector.currentSubject;

    // it's cheaper to compare descendants first and go up so replace the ancestor
    replaceLastQuery(selector, query, descendantQuery);

    // we're now populating the descendant query with expressions that follow
    return descendantQuery;
  }
}, {
  name: 'subject',
  modifier: true,
  regex: tokens.subject,
  populate: function populate(selector, query) {
    if (selector.currentSubject != null && query.subject != query) {
      util.error('Redefinition of subject in selector `' + selector.toString() + '`');
      return false;
    }

    selector.currentSubject = query;
    query.subject = query;
    selector[selector.length - 1].subject = query;
  }
}];

exprs.forEach(function (e) {
  return e.regexObj = new RegExp('^' + e.regex);
});

module.exports = exprs;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _require = __webpack_require__(17),
    stateSelectorMatches = _require.stateSelectorMatches;

var is = __webpack_require__(0);

// generic checking for data/metadata
var operandsMatch = function operandsMatch(query, params) {
  var allDataMatches = true;
  for (var k = 0; k < query[params.name].length; k++) {
    var data = query[params.name][k];
    var operator = data.operator;
    var value = data.value;
    var field = data.field;
    var _matches = void 0;
    var fieldVal = params.fieldValue(field);

    if (operator != null && value != null) {
      var fieldStr = !is.string(fieldVal) && !is.number(fieldVal) ? '' : '' + fieldVal;
      var valStr = '' + value;

      var caseInsensitive = false;
      if (operator.indexOf('@') >= 0) {
        fieldStr = fieldStr.toLowerCase();
        valStr = valStr.toLowerCase();

        operator = operator.replace('@', '');
        caseInsensitive = true;
      }

      var notExpr = false;
      if (operator.indexOf('!') >= 0) {
        operator = operator.replace('!', '');
        notExpr = true;
      }

      // if we're doing a case insensitive comparison, then we're using a STRING comparison
      // even if we're comparing numbers
      if (caseInsensitive) {
        value = valStr.toLowerCase();
        fieldVal = fieldStr.toLowerCase();
      }

      var isIneqCmp = false;

      switch (operator) {
        case '*=':
          _matches = fieldStr.indexOf(valStr) >= 0;
          break;
        case '$=':
          _matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;
          break;
        case '^=':
          _matches = fieldStr.indexOf(valStr) === 0;
          break;
        case '=':
          _matches = fieldVal === value;
          break;
        case '>':
          isIneqCmp = true;
          _matches = fieldVal > value;
          break;
        case '>=':
          isIneqCmp = true;
          _matches = fieldVal >= value;
          break;
        case '<':
          isIneqCmp = true;
          _matches = fieldVal < value;
          break;
        case '<=':
          isIneqCmp = true;
          _matches = fieldVal <= value;
          break;
        default:
          _matches = false;
          break;
      }

      // apply the not op, but null vals for inequalities should always stay non-matching
      if (notExpr && (fieldVal != null || !isIneqCmp)) {
        _matches = !_matches;
      }
    } else if (operator != null) {
      switch (operator) {
        case '?':
          _matches = fieldVal ? true : false;
          break;
        case '!':
          _matches = fieldVal ? false : true;
          break;
        case '^':
          _matches = fieldVal === undefined;
          break;
      }
    } else {
      _matches = fieldVal !== undefined;
    }

    if (!_matches) {
      allDataMatches = false;
      break;
    }
  } // for

  return allDataMatches;
}; // operandsMatch

// check parent/child relations
var confirmRelations = function confirmRelations(query, isNecessary, eles) {
  if (query != null) {
    var _matches2 = false;

    if (!isNecessary) {
      return false;
    }

    eles = eles(); // save cycles if query == null

    // query must match for at least one element (may be recursive)
    for (var i = 0; i < eles.length; i++) {
      if (queryMatches(query, eles[i])) {
        _matches2 = true;
        break;
      }
    }

    return _matches2;
  } else {
    return true;
  }
};

var queryMatches = function queryMatches(query, ele) {
  // make single group-only selectors really cheap to check since they're the most common ones
  if (query.groupOnly) {
    return query.group === '*' || query.group === ele.group();
  }

  // check group
  if (query.group != null && query.group != '*' && query.group != ele.group()) {
    return false;
  }

  var cy = ele.cy();
  var k = void 0;

  // check colon selectors
  var allColonSelectorsMatch = true;
  for (k = 0; k < query.colonSelectors.length; k++) {
    var sel = query.colonSelectors[k];

    allColonSelectorsMatch = stateSelectorMatches(sel, ele);

    if (!allColonSelectorsMatch) break;
  }
  if (!allColonSelectorsMatch) return false;

  // check id
  var allIdsMatch = true;
  for (k = 0; k < query.ids.length; k++) {
    var id = query.ids[k];
    var actualId = ele.id();

    allIdsMatch = allIdsMatch && id == actualId;

    if (!allIdsMatch) break;
  }
  if (!allIdsMatch) return false;

  // check classes
  var allClassesMatch = true;
  for (k = 0; k < query.classes.length; k++) {
    var cls = query.classes[k];

    allClassesMatch = allClassesMatch && ele.hasClass(cls);

    if (!allClassesMatch) break;
  }
  if (!allClassesMatch) return false;

  // check data matches
  var allDataMatches = operandsMatch(query, {
    name: 'data',
    fieldValue: function fieldValue(field) {
      return ele.data(field);
    }
  });

  if (!allDataMatches) {
    return false;
  }

  // check metadata matches
  var allMetaMatches = operandsMatch(query, {
    name: 'meta',
    fieldValue: function fieldValue(field) {
      return ele[field]();
    }
  });

  if (!allMetaMatches) {
    return false;
  }

  // check collection
  if (query.collection != null) {
    var matchesAny = query.collection.hasElementWithId(ele.id());

    if (!matchesAny) {
      return false;
    }
  }

  // check filter function
  if (query.filter != null && ele.collection().some(query.filter)) {
    return false;
  }

  var isCompound = cy.hasCompoundNodes();
  var getSource = function getSource() {
    return ele.source();
  };
  var getTarget = function getTarget() {
    return ele.target();
  };

  if (!confirmRelations(query.parent, isCompound, function () {
    return ele.parent();
  })) {
    return false;
  }

  if (!confirmRelations(query.ancestor, isCompound, function () {
    return ele.parents();
  })) {
    return false;
  }

  if (!confirmRelations(query.child, isCompound, function () {
    return ele.children();
  })) {
    return false;
  }

  if (!confirmRelations(query.descendant, isCompound, function () {
    return ele.descendants();
  })) {
    return false;
  }

  if (!confirmRelations(query.source, true, getSource)) {
    return false;
  }

  if (!confirmRelations(query.target, true, getTarget)) {
    return false;
  }

  if (query.connectedNodes) {
    var q0 = query.connectedNodes[0];
    var q1 = query.connectedNodes[1];

    if (confirmRelations(q0, true, getSource) && confirmRelations(q1, true, getTarget)) {
      // match
    } else if (confirmRelations(q0, true, getTarget) && confirmRelations(q1, true, getSource)) {
      // match
    } else {
      return false;
    }
  }

  // we've reached the end, so we've matched everything for this query
  return true;
}; // queryMatches

// filter an existing collection
var filter = function filter(collection) {
  var self = this;
  var cy = collection.cy();

  // don't bother trying if it's invalid
  if (self.invalid()) {
    return cy.collection();
  }

  // for 1 id #foo queries, just get the element
  if (self.length === 1 && self[0].length === 1 && self[0].ids.length === 1) {
    return collection.getElementById(self[0].ids[0]).collection();
  }

  var selectorFunction = function selectorFunction(element) {
    for (var j = 0; j < self.length; j++) {
      var query = self[j];

      if (queryMatches(query, element)) {
        return true;
      }
    }

    return false;
  };

  if (self.text() == null) {
    selectorFunction = function selectorFunction() {
      return true;
    };
  }

  var filteredCollection = collection.filter(selectorFunction);

  return filteredCollection;
}; // filter

// does selector match a single element?
var matches = function matches(ele) {
  var self = this;

  // don't bother trying if it's invalid
  if (self.invalid()) {
    return false;
  }

  for (var j = 0; j < self.length; j++) {
    var query = self[j];

    if (queryMatches(query, ele)) {
      return true;
    }
  }

  return false;
}; // filter

module.exports = { matches: matches, filter: filter };

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var exprs = __webpack_require__(119);
var newQuery = __webpack_require__(11);

// of all the expressions, find the first match in the remaining text
var consumeExpr = function consumeExpr(remaining) {
  var expr = void 0;
  var match = void 0;
  var name = void 0;

  for (var j = 0; j < exprs.length; j++) {
    var e = exprs[j];
    var n = e.name;

    var m = remaining.match(e.regexObj);

    if (m != null) {
      match = m;
      expr = e;
      name = n;

      var consumed = m[0];
      remaining = remaining.substring(consumed.length);

      break; // we've consumed one expr, so we can return now
    }
  }

  return {
    expr: expr,
    match: match,
    name: name,
    remaining: remaining
  };
};

// consume all leading whitespace
var consumeWhitespace = function consumeWhitespace(remaining) {
  var match = remaining.match(/^\s+/);

  if (match) {
    var consumed = match[0];
    remaining = remaining.substring(consumed.length);
  }

  return remaining;
};

var parse = function parse(selector) {
  var self = this;

  var remaining = self._private.selectorText = selector;

  var currentQuery = self[0] = newQuery();
  self.length = 1;

  remaining = consumeWhitespace(remaining); // get rid of leading whitespace

  for (;;) {
    var check = consumeExpr(remaining);

    if (check.expr == null) {
      util.error('The selector `' + selector + '`is invalid');
      return false;
    } else {
      var args = check.match.slice(1);

      // let the token populate the selector object in currentQuery
      var ret = check.expr.populate(self, currentQuery, args);

      if (ret === false) {
        return false; // exit if population failed
      } else if (ret != null) {
        currentQuery = ret; // change the current query to be filled if the expr specifies
      }
    }

    remaining = check.remaining;

    // we're done when there's nothing left to parse
    if (remaining.match(/^\s*$/)) {
      break;
    }
  }

  // adjust references for subject
  for (var j = 0; j < self.length; j++) {
    var query = self[j];

    if (query.subject != null) {
      // go up the tree until we reach the subject
      for (;;) {
        if (query.subject === query) {
          break;
        } // done if subject is self

        if (query.parent != null) {
          // swap parent/child reference
          var parent = query.parent;
          var child = query;

          child.parent = null;
          parent.child = child;

          query = parent; // go up the tree
        } else if (query.ancestor != null) {
          // swap ancestor/descendant
          var ancestor = query.ancestor;
          var descendant = query;

          descendant.ancestor = null;
          ancestor.descendant = descendant;

          query = ancestor; // go up the tree
        } else if (query.source || query.target || query.connectedNodes) {
          util.error('The selector `' + self.text() + '` can not contain a subject selector that applies to the source or target of an edge selector');
          return false;
        } else {
          util.error('When adjusting references for the selector `' + self.text() + '`, neither parent nor ancestor was found');
          return false;
        }
      } // for

      self[j] = query.subject; // subject should be the root query
    } // if
  } // for

  return true; // success
};

module.exports = { parse: parse };

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

// tokens in the query language
var tokens = {
  metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]', // chars we need to escape in let names, etc
  comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=', // binary comparison op (used in data selectors)
  boolOp: '\\?|\\!|\\^', // boolean (unary) operators (used in data selectors)
  string: '"(?:\\\\"|[^"])*"' + '|' + "'(?:\\\\'|[^'])*'", // string literals (used in data selectors) -- doublequotes | singlequotes
  number: util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
  meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from Collection)
  separator: '\\s*,\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
  descendant: '\\s+',
  child: '\\s+>\\s+',
  subject: '\\$',
  group: 'node|edge|\\*',
  directedEdge: '\\s+->\\s+',
  undirectedEdge: '\\s+<->\\s+'
};
tokens.variable = '(?:[\\w-]|(?:\\\\' + tokens.metaChar + '))+'; // a variable name
tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number
tokens.className = tokens.variable; // a class name (follows variable conventions)
tokens.id = tokens.variable; // an element id (follows variable conventions)

(function () {
  var ops = void 0,
      op = void 0,
      i = void 0;

  // add @ variants to comparatorOp
  ops = tokens.comparatorOp.split('|');
  for (i = 0; i < ops.length; i++) {
    op = ops[i];
    tokens.comparatorOp += '|@' + op;
  }

  // add ! variants to comparatorOp
  ops = tokens.comparatorOp.split('|');
  for (i = 0; i < ops.length; i++) {
    op = ops[i];

    if (op.indexOf('!') >= 0) {
      continue;
    } // skip ops that explicitly contain !
    if (op === '=') {
      continue;
    } // skip = b/c != is explicitly defined

    tokens.comparatorOp += '|\\!' + op;
  }
})();

module.exports = tokens;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);
var Promise = __webpack_require__(5);

var styfn = {};

// (potentially expensive calculation)
// apply the style to the element based on
// - its bypass
// - what selectors match it
styfn.apply = function (eles) {
  var self = this;
  var _p = self._private;
  var cy = _p.cy;
  var updatedEles = cy.collection();

  if (_p.newStyle) {
    // clear style caches
    _p.contextStyles = {};
    _p.propDiffs = {};

    self.cleanElements(eles, true);
  }

  for (var ie = 0; ie < eles.length; ie++) {
    var ele = eles[ie];

    var cxtMeta = self.getContextMeta(ele);

    if (cxtMeta.empty) {
      continue;
    } else {
      updatedEles.merge(ele);
    }

    var cxtStyle = self.getContextStyle(cxtMeta);
    var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);

    if (!_p.newStyle) {
      self.updateTransitions(ele, app.diffProps);
    }

    self.updateStyleHints(ele);
  } // for elements

  _p.newStyle = false;

  return updatedEles;
};

styfn.getPropertiesDiff = function (oldCxtKey, newCxtKey) {
  var self = this;
  var cache = self._private.propDiffs = self._private.propDiffs || {};
  var dualCxtKey = oldCxtKey + '-' + newCxtKey;
  var cachedVal = cache[dualCxtKey];

  if (cachedVal) {
    return cachedVal;
  }

  var diffProps = [];
  var addedProp = {};

  for (var i = 0; i < self.length; i++) {
    var cxt = self[i];
    var oldHasCxt = oldCxtKey[i] === 't';
    var newHasCxt = newCxtKey[i] === 't';
    var cxtHasDiffed = oldHasCxt !== newHasCxt;
    var cxtHasMappedProps = cxt.mappedProperties.length > 0;

    if (cxtHasDiffed || cxtHasMappedProps) {
      var props = void 0;

      if (cxtHasDiffed && cxtHasMappedProps) {
        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
      } else if (cxtHasDiffed) {
        props = cxt.properties; // need to check them all
      } else if (cxtHasMappedProps) {
        props = cxt.mappedProperties; // only need to check mapped
      }

      for (var j = 0; j < props.length; j++) {
        var prop = props[j];
        var name = prop.name;

        // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
        // is cached)
        var laterCxtOverrides = false;
        for (var k = i + 1; k < self.length; k++) {
          var laterCxt = self[k];
          var hasLaterCxt = newCxtKey[k] === 't';

          if (!hasLaterCxt) {
            continue;
          } // can't override unless the context is active

          laterCxtOverrides = laterCxt.properties[prop.name] != null;

          if (laterCxtOverrides) {
            break;
          } // exit early as long as one later context overrides
        }

        if (!addedProp[name] && !laterCxtOverrides) {
          addedProp[name] = true;
          diffProps.push(name);
        }
      } // for props
    } // if
  } // for contexts

  cache[dualCxtKey] = diffProps;
  return diffProps;
};

styfn.getContextMeta = function (ele) {
  var self = this;
  var cxtKey = '';
  var diffProps = void 0;
  var prevKey = ele._private.styleCxtKey || '';

  if (self._private.newStyle) {
    prevKey = ''; // since we need to apply all style if a fresh stylesheet
  }

  // get the cxt key
  for (var i = 0; i < self.length; i++) {
    var context = self[i];
    var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'

    if (contextSelectorMatches) {
      cxtKey += 't';
    } else {
      cxtKey += 'f';
    }
  } // for context

  diffProps = self.getPropertiesDiff(prevKey, cxtKey);

  ele._private.styleCxtKey = cxtKey;

  return {
    key: cxtKey,
    diffPropNames: diffProps,
    empty: diffProps.length === 0
  };
};

// gets a computed ele style object based on matched contexts
styfn.getContextStyle = function (cxtMeta) {
  var cxtKey = cxtMeta.key;
  var self = this;
  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};

  // if already computed style, returned cached copy
  if (cxtStyles[cxtKey]) {
    return cxtStyles[cxtKey];
  }

  var style = {
    _private: {
      key: cxtKey
    }
  };

  for (var i = 0; i < self.length; i++) {
    var cxt = self[i];
    var hasCxt = cxtKey[i] === 't';

    if (!hasCxt) {
      continue;
    }

    for (var j = 0; j < cxt.properties.length; j++) {
      var prop = cxt.properties[j];

      style[prop.name] = prop;
    }
  }

  cxtStyles[cxtKey] = style;
  return style;
};

styfn.applyContextStyle = function (cxtMeta, cxtStyle, ele) {
  var self = this;
  var diffProps = cxtMeta.diffPropNames;
  var retDiffProps = {};

  for (var i = 0; i < diffProps.length; i++) {
    var diffPropName = diffProps[i];
    var cxtProp = cxtStyle[diffPropName];
    var eleProp = ele.pstyle(diffPropName);

    if (!cxtProp) {
      // no context prop means delete
      if (!eleProp) {
        continue; // no existing prop means nothing needs to be removed
        // nb affects initial application on mapped values like control-point-distances
      } else if (eleProp.bypass) {
        cxtProp = { name: diffPropName, deleteBypassed: true };
      } else {
        cxtProp = { name: diffPropName, delete: true };
      }
    }

    // save cycles when the context prop doesn't need to be applied
    if (eleProp === cxtProp) {
      continue;
    }

    var retDiffProp = retDiffProps[diffPropName] = {
      prev: eleProp
    };

    self.applyParsedProperty(ele, cxtProp);

    retDiffProp.next = ele.pstyle(diffPropName);

    if (retDiffProp.next && retDiffProp.next.bypass) {
      retDiffProp.next = retDiffProp.next.bypassed;
    }
  }

  return {
    diffProps: retDiffProps
  };
};

styfn.updateStyleHints = function (ele) {
  var _p = ele._private;
  var self = this;

  if (ele.removed()) {
    return;
  }

  // set whether has pie or not; for greater efficiency
  var hasPie = false;
  if (_p.group === 'nodes') {
    for (var i = 1; i <= self.pieBackgroundN; i++) {
      // 1..N
      var _size = ele.pstyle('pie-' + i + '-background-size').value;

      if (_size > 0) {
        hasPie = true;
        break;
      }
    }
  }

  _p.hasPie = hasPie;

  var transform = ele.pstyle('text-transform').strValue;
  var content = ele.pstyle('label').strValue;
  var srcContent = ele.pstyle('source-label').strValue;
  var tgtContent = ele.pstyle('target-label').strValue;
  var fStyle = ele.pstyle('font-style').strValue;
  var size = ele.pstyle('font-size').pfValue + 'px';
  var family = ele.pstyle('font-family').strValue;
  // let letiant = style['font-letiant'].strValue;
  var weight = ele.pstyle('font-weight').strValue;
  var valign = ele.pstyle('text-valign').strValue;
  var halign = ele.pstyle('text-valign').strValue;
  var oWidth = ele.pstyle('text-outline-width').pfValue;
  var wrap = ele.pstyle('text-wrap').strValue;
  var wrapW = ele.pstyle('text-max-width').pfValue;
  var labelStyleKey = fStyle + '$' + size + '$' + family + '$' + weight + '$' + transform + '$' + valign + '$' + halign + '$' + oWidth + '$' + wrap + '$' + wrapW;
  _p.labelStyleKey = labelStyleKey;
  _p.sourceLabelKey = labelStyleKey + '$' + srcContent;
  _p.targetLabelKey = labelStyleKey + '$' + tgtContent;
  _p.labelKey = labelStyleKey + '$' + content;
  _p.fontKey = fStyle + '$' + weight + '$' + size + '$' + family;

  _p.styleKey = Date.now();
};

// apply a property to the style (for internal use)
// returns whether application was successful
//
// now, this function flattens the property, and here's how:
//
// for parsedProp:{ bypass: true, deleteBypass: true }
// no property is generated, instead the bypass property in the
// element's style is replaced by what's pointed to by the `bypassed`
// field in the bypass property (i.e. restoring the property the
// bypass was overriding)
//
// for parsedProp:{ mapped: truthy }
// the generated flattenedProp:{ mapping: prop }
//
// for parsedProp:{ bypass: true }
// the generated flattenedProp:{ bypassed: parsedProp }
styfn.applyParsedProperty = function (ele, parsedProp) {
  var self = this;
  var prop = parsedProp;
  var style = ele._private.style;
  var fieldVal = void 0,
      flatProp = void 0;
  var types = self.types;
  var type = self.properties[prop.name].type;
  var propIsBypass = prop.bypass;
  var origProp = style[prop.name];
  var origPropIsBypass = origProp && origProp.bypass;
  var _p = ele._private;
  var flatPropMapping = 'mapping';

  var checkZOrder = function checkZOrder() {
    self.checkZOrderTrigger(ele, prop.name, origProp ? origProp.value : null, prop.value);
  };

  // edges connected to compound nodes can not be haystacks
  if (parsedProp.name === 'curve-style' && parsedProp.value === 'haystack' && ele.isEdge() && (ele.isLoop() || ele.source().isParent() || ele.target().isParent())) {
    prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);
  }

  if (prop.delete) {
    // delete the property and use the default value on falsey value
    style[prop.name] = undefined;

    checkZOrder();

    return true;
  }

  if (prop.deleteBypassed) {
    // delete the property that the
    if (!origProp) {
      checkZOrder();

      return true; // can't delete if no prop
    } else if (origProp.bypass) {
      // delete bypassed
      origProp.bypassed = undefined;

      checkZOrder();

      return true;
    } else {
      return false; // we're unsuccessful deleting the bypassed
    }
  }

  // check if we need to delete the current bypass
  if (prop.deleteBypass) {
    // then this property is just here to indicate we need to delete
    if (!origProp) {
      checkZOrder();

      return true; // property is already not defined
    } else if (origProp.bypass) {
      // then replace the bypass property with the original
      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
      style[prop.name] = origProp.bypassed;

      checkZOrder();

      return true;
    } else {
      return false; // we're unsuccessful deleting the bypass
    }
  }

  var printMappingErr = function printMappingErr() {
    util.error('Do not assign mappings to elements without corresponding data (e.g. ele `' + ele.id() + '` for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');
  };

  // put the property in the style objects
  switch (prop.mapped) {// flatten the property if mapped
    case types.mapData:
      {
        // flatten the field (e.g. data.foo.bar)
        var fields = prop.field.split('.');
        var _fieldVal = _p.data;

        for (var i = 0; i < fields.length && _fieldVal; i++) {
          var field = fields[i];
          _fieldVal = _fieldVal[field];
        }

        var percent = void 0;
        if (!is.number(_fieldVal)) {
          // then keep the mapping but assume 0% for now
          percent = 0;
        } else {
          percent = (_fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);
        }

        // make sure to bound percent value
        if (percent < 0) {
          percent = 0;
        } else if (percent > 1) {
          percent = 1;
        }

        if (type.color) {
          var r1 = prop.valueMin[0];
          var r2 = prop.valueMax[0];
          var g1 = prop.valueMin[1];
          var g2 = prop.valueMax[1];
          var b1 = prop.valueMin[2];
          var b2 = prop.valueMax[2];
          var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
          var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];

          var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];

          flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing
            bypass: prop.bypass, // we're a bypass if the mapping property is a bypass
            name: prop.name,
            value: clr,
            strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
          };
        } else if (type.number) {
          var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
          flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);
        } else {
          return false; // can only map to colours and numbers
        }

        if (!flatProp) {
          // if we can't flatten the property, then use the origProp so we still keep the mapping itself
          flatProp = this.parse(prop.name, origProp.strValue, prop.bypass, flatPropMapping);
        }

        if (!flatProp) {
          printMappingErr();
        }
        flatProp.mapping = prop; // keep a reference to the mapping
        prop = flatProp; // the flattened (mapped) property is the one we want

        break;
      }

    // direct mapping
    case types.data:
      {
        // flatten the field (e.g. data.foo.bar)
        var _fields = prop.field.split('.');
        var _fieldVal2 = _p.data;

        if (_fieldVal2) {
          for (var _i = 0; _i < _fields.length; _i++) {
            var _field = _fields[_i];
            _fieldVal2 = _fieldVal2[_field];
          }
        }

        flatProp = this.parse(prop.name, _fieldVal2, prop.bypass, flatPropMapping);

        if (!flatProp) {
          // if we can't flatten the property, then use the origProp so we still keep the mapping itself
          var flatPropVal = origProp ? origProp.strValue : '';

          flatProp = this.parse(prop.name, flatPropVal, prop.bypass, flatPropMapping);
        }

        if (!flatProp) {
          printMappingErr();
        }
        flatProp.mapping = prop; // keep a reference to the mapping
        prop = flatProp; // the flattened (mapped) property is the one we want

        break;
      }

    case types.fn:
      {
        var fn = prop.value;
        var fnRetVal = fn(ele);

        flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);
        flatProp.mapping = prop; // keep a reference to the mapping
        prop = flatProp; // the flattened (mapped) property is the one we want

        break;
      }

    case undefined:
      break; // just set the property

    default:
      return false; // not a valid mapping
  }

  // if the property is a bypass property, then link the resultant property to the original one
  if (propIsBypass) {
    if (origPropIsBypass) {
      // then this bypass overrides the existing one
      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
    } else {
      // then link the orig prop to the new bypass
      prop.bypassed = origProp;
    }

    style[prop.name] = prop; // and set
  } else {
    // prop is not bypass
    if (origPropIsBypass) {
      // then keep the orig prop (since it's a bypass) and link to the new prop
      origProp.bypassed = prop;
    } else {
      // then just replace the old prop with the new one
      style[prop.name] = prop;
    }
  }

  checkZOrder();

  return true;
};

styfn.cleanElements = function (eles, keepBypasses) {
  var self = this;
  var props = self.properties;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (!keepBypasses) {
      ele._private.style = {};
    } else {
      var style = ele._private.style;

      for (var j = 0; j < props.length; j++) {
        var prop = props[j];
        var eleProp = style[prop.name];

        if (eleProp) {
          if (eleProp.bypass) {
            eleProp.bypassed = null;
          } else {
            style[prop.name] = null;
          }
        }
      }
    }
  }
};

// updates the visual style for all elements (useful for manual style modification after init)
styfn.update = function () {
  var cy = this._private.cy;
  var eles = cy.mutableElements();

  eles.updateStyle();
};

// just update the functional properties (i.e. mappings) in the elements'
// styles (less expensive than recalculation)
styfn.updateMappers = function (eles) {
  var self = this;
  var cy = this._private.cy;
  var updatedEles = cy.collection();

  for (var i = 0; i < eles.length; i++) {
    // for each ele
    var ele = eles[i];
    var style = ele._private.style;
    var updatedEle = false;

    for (var j = 0; j < self.properties.length; j++) {
      // for each prop
      var prop = self.properties[j];
      var propInStyle = style[prop.name];

      if (propInStyle && propInStyle.mapping) {
        var mapping = propInStyle.mapping;

        this.applyParsedProperty(ele, mapping); // reapply the mapping property

        updatedEle = true;
      }
    }

    if (updatedEle) {
      this.updateStyleHints(ele);

      updatedEles.merge(ele);
    }
  }

  return updatedEles;
};

// diffProps : { name => { prev, next } }
styfn.updateTransitions = function (ele, diffProps, isBypass) {
  var self = this;
  var _p = ele._private;
  var props = ele.pstyle('transition-property').value;
  var duration = ele.pstyle('transition-duration').pfValue;
  var delay = ele.pstyle('transition-delay').pfValue;

  if (props.length > 0 && duration > 0) {

    var style = {};

    // build up the style to animate towards
    var anyPrev = false;
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      var styProp = ele.pstyle(prop);
      var diffProp = diffProps[prop];

      if (!diffProp) {
        continue;
      }

      var prevProp = diffProp.prev;
      var fromProp = prevProp;
      var toProp = diffProp.next != null ? diffProp.next : styProp;
      var diff = false;
      var initVal = void 0;
      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)

      if (!fromProp) {
        continue;
      }

      // consider px values
      if (is.number(fromProp.pfValue) && is.number(toProp.pfValue)) {
        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy
        initVal = fromProp.pfValue + initDt * diff;

        // consider numerical values
      } else if (is.number(fromProp.value) && is.number(toProp.value)) {
        diff = toProp.value - fromProp.value; // nonzero is truthy
        initVal = fromProp.value + initDt * diff;

        // consider colour values
      } else if (is.array(fromProp.value) && is.array(toProp.value)) {
        diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];

        initVal = fromProp.strValue;
      }

      // the previous value is good for an animation only if it's different
      if (diff) {
        style[prop] = toProp.strValue; // to val
        this.applyBypass(ele, prop, initVal); // from val
        anyPrev = true;
      }
    } // end if props allow ani

    // can't transition if there's nothing previous to transition from
    if (!anyPrev) {
      return;
    }

    _p.transitioning = true;

    new Promise(function (resolve) {
      if (delay > 0) {
        ele.delayAnimation(delay).play().promise().then(resolve);
      } else {
        resolve();
      }
    }).then(function () {
      return ele.animation({
        style: style,
        duration: duration,
        easing: ele.pstyle('transition-timing-function').value,
        queue: false
      }).play().promise();
    }).then(function () {
      // if( !isBypass ){
      self.removeBypasses(ele, props);
      ele.emitAndNotify('style');
      // }

      _p.transitioning = false;
    });
  } else if (_p.transitioning) {
    this.removeBypasses(ele, props);
    ele.emitAndNotify('style');

    _p.transitioning = false;
  }
};

styfn.checkZOrderTrigger = function (ele, name, fromValue, toValue) {
  var prop = this.properties[name];

  if (prop.triggersZOrder != null && (fromValue == null || prop.triggersZOrder(fromValue, toValue))) {
    this._private.cy.notify({
      type: 'zorder',
      eles: ele
    });
  }
};

module.exports = styfn;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);

var styfn = {};

// bypasses are applied to an existing style on an element, and just tacked on temporarily
// returns true iff application was successful for at least 1 specified property
styfn.applyBypass = function (eles, name, value, updateTransitions) {
  var self = this;
  var props = [];
  var isBypass = true;

  // put all the properties (can specify one or many) in an array after parsing them
  if (name === '*' || name === '**') {
    // apply to all property names

    if (value !== undefined) {
      for (var i = 0; i < self.properties.length; i++) {
        var prop = self.properties[i];
        var _name = prop.name;

        var parsedProp = this.parse(_name, value, true);

        if (parsedProp) {
          props.push(parsedProp);
        }
      }
    }
  } else if (is.string(name)) {
    // then parse the single property
    var _parsedProp = this.parse(name, value, true);

    if (_parsedProp) {
      props.push(_parsedProp);
    }
  } else if (is.plainObject(name)) {
    // then parse each property
    var specifiedProps = name;
    updateTransitions = value;

    var names = Object.keys(specifiedProps);

    for (var _i = 0; _i < names.length; _i++) {
      var _name2 = names[_i];
      var _prop = self.properties[_name2];
      var _value = specifiedProps[_name2];

      if (_value === undefined) {
        // try camel case name too
        _value = specifiedProps[util.dash2camel(_name2)];
      }

      if (_value !== undefined) {
        var _parsedProp2 = this.parse(_name2, _value, true);

        if (_parsedProp2) {
          props.push(_parsedProp2);
        }
      }
    }
  } else {
    // can't do anything without well defined properties
    return false;
  }

  // we've failed if there are no valid properties
  if (props.length === 0) {
    return false;
  }

  // now, apply the bypass properties on the elements
  var ret = false; // return true if at least one succesful bypass applied
  for (var _i2 = 0; _i2 < eles.length; _i2++) {
    // for each ele
    var ele = eles[_i2];
    var diffProps = {};
    var diffProp = void 0;

    for (var j = 0; j < props.length; j++) {
      // for each prop
      var _prop2 = props[j];

      if (updateTransitions) {
        var prevProp = ele.pstyle(_prop2.name);
        diffProp = diffProps[_prop2.name] = { prev: prevProp };
      }

      ret = this.applyParsedProperty(ele, _prop2) || ret;

      if (updateTransitions) {
        diffProp.next = ele.pstyle(_prop2.name);
      }
    } // for props

    if (ret) {
      this.updateStyleHints(ele);
    }

    if (updateTransitions) {
      this.updateTransitions(ele, diffProps, isBypass);
    }
  } // for eles

  return ret;
};

// only useful in specific cases like animation
styfn.overrideBypass = function (eles, name, value) {
  name = util.camel2dash(name);

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var prop = ele._private.style[name];
    var type = this.properties[name].type;
    var isColor = type.color;
    var isMulti = type.mutiple;

    if (!prop || !prop.bypass) {
      // need a bypass if one doesn't exist
      this.applyBypass(ele, name, value);
      continue;
    }

    var oldValue = prop.pfValue != null ? prop.pfValue : prop.value;

    prop.value = value;

    if (prop.pfValue != null) {
      prop.pfValue = value;
    }

    if (isColor) {
      prop.strValue = 'rgb(' + value.join(',') + ')';
    } else if (isMulti) {
      prop.strValue = value.join(' ');
    } else {
      prop.strValue = '' + value;
    }

    this.checkZOrderTrigger(ele, name, oldValue, value);
  }
};

styfn.removeAllBypasses = function (eles, updateTransitions) {
  return this.removeBypasses(eles, this.propertyNames, updateTransitions);
};

styfn.removeBypasses = function (eles, props, updateTransitions) {
  var isBypass = true;

  for (var j = 0; j < eles.length; j++) {
    var ele = eles[j];
    var diffProps = {};

    for (var i = 0; i < props.length; i++) {
      var name = props[i];
      var prop = this.properties[name];
      var prevProp = ele.pstyle(prop.name);

      if (!prevProp || !prevProp.bypass) {
        // if a bypass doesn't exist for the prop, nothing needs to be removed
        continue;
      }

      var value = ''; // empty => remove bypass
      var parsedProp = this.parse(name, value, true);
      var diffProp = diffProps[prop.name] = { prev: prevProp };

      this.applyParsedProperty(ele, parsedProp);

      diffProp.next = ele.pstyle(prop.name);
    } // for props

    this.updateStyleHints(ele);

    if (updateTransitions) {
      this.updateTransitions(ele, diffProps, isBypass);
    }
  } // for eles
};

module.exports = styfn;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var window = __webpack_require__(4);

var styfn = {};

// gets what an em size corresponds to in pixels relative to a dom element
styfn.getEmSizeInPixels = function () {
  var px = this.containerCss('font-size');

  if (px != null) {
    return parseFloat(px);
  } else {
    return 1; // for headless
  }
};

// gets css property from the core container
styfn.containerCss = function (propName) {
  var cy = this._private.cy;
  var domElement = cy.container();

  if (window && domElement && window.getComputedStyle) {
    return window.getComputedStyle(domElement).getPropertyValue(propName);
  }
};

module.exports = styfn;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);

var styfn = {};

// gets the rendered style for an element
styfn.getRenderedStyle = function (ele, prop) {
  if (prop) {
    return this.getStylePropertyValue(ele, prop, true);
  } else {
    return this.getRawStyle(ele, true);
  }
};

// gets the raw style for an element
styfn.getRawStyle = function (ele, isRenderedVal) {
  var self = this;

  ele = ele[0]; // insure it's an element

  if (ele) {
    var rstyle = {};

    for (var i = 0; i < self.properties.length; i++) {
      var prop = self.properties[i];
      var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);

      if (val != null) {
        rstyle[prop.name] = val;
        rstyle[util.dash2camel(prop.name)] = val;
      }
    }

    return rstyle;
  }
};

styfn.getIndexedStyle = function (ele, property, subproperty, index) {
  var pstyle = ele.pstyle(property)[subproperty][index];
  return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];
};

styfn.getStylePropertyValue = function (ele, propName, isRenderedVal) {
  var self = this;

  ele = ele[0]; // insure it's an element

  if (ele) {
    var prop = self.properties[propName];

    if (prop.alias) {
      prop = prop.pointsTo;
    }

    var type = prop.type;
    var styleProp = ele.pstyle(prop.name);
    var zoom = ele.cy().zoom();

    if (styleProp) {
      var units = styleProp.units ? type.implicitUnits || 'px' : null;
      var val = units ? [].concat(styleProp.pfValue).map(function (pfValue) {
        return pfValue * (isRenderedVal ? zoom : 1) + units;
      }).join(' ') : styleProp.strValue;

      return val;
    }
  }
};

styfn.getAnimationStartStyle = function (ele, aniProps) {
  var rstyle = {};

  for (var i = 0; i < aniProps.length; i++) {
    var aniProp = aniProps[i];
    var name = aniProp.name;

    var styleProp = ele.pstyle(name);

    if (styleProp !== undefined) {
      // then make a prop of it
      if (is.plainObject(styleProp)) {
        styleProp = this.parse(name, styleProp.strValue);
      } else {
        styleProp = this.parse(name, styleProp);
      }
    }

    if (styleProp) {
      rstyle[name] = styleProp;
    }
  }

  return rstyle;
};

styfn.getPropsList = function (propsObj) {
  var self = this;
  var rstyle = [];
  var style = propsObj;
  var props = self.properties;

  if (style) {
    var names = Object.keys(style);

    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      var val = style[name];
      var prop = props[name] || props[util.camel2dash(name)];
      var styleProp = this.parse(prop.name, val);

      if (styleProp) {
        rstyle.push(styleProp);
      }
    }
  }

  return rstyle;
};

module.exports = styfn;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var styfn = {};

styfn.appendFromJson = function (json) {
  var style = this;

  for (var i = 0; i < json.length; i++) {
    var context = json[i];
    var selector = context.selector;
    var props = context.style || context.css;
    var names = Object.keys(props);

    style.selector(selector); // apply selector

    for (var j = 0; j < names.length; j++) {
      var name = names[j];
      var value = props[name];

      style.css(name, value); // apply property
    }
  }

  return style;
};

// accessible cy.style() function
styfn.fromJson = function (json) {
  var style = this;

  style.resetToDefault();
  style.appendFromJson(json);

  return style;
};

// get json from cy.style() api
styfn.json = function () {
  var json = [];

  for (var i = this.defaultLength; i < this.length; i++) {
    var cxt = this[i];
    var selector = cxt.selector;
    var props = cxt.properties;
    var css = {};

    for (var j = 0; j < props.length; j++) {
      var prop = props[j];
      css[prop.name] = prop.strValue;
    }

    json.push({
      selector: !selector ? 'core' : selector.toString(),
      style: css
    });
  }

  return json;
};

module.exports = styfn;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);
var math = __webpack_require__(2);

var styfn = {};

// a caching layer for property parsing
styfn.parse = function (name, value, propIsBypass, propIsFlat) {
  var self = this;

  // function values can't be cached in all cases, and there isn't much benefit of caching them anyway
  if (is.fn(value)) {
    return self.parseImplWarn(name, value, propIsBypass, propIsFlat);
  }

  var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;
  var argHash = [name, value, propIsBypass, flatKey].join('$');
  var propCache = self.propCache = self.propCache || {};
  var ret = void 0;

  if (!(ret = propCache[argHash])) {
    ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);
  }

  // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden
  // - mappings can't be shared b/c mappings are per-element
  if (propIsBypass || propIsFlat === 'mapping') {
    // need a copy since props are mutated later in their lifecycles
    ret = util.copy(ret);

    if (ret) {
      ret.value = util.copy(ret.value); // because it could be an array, e.g. colour
    }
  }

  return ret;
};

styfn.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {
  var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);

  if (!prop && value != null) {
    util.error('The style property `%s: %s` is invalid', name, value);
  }

  return prop;
};

// parse a property; return null on invalid; return parsed property otherwise
// fields :
// - name : the name of the property
// - value : the parsed, native-typed value of the property
// - strValue : a string value that represents the property value in valid css
// - bypass : true iff the property is a bypass property
styfn.parseImpl = function (name, value, propIsBypass, propIsFlat) {
  var self = this;

  name = util.camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')

  var property = self.properties[name];
  var passedValue = value;
  var types = self.types;

  if (!property) {
    return null;
  } // return null on property of unknown name
  if (value === undefined || value === null) {
    return null;
  } // can't assign null

  // the property may be an alias
  if (property.alias) {
    property = property.pointsTo;
    name = property.name;
  }

  var valueIsString = is.string(value);
  if (valueIsString) {
    // trim the value to make parsing easier
    value = value.trim();
  }

  var type = property.type;
  if (!type) {
    return null;
  } // no type, no luck

  // check if bypass is null or empty string (i.e. indication to delete bypass property)
  if (propIsBypass && (value === '' || value === null)) {
    return {
      name: name,
      value: value,
      bypass: true,
      deleteBypass: true
    };
  }

  // check if value is a function used as a mapper
  if (is.fn(value)) {
    return {
      name: name,
      value: value,
      strValue: 'fn',
      mapped: types.fn,
      bypass: propIsBypass
    };
  }

  // check if value is mapped
  var data = void 0,
      mapData = void 0;
  if (!valueIsString || propIsFlat) {
    // then don't bother to do the expensive regex checks

  } else if (data = new RegExp(types.data.regex).exec(value)) {
    if (propIsBypass) {
      return false;
    } // mappers not allowed in bypass

    var mapped = types.data;

    return {
      name: name,
      value: data,
      strValue: '' + value,
      mapped: mapped,
      field: data[1],
      bypass: propIsBypass
    };
  } else if (mapData = new RegExp(types.mapData.regex).exec(value)) {
    if (propIsBypass) {
      return false;
    } // mappers not allowed in bypass
    if (type.multiple) {
      return false;
    } // impossible to map to num

    var _mapped = types.mapData;

    // we can map only if the type is a colour or a number
    if (!(type.color || type.number)) {
      return false;
    }

    var valueMin = this.parse(name, mapData[4]); // parse to validate
    if (!valueMin || valueMin.mapped) {
      return false;
    } // can't be invalid or mapped

    var valueMax = this.parse(name, mapData[5]); // parse to validate
    if (!valueMax || valueMax.mapped) {
      return false;
    } // can't be invalid or mapped

    // check if valueMin and valueMax are the same
    if (valueMin.value === valueMax.value) {
      return false; // can't make much of a mapper without a range
    } else if (type.color) {
      var c1 = valueMin.value;
      var c2 = valueMax.value;

      var same = c1[0] === c2[0] // red
      && c1[1] === c2[1] // green
      && c1[2] === c2[2] // blue
      && ( // optional alpha
      c1[3] === c2[3] // same alpha outright
      || (c1[3] == null || c1[3] === 1) && ( // full opacity for colour 1?
      c2[3] == null || c2[3] === 1) // full opacity for colour 2?
      );

      if (same) {
        return false;
      } // can't make a mapper without a range
    }

    return {
      name: name,
      value: mapData,
      strValue: '' + value,
      mapped: _mapped,
      field: mapData[1],
      fieldMin: parseFloat(mapData[2]), // min & max are numeric
      fieldMax: parseFloat(mapData[3]),
      valueMin: valueMin.value,
      valueMax: valueMax.value,
      bypass: propIsBypass
    };
  }

  if (type.multiple && propIsFlat !== 'multiple') {
    var vals = void 0;

    if (valueIsString) {
      vals = value.split(/\s+/);
    } else if (is.array(value)) {
      vals = value;
    } else {
      vals = [value];
    }

    if (type.evenMultiple && vals.length % 2 !== 0) {
      return null;
    }

    var valArr = [];
    var unitsArr = [];
    var pfValArr = [];
    var hasEnum = false;

    for (var i = 0; i < vals.length; i++) {
      var p = self.parse(name, vals[i], propIsBypass, 'multiple');

      hasEnum = hasEnum || is.string(p.value);

      valArr.push(p.value);
      pfValArr.push(p.pfValue != null ? p.pfValue : p.value);
      unitsArr.push(p.units);
    }

    if (type.validate && !type.validate(valArr, unitsArr)) {
      return null;
    }

    if (type.singleEnum && hasEnum) {
      if (valArr.length === 1 && is.string(valArr[0])) {
        return {
          name: name,
          value: valArr[0],
          strValue: valArr[0],
          bypass: propIsBypass
        };
      } else {
        return null;
      }
    }

    return {
      name: name,
      value: valArr,
      pfValue: pfValArr,
      strValue: valArr.join(' '),
      bypass: propIsBypass,
      units: unitsArr
    };
  }

  // several types also allow enums
  var checkEnums = function checkEnums() {
    for (var _i = 0; _i < type.enums.length; _i++) {
      var en = type.enums[_i];

      if (en === value) {
        return {
          name: name,
          value: value,
          strValue: '' + value,
          bypass: propIsBypass
        };
      }
    }

    return null;
  };

  // check the type and return the appropriate object
  if (type.number) {
    var units = void 0;
    var implicitUnits = 'px'; // not set => px

    if (type.units) {
      // use specified units if set
      units = type.units;
    }

    if (type.implicitUnits) {
      implicitUnits = type.implicitUnits;
    }

    if (!type.unitless) {
      if (valueIsString) {
        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');
        if (units) {
          unitsRegex = units;
        } // only allow explicit units if so set
        var match = value.match('^(' + util.regex.number + ')(' + unitsRegex + ')?' + '$');

        if (match) {
          value = match[1];
          units = match[2] || implicitUnits;
        }
      } else if (!units || type.implicitUnits) {
        units = implicitUnits; // implicitly px if unspecified
      }
    }

    value = parseFloat(value);

    // if not a number and enums not allowed, then the value is invalid
    if (isNaN(value) && type.enums === undefined) {
      return null;
    }

    // check if this number type also accepts special keywords in place of numbers
    // (i.e. `left`, `auto`, etc)
    if (isNaN(value) && type.enums !== undefined) {
      value = passedValue;

      return checkEnums();
    }

    // check if value must be an integer
    if (type.integer && !is.integer(value)) {
      return null;
    }

    // check value is within range
    if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {
      return null;
    }

    var ret = {
      name: name,
      value: value,
      strValue: '' + value + (units ? units : ''),
      units: units,
      bypass: propIsBypass
    };

    // normalise value in pixels
    if (type.unitless || units !== 'px' && units !== 'em') {
      ret.pfValue = value;
    } else {
      ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;
    }

    // normalise value in ms
    if (units === 'ms' || units === 's') {
      ret.pfValue = units === 'ms' ? value : 1000 * value;
    }

    // normalise value in rad
    if (units === 'deg' || units === 'rad') {
      ret.pfValue = units === 'rad' ? value : math.deg2rad(value);
    }

    // normalize value in %
    if (units === '%') {
      ret.pfValue = value / 100;
    }

    return ret;
  } else if (type.propList) {

    var props = [];
    var propsStr = '' + value;

    if (propsStr === 'none') {
      // leave empty

    } else {
      // go over each prop

      var propsSplit = propsStr.split(',');
      for (var _i2 = 0; _i2 < propsSplit.length; _i2++) {
        var propName = propsSplit[_i2].trim();

        if (self.properties[propName]) {
          props.push(propName);
        }
      }

      if (props.length === 0) {
        return null;
      }
    }

    return {
      name: name,
      value: props,
      strValue: props.length === 0 ? 'none' : props.join(', '),
      bypass: propIsBypass
    };
  } else if (type.color) {
    var tuple = util.color2tuple(value);

    if (!tuple) {
      return null;
    }

    return {
      name: name,
      value: tuple,
      pfValue: tuple,
      strValue: '' + value,
      bypass: propIsBypass
    };
  } else if (type.regex || type.regexes) {

    // first check enums
    if (type.enums) {
      var enumProp = checkEnums();

      if (enumProp) {
        return enumProp;
      }
    }

    var regexes = type.regexes ? type.regexes : [type.regex];

    for (var _i3 = 0; _i3 < regexes.length; _i3++) {
      var regex = new RegExp(regexes[_i3]); // make a regex from the type string
      var m = regex.exec(value);

      if (m) {
        // regex matches
        return {
          name: name,
          value: type.singleRegexMatchValue ? m[1] : m,
          strValue: '' + value,
          bypass: propIsBypass
        };
      }
    }

    return null; // didn't match any
  } else if (type.string) {
    // just return
    return {
      name: name,
      value: '' + value,
      strValue: '' + value,
      bypass: propIsBypass
    };
  } else if (type.enums) {
    // check enums last because it's a combo type in others
    return checkEnums();
  } else {
    return null; // not a type we can handle
  }
};

module.exports = styfn;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);

var styfn = {};

(function () {
  var number = util.regex.number;
  var rgba = util.regex.rgbaNoBackRefs;
  var hsla = util.regex.hslaNoBackRefs;
  var hex3 = util.regex.hex3;
  var hex6 = util.regex.hex6;
  var data = function data(prefix) {
    return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$';
  };
  var mapData = function mapData(prefix) {
    var mapArg = number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6;
    return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + mapArg + ')\\s*\\,\\s*(' + mapArg + ')\\)$';
  };
  var urlRegexes = ['^url\\s*\\(\\s*[\'"]?(.+?)[\'"]?\\s*\\)$', '^(none)$', '^(.+)$'];

  // each visual style property has a type and needs to be validated according to it
  styfn.types = {
    time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },
    percent: { number: true, min: 0, max: 100, units: '%', implicitUnits: '%' },
    zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },
    zeroOneNumbers: { number: true, min: 0, max: 1, unitless: true, multiple: true },
    nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },
    nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },
    position: { enums: ['parent', 'origin'] },
    nodeSize: { number: true, min: 0, enums: ['label'] },
    number: { number: true, unitless: true },
    numbers: { number: true, unitless: true, multiple: true },
    positiveNumber: { number: true, unitless: true, min: 0, strictMin: true },
    size: { number: true, min: 0 },
    bidirectionalSize: { number: true }, // allows negative
    bidirectionalSizes: { number: true, multiple: true }, // allows negative
    sizeMaybePercent: { number: true, min: 0, allowPercent: true },
    paddingRelativeTo: { enums: ['width', 'height', 'average', 'min', 'max'] },
    bgWH: { number: true, min: 0, allowPercent: true, enums: ['auto'], multiple: true },
    bgPos: { number: true, allowPercent: true, multiple: true },
    bgRelativeTo: { enums: ['inner', 'include-padding'], multiple: true },
    bgRepeat: { enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'], multiple: true },
    bgFit: { enums: ['none', 'contain', 'cover'], multiple: true },
    bgCrossOrigin: { enums: ['anonymous', 'use-credentials'], multiple: true },
    bgClip: { enums: ['none', 'node'] },
    color: { color: true },
    bool: { enums: ['yes', 'no'] },
    lineStyle: { enums: ['solid', 'dotted', 'dashed'] },
    borderStyle: { enums: ['solid', 'dotted', 'dashed', 'double'] },
    curveStyle: { enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments'] },
    fontFamily: { regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$' },
    fontletiant: { enums: ['small-caps', 'normal'] },
    fontStyle: { enums: ['italic', 'normal', 'oblique'] },
    fontWeight: { enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900] },
    textDecoration: { enums: ['none', 'underline', 'overline', 'line-through'] },
    textTransform: { enums: ['none', 'uppercase', 'lowercase'] },
    textWrap: { enums: ['none', 'wrap', 'ellipsis'] },
    textBackgroundShape: { enums: ['rectangle', 'roundrectangle'] },
    nodeShape: { enums: ['rectangle', 'roundrectangle', 'cutrectangle', 'bottomroundrectangle', 'barrel', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'concavehexagon', 'heptagon', 'octagon', 'tag', 'star', 'diamond', 'vee', 'rhomboid', 'polygon'] },
    compoundIncludeLabels: { enums: ['include', 'exclude'] },
    arrowShape: { enums: ['tee', 'triangle', 'triangle-tee', 'triangle-cross', 'triangle-backcurve', 'half-triangle-overshot', 'vee', 'square', 'circle', 'diamond', 'none'] },
    arrowFill: { enums: ['filled', 'hollow'] },
    display: { enums: ['element', 'none'] },
    visibility: { enums: ['hidden', 'visible'] },
    zCompoundDepth: { enums: ['bottom', 'orphan', 'auto', 'top'] },
    zIndexCompare: { enums: ['auto', 'manual'] },
    valign: { enums: ['top', 'center', 'bottom'] },
    halign: { enums: ['left', 'center', 'right'] },
    text: { string: true },
    data: { mapping: true, regex: data('data') },
    layoutData: { mapping: true, regex: data('layoutData') },
    scratch: { mapping: true, regex: data('scratch') },
    mapData: { mapping: true, regex: mapData('mapData') },
    mapLayoutData: { mapping: true, regex: mapData('mapLayoutData') },
    mapScratch: { mapping: true, regex: mapData('mapScratch') },
    fn: { mapping: true, fn: true },
    url: { regexes: urlRegexes, singleRegexMatchValue: true },
    urls: { regexes: urlRegexes, singleRegexMatchValue: true, multiple: true },
    propList: { propList: true },
    angle: { number: true, units: 'deg|rad', implicitUnits: 'rad' },
    textRotation: { number: true, units: 'deg|rad', implicitUnits: 'rad', enums: ['none', 'autorotate'] },
    polygonPointList: { number: true, multiple: true, evenMultiple: true, min: -1, max: 1, unitless: true },
    edgeDistances: { enums: ['intersection', 'node-position'] },
    edgeEndpoint: {
      number: true, multiple: true, units: '%|px|em|deg|rad', implicitUnits: 'px',
      enums: ['inside-to-node', 'outside-to-node', 'outside-to-line'], singleEnum: true,
      validate: function validate(valArr, unitsArr) {
        switch (valArr.length) {
          case 2:
            // can be % or px only
            return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';
          case 1:
            // can be enum, deg, or rad only
            return is.string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';
          default:
            return false;
        }
      }
    },
    easing: {
      regexes: ['^(spring)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$', '^(cubic-bezier)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$'],
      enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']
    }
  };

  var zOrderDiff = {
    zeroNonZero: function zeroNonZero(val1, val2) {
      if (val1 === 0 && val2 !== 0) {
        return true;
      } else if (val1 !== 0 && val2 === 0) {
        return true;
      } else {
        return false;
      }
    },
    anyDiff: function anyDiff(val1, val2) {
      return val1 !== val2;
    }
  };

  var zd = zOrderDiff;

  // define visual style properties
  var t = styfn.types;
  var props = styfn.properties = [
  // main label
  { name: 'label', type: t.text }, { name: 'text-rotation', type: t.textRotation }, { name: 'text-margin-x', type: t.bidirectionalSize }, { name: 'text-margin-y', type: t.bidirectionalSize },

  // source label
  { name: 'source-label', type: t.text }, { name: 'source-text-rotation', type: t.textRotation }, { name: 'source-text-margin-x', type: t.bidirectionalSize }, { name: 'source-text-margin-y', type: t.bidirectionalSize }, { name: 'source-text-offset', type: t.size },

  // target label
  { name: 'target-label', type: t.text }, { name: 'target-text-rotation', type: t.textRotation }, { name: 'target-text-margin-x', type: t.bidirectionalSize }, { name: 'target-text-margin-y', type: t.bidirectionalSize }, { name: 'target-text-offset', type: t.size },

  // common label style
  { name: 'text-valign', type: t.valign }, { name: 'text-halign', type: t.halign }, { name: 'color', type: t.color }, { name: 'text-outline-color', type: t.color }, { name: 'text-outline-width', type: t.size }, { name: 'text-outline-opacity', type: t.zeroOneNumber }, { name: 'text-opacity', type: t.zeroOneNumber }, { name: 'text-background-color', type: t.color }, { name: 'text-background-opacity', type: t.zeroOneNumber }, { name: 'text-background-padding', type: t.size }, { name: 'text-border-opacity', type: t.zeroOneNumber }, { name: 'text-border-color', type: t.color }, { name: 'text-border-width', type: t.size }, { name: 'text-border-style', type: t.borderStyle }, { name: 'text-background-shape', type: t.textBackgroundShape },
  // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas
  { name: 'text-transform', type: t.textTransform }, { name: 'text-wrap', type: t.textWrap }, { name: 'text-max-width', type: t.size }, { name: 'text-events', type: t.bool }, { name: 'font-family', type: t.fontFamily }, { name: 'font-style', type: t.fontStyle },
  // { name: 'font-letiant', type: t.fontletiant }, // not useful
  { name: 'font-weight', type: t.fontWeight }, { name: 'font-size', type: t.size }, { name: 'min-zoomed-font-size', type: t.size },

  // behaviour
  { name: 'events', type: t.bool },

  // visibility
  { name: 'display', type: t.display, triggersZOrder: zd.anyDiff }, { name: 'visibility', type: t.visibility, triggersZOrder: zd.anyDiff }, { name: 'opacity', type: t.zeroOneNumber, triggersZOrder: zd.zeroNonZero }, { name: 'z-compound-depth', type: t.zCompoundDepth, triggersZOrder: zd.anyDiff }, { name: 'z-index-compare', type: t.zIndexCompare, triggersZOrder: zd.anyDiff }, { name: 'z-index', type: t.nonNegativeInt, triggersZOrder: zd.anyDiff },

  // overlays
  { name: 'overlay-padding', type: t.size }, { name: 'overlay-color', type: t.color }, { name: 'overlay-opacity', type: t.zeroOneNumber },

  // transition anis
  { name: 'transition-property', type: t.propList }, { name: 'transition-duration', type: t.time }, { name: 'transition-delay', type: t.time }, { name: 'transition-timing-function', type: t.easing },

  // node body
  { name: 'height', type: t.nodeSize }, { name: 'width', type: t.nodeSize }, { name: 'shape', type: t.nodeShape }, { name: 'shape-polygon-points', type: t.polygonPointList }, { name: 'background-color', type: t.color }, { name: 'background-opacity', type: t.zeroOneNumber }, { name: 'background-blacken', type: t.nOneOneNumber }, { name: 'padding', type: t.sizeMaybePercent }, { name: 'padding-relative-to', type: t.paddingRelativeTo },

  // node border
  { name: 'border-color', type: t.color }, { name: 'border-opacity', type: t.zeroOneNumber }, { name: 'border-width', type: t.size }, { name: 'border-style', type: t.borderStyle },

  // node background images
  { name: 'background-image', type: t.urls }, { name: 'background-image-crossorigin', type: t.bgCrossOrigin }, { name: 'background-image-opacity', type: t.zeroOneNumbers }, { name: 'background-position-x', type: t.bgPos }, { name: 'background-position-y', type: t.bgPos }, { name: 'background-width-relative-to', type: t.bgRelativeTo }, { name: 'background-height-relative-to', type: t.bgRelativeTo }, { name: 'background-repeat', type: t.bgRepeat }, { name: 'background-fit', type: t.bgFit }, { name: 'background-clip', type: t.bgClip }, { name: 'background-width', type: t.bgWH }, { name: 'background-height', type: t.bgWH },

  // compound props
  { name: 'position', type: t.position }, { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels }, { name: 'min-width', type: t.size }, { name: 'min-width-bias-left', type: t.sizeMaybePercent }, { name: 'min-width-bias-right', type: t.sizeMaybePercent }, { name: 'min-height', type: t.size }, { name: 'min-height-bias-top', type: t.sizeMaybePercent }, { name: 'min-height-bias-bottom', type: t.sizeMaybePercent },

  // edge line
  { name: 'line-style', type: t.lineStyle }, { name: 'line-color', type: t.color }, { name: 'curve-style', type: t.curveStyle }, { name: 'haystack-radius', type: t.zeroOneNumber }, { name: 'source-endpoint', type: t.edgeEndpoint }, { name: 'target-endpoint', type: t.edgeEndpoint }, { name: 'control-point-step-size', type: t.size }, { name: 'control-point-distances', type: t.bidirectionalSizes }, { name: 'control-point-weights', type: t.numbers }, { name: 'segment-distances', type: t.bidirectionalSizes }, { name: 'segment-weights', type: t.numbers }, { name: 'edge-distances', type: t.edgeDistances }, { name: 'arrow-scale', type: t.positiveNumber }, { name: 'loop-direction', type: t.angle }, { name: 'loop-sweep', type: t.angle }, { name: 'source-distance-from-node', type: t.size }, { name: 'target-distance-from-node', type: t.size },

  // ghost properties
  { name: 'ghost', type: t.bool }, { name: 'ghost-offset-x', type: t.bidirectionalSize }, { name: 'ghost-offset-y', type: t.bidirectionalSize }, { name: 'ghost-opacity', type: t.zeroOneNumber },

  // these are just for the core
  { name: 'selection-box-color', type: t.color }, { name: 'selection-box-opacity', type: t.zeroOneNumber }, { name: 'selection-box-border-color', type: t.color }, { name: 'selection-box-border-width', type: t.size }, { name: 'active-bg-color', type: t.color }, { name: 'active-bg-opacity', type: t.zeroOneNumber }, { name: 'active-bg-size', type: t.size }, { name: 'outside-texture-bg-color', type: t.color }, { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }];

  // define aliases
  var aliases = styfn.aliases = [{ name: 'content', pointsTo: 'label' }, { name: 'control-point-distance', pointsTo: 'control-point-distances' }, { name: 'control-point-weight', pointsTo: 'control-point-weights' }, { name: 'edge-text-rotation', pointsTo: 'text-rotation' }, { name: 'padding-left', pointsTo: 'padding' }, { name: 'padding-right', pointsTo: 'padding' }, { name: 'padding-top', pointsTo: 'padding' }, { name: 'padding-bottom', pointsTo: 'padding' }];

  // pie backgrounds for nodes
  styfn.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
  props.push({ name: 'pie-size', type: t.sizeMaybePercent });
  for (var i = 1; i <= styfn.pieBackgroundN; i++) {
    props.push({ name: 'pie-' + i + '-background-color', type: t.color });
    props.push({ name: 'pie-' + i + '-background-size', type: t.percent });
    props.push({ name: 'pie-' + i + '-background-opacity', type: t.zeroOneNumber });
  }

  // edge arrows
  var arrowPrefixes = styfn.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];
  [{ name: 'arrow-shape', type: t.arrowShape }, { name: 'arrow-color', type: t.color }, { name: 'arrow-fill', type: t.arrowFill }].forEach(function (prop) {
    arrowPrefixes.forEach(function (prefix) {
      var name = prefix + '-' + prop.name;
      var type = prop.type;

      props.push({ name: name, type: type });
    });
  }, {});

  // list of property names
  styfn.propertyNames = props.map(function (p) {
    return p.name;
  });

  // allow access of properties by name ( e.g. style.properties.height )
  for (var _i = 0; _i < props.length; _i++) {
    var prop = props[_i];

    props[prop.name] = prop; // allow lookup by name
  }

  // map aliases
  for (var _i2 = 0; _i2 < aliases.length; _i2++) {
    var alias = aliases[_i2];
    var pointsToProp = props[alias.pointsTo];
    var aliasProp = {
      name: alias.name,
      alias: true,
      pointsTo: pointsToProp
    };

    // add alias prop for parsing
    props.push(aliasProp);

    props[alias.name] = aliasProp; // allow lookup by name
  }
})();

styfn.getDefaultProperty = function (name) {
  return this.getDefaultProperties()[name];
};

styfn.getDefaultProperties = util.memoize(function () {
  var rawProps = util.extend({
    // common node/edge props
    'events': 'yes',
    'text-events': 'no',
    'text-valign': 'top',
    'text-halign': 'center',
    'color': '#000',
    'text-outline-color': '#000',
    'text-outline-width': 0,
    'text-outline-opacity': 1,
    'text-opacity': 1,
    'text-decoration': 'none',
    'text-transform': 'none',
    'text-wrap': 'none',
    'text-max-width': 9999,
    'text-background-color': '#000',
    'text-background-opacity': 0,
    'text-background-shape': 'rectangle',
    'text-background-padding': 0,
    'text-border-opacity': 0,
    'text-border-width': 0,
    'text-border-style': 'solid',
    'text-border-color': '#000',
    'font-family': 'Helvetica Neue, Helvetica, sans-serif',
    'font-style': 'normal',
    // 'font-letiant': fontletiant,
    'font-weight': 'normal',
    'font-size': 16,
    'min-zoomed-font-size': 0,
    'text-rotation': 'none',
    'source-text-rotation': 'none',
    'target-text-rotation': 'none',
    'visibility': 'visible',
    'display': 'element',
    'opacity': 1,
    'z-compound-depth': 'auto',
    'z-index-compare': 'auto',
    'z-index': 0,
    'label': '',
    'text-margin-x': 0,
    'text-margin-y': 0,
    'source-label': '',
    'source-text-offset': 0,
    'source-text-margin-x': 0,
    'source-text-margin-y': 0,
    'target-label': '',
    'target-text-offset': 0,
    'target-text-margin-x': 0,
    'target-text-margin-y': 0,
    'overlay-opacity': 0,
    'overlay-color': '#000',
    'overlay-padding': 10,
    'transition-property': 'none',
    'transition-duration': 0,
    'transition-delay': 0,
    'transition-timing-function': 'linear',

    // node props
    'background-blacken': 0,
    'background-color': '#999',
    'background-opacity': 1,
    'background-image': 'none',
    'background-image-crossorigin': 'anonymous',
    'background-image-opacity': 1,
    'background-position-x': '50%',
    'background-position-y': '50%',
    'background-width-relative-to': 'include-padding',
    'background-height-relative-to': 'include-padding',
    'background-repeat': 'no-repeat',
    'background-fit': 'none',
    'background-clip': 'node',
    'background-width': 'auto',
    'background-height': 'auto',
    'border-color': '#000',
    'border-opacity': 1,
    'border-width': 0,
    'border-style': 'solid',
    'height': 30,
    'width': 30,
    'shape': 'ellipse',
    'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',

    // ghost props
    'ghost': 'no',
    'ghost-offset-y': 0,
    'ghost-offset-x': 0,
    'ghost-opacity': 0,

    // compound props
    'padding': 0,
    'padding-relative-to': 'width',
    'position': 'origin',
    'compound-sizing-wrt-labels': 'include',
    'min-width': 0,
    'min-width-bias-left': 0,
    'min-width-bias-right': 0,
    'min-height': 0,
    'min-height-bias-top': 0,
    'min-height-bias-bottom': 0
  }, {
    // node pie bg
    'pie-size': '100%'
  }, [{ name: 'pie-{{i}}-background-color', value: 'black' }, { name: 'pie-{{i}}-background-size', value: '0%' }, { name: 'pie-{{i}}-background-opacity', value: 1 }].reduce(function (css, prop) {
    for (var i = 1; i <= styfn.pieBackgroundN; i++) {
      var name = prop.name.replace('{{i}}', i);
      var val = prop.value;

      css[name] = val;
    }

    return css;
  }, {}), {
    // edge props
    'line-style': 'solid',
    'line-color': '#999',
    'control-point-step-size': 40,
    'control-point-weights': 0.5,
    'segment-weights': 0.5,
    'segment-distances': 20,
    'edge-distances': 'intersection',
    'curve-style': 'bezier',
    'haystack-radius': 0,
    'arrow-scale': 1,
    'loop-direction': '-45deg',
    'loop-sweep': '-90deg',
    'source-distance-from-node': 0,
    'target-distance-from-node': 0,
    'source-endpoint': 'outside-to-node',
    'target-endpoint': 'outside-to-node'
  }, [{ name: 'arrow-shape', value: 'none' }, { name: 'arrow-color', value: '#999' }, { name: 'arrow-fill', value: 'filled' }].reduce(function (css, prop) {
    styfn.arrowPrefixes.forEach(function (prefix) {
      var name = prefix + '-' + prop.name;
      var val = prop.value;

      css[name] = val;
    });

    return css;
  }, {}));

  var parsedProps = {};

  for (var i = 0; i < this.properties.length; i++) {
    var prop = this.properties[i];

    if (prop.pointsTo) {
      continue;
    }

    var name = prop.name;
    var val = rawProps[name];
    var parsedProp = this.parse(name, val);

    parsedProps[name] = parsedProp;
  }

  return parsedProps;
});

styfn.addDefaultStylesheet = function () {
  this.selector('$node > node') // compound (parent) node properties
  .css({
    'shape': 'rectangle',
    'padding': 10,
    'background-color': '#eee',
    'border-color': '#ccc',
    'border-width': 1
  }).selector('edge') // just edge properties
  .css({
    'width': 3,
    'curve-style': 'haystack'
  }).selector(':parent <-> node').css({
    'curve-style': 'bezier',
    'source-endpoint': 'outside-to-line',
    'target-endpoint': 'outside-to-line'
  }).selector(':selected').css({
    'background-color': '#0169D9',
    'line-color': '#0169D9',
    'source-arrow-color': '#0169D9',
    'target-arrow-color': '#0169D9',
    'mid-source-arrow-color': '#0169D9',
    'mid-target-arrow-color': '#0169D9'
  }).selector('node:parent:selected').css({
    'background-color': '#CCE1F9',
    'border-color': '#aec8e5'
  }).selector(':active').css({
    'overlay-color': 'black',
    'overlay-padding': 10,
    'overlay-opacity': 0.25
  }).selector('core') // just core properties
  .css({
    'selection-box-color': '#ddd',
    'selection-box-opacity': 0.65,
    'selection-box-border-color': '#aaa',
    'selection-box-border-width': 1,
    'active-bg-color': 'black',
    'active-bg-opacity': 0.15,
    'active-bg-size': 30,
    'outside-texture-bg-color': '#000',
    'outside-texture-bg-opacity': 0.125
  });

  this.defaultLength = this.length;
};

module.exports = styfn;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var Selector = __webpack_require__(6);

var styfn = {};

styfn.appendFromString = function (string) {
  var self = this;
  var style = this;
  var remaining = '' + string;
  var selAndBlockStr = void 0;
  var blockRem = void 0;
  var propAndValStr = void 0;

  // remove comments from the style string
  remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');

  function removeSelAndBlockFromRemaining() {
    // remove the parsed selector and block from the remaining text to parse
    if (remaining.length > selAndBlockStr.length) {
      remaining = remaining.substr(selAndBlockStr.length);
    } else {
      remaining = '';
    }
  }

  function removePropAndValFromRem() {
    // remove the parsed property and value from the remaining block text to parse
    if (blockRem.length > propAndValStr.length) {
      blockRem = blockRem.substr(propAndValStr.length);
    } else {
      blockRem = '';
    }
  }

  while (true) {
    var nothingLeftToParse = remaining.match(/^\s*$/);
    if (nothingLeftToParse) {
      break;
    }

    var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);

    if (!selAndBlock) {
      util.error('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
      break;
    }

    selAndBlockStr = selAndBlock[0];

    // parse the selector
    var selectorStr = selAndBlock[1];
    if (selectorStr !== 'core') {
      var selector = new Selector(selectorStr);
      if (selector._private.invalid) {
        util.error('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);

        // skip this selector and block
        removeSelAndBlockFromRemaining();
        continue;
      }
    }

    // parse the block of properties and values
    var blockStr = selAndBlock[2];
    var invalidBlock = false;
    blockRem = blockStr;
    var props = [];

    while (true) {
      var _nothingLeftToParse = blockRem.match(/^\s*$/);
      if (_nothingLeftToParse) {
        break;
      }

      var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);

      if (!propAndVal) {
        util.error('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
        invalidBlock = true;
        break;
      }

      propAndValStr = propAndVal[0];
      var propStr = propAndVal[1];
      var valStr = propAndVal[2];

      var prop = self.properties[propStr];
      if (!prop) {
        util.error('Skipping property: Invalid property name in: ' + propAndValStr);

        // skip this property in the block
        removePropAndValFromRem();
        continue;
      }

      var parsedProp = style.parse(propStr, valStr);

      if (!parsedProp) {
        util.error('Skipping property: Invalid property definition in: ' + propAndValStr);

        // skip this property in the block
        removePropAndValFromRem();
        continue;
      }

      props.push({
        name: propStr,
        val: valStr
      });
      removePropAndValFromRem();
    }

    if (invalidBlock) {
      removeSelAndBlockFromRemaining();
      break;
    }

    // put the parsed block in the style
    style.selector(selectorStr);
    for (var i = 0; i < props.length; i++) {
      var _prop = props[i];
      style.css(_prop.name, _prop.val);
    }

    removeSelAndBlockFromRemaining();
  }

  return style;
};

styfn.fromString = function (string) {
  var style = this;

  style.resetToDefault();
  style.appendFromString(string);

  return style;
};

module.exports = styfn;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

module.exports = {
  // get [r, g, b] from #abc or #aabbcc
  hex2tuple: function hex2tuple(hex) {
    if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {
      return;
    }

    var shortHex = hex.length === 4;
    var r = void 0,
        g = void 0,
        b = void 0;
    var base = 16;

    if (shortHex) {
      r = parseInt(hex[1] + hex[1], base);
      g = parseInt(hex[2] + hex[2], base);
      b = parseInt(hex[3] + hex[3], base);
    } else {
      r = parseInt(hex[1] + hex[2], base);
      g = parseInt(hex[3] + hex[4], base);
      b = parseInt(hex[5] + hex[6], base);
    }

    return [r, g, b];
  },

  // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
  hsl2tuple: function hsl2tuple(hsl) {
    var ret = void 0;
    var h = void 0,
        s = void 0,
        l = void 0,
        a = void 0,
        r = void 0,
        g = void 0,
        b = void 0;
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }

    var m = new RegExp('^' + this.regex.hsla + '$').exec(hsl);
    if (m) {

      // get hue
      h = parseInt(m[1]);
      if (h < 0) {
        h = (360 - -1 * h % 360) % 360;
      } else if (h > 360) {
        h = h % 360;
      }
      h /= 360; // normalise on [0, 1]

      s = parseFloat(m[2]);
      if (s < 0 || s > 100) {
        return;
      } // saturation is [0, 100]
      s = s / 100; // normalise on [0, 1]

      l = parseFloat(m[3]);
      if (l < 0 || l > 100) {
        return;
      } // lightness is [0, 100]
      l = l / 100; // normalise on [0, 1]

      a = m[4];
      if (a !== undefined) {
        a = parseFloat(a);

        if (a < 0 || a > 1) {
          return;
        } // alpha is [0, 1]
      }

      // now, convert to rgb
      // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
      if (s === 0) {
        r = g = b = Math.round(l * 255); // achromatic
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));
        g = Math.round(255 * hue2rgb(p, q, h));
        b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));
      }

      ret = [r, g, b, a];
    }

    return ret;
  },

  // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
  rgb2tuple: function rgb2tuple(rgb) {
    var ret = void 0;

    var m = new RegExp('^' + this.regex.rgba + '$').exec(rgb);
    if (m) {
      ret = [];

      var isPct = [];
      for (var i = 1; i <= 3; i++) {
        var channel = m[i];

        if (channel[channel.length - 1] === '%') {
          isPct[i] = true;
        }
        channel = parseFloat(channel);

        if (isPct[i]) {
          channel = channel / 100 * 255; // normalise to [0, 255]
        }

        if (channel < 0 || channel > 255) {
          return;
        } // invalid channel value

        ret.push(Math.floor(channel));
      }

      var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
      var allArePct = isPct[1] && isPct[2] && isPct[3];
      if (atLeastOneIsPct && !allArePct) {
        return;
      } // must all be percent values if one is

      var alpha = m[4];
      if (alpha !== undefined) {
        alpha = parseFloat(alpha);

        if (alpha < 0 || alpha > 1) {
          return;
        } // invalid alpha value

        ret.push(alpha);
      }
    }

    return ret;
  },

  colorname2tuple: function colorname2tuple(color) {
    return this.colors[color.toLowerCase()];
  },

  color2tuple: function color2tuple(color) {
    return (is.array(color) ? color : null) || this.colorname2tuple(color) || this.hex2tuple(color) || this.rgb2tuple(color) || this.hsl2tuple(color);
  },

  colors: {
    // special colour names
    transparent: [0, 0, 0, 0], // NB alpha === 0

    // regular colours
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    grey: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }
};

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

module.exports = {
  // has anything been set in the map
  mapEmpty: function mapEmpty(map) {
    var empty = true;

    if (map != null) {
      return Object.keys(map).length === 0;
    }

    return empty;
  },

  // pushes to the array at the end of a map (map may not be built)
  pushMap: function pushMap(options) {
    var array = this.getMap(options);

    if (array == null) {
      // if empty, put initial array
      this.setMap(this.extend({}, options, {
        value: [options.value]
      }));
    } else {
      array.push(options.value);
    }
  },

  // sets the value in a map (map may not be built)
  setMap: function setMap(options) {
    var obj = options.map;
    var key = void 0;
    var keys = options.keys;
    var l = keys.length;

    for (var i = 0; i < l; i++) {
      var _key = keys[i];

      if (is.plainObject(_key)) {
        this.error('Tried to set map with object key');
      }

      if (i < keys.length - 1) {

        // extend the map if necessary
        if (obj[_key] == null) {
          obj[_key] = {};
        }

        obj = obj[_key];
      } else {
        // set the value
        obj[_key] = options.value;
      }
    }
  },

  // gets the value in a map even if it's not built in places
  getMap: function getMap(options) {
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;

    for (var i = 0; i < l; i++) {
      var key = keys[i];

      if (is.plainObject(key)) {
        this.error('Tried to get map with object key');
      }

      obj = obj[key];

      if (obj == null) {
        return obj;
      }
    }

    return obj;
  },

  // deletes the entry in the map
  deleteMap: function deleteMap(options) {
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;
    var keepChildren = options.keepChildren;

    for (var i = 0; i < l; i++) {
      var key = keys[i];

      if (is.plainObject(key)) {
        this.error('Tried to delete map with object key');
      }

      var lastKey = i === options.keys.length - 1;
      if (lastKey) {

        if (keepChildren) {
          // then only delete child fields not in keepChildren
          var children = Object.keys(obj);

          for (var j = 0; j < children.length; j++) {
            var child = children[j];

            if (!keepChildren[child]) {
              obj[child] = undefined;
            }
          }
        } else {
          obj[key] = undefined;
        }
      } else {
        obj = obj[key];
      }
    }
  }
};

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var number = '(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))';

var rgba = 'rgb[a]?\\((' + number + '[%]?)\\s*,\\s*(' + number + '[%]?)\\s*,\\s*(' + number + '[%]?)(?:\\s*,\\s*(' + number + '))?\\)';
var rgbaNoBackRefs = 'rgb[a]?\\((?:' + number + '[%]?)\\s*,\\s*(?:' + number + '[%]?)\\s*,\\s*(?:' + number + '[%]?)(?:\\s*,\\s*(?:' + number + '))?\\)';

var hsla = 'hsl[a]?\\((' + number + ')\\s*,\\s*(' + number + '[%])\\s*,\\s*(' + number + '[%])(?:\\s*,\\s*(' + number + '))?\\)';
var hslaNoBackRefs = 'hsl[a]?\\((?:' + number + ')\\s*,\\s*(?:' + number + '[%])\\s*,\\s*(?:' + number + '[%])(?:\\s*,\\s*(?:' + number + '))?\\)';

var hex3 = '\\#[0-9a-fA-F]{3}';
var hex6 = '\\#[0-9a-fA-F]{6}';

module.exports = {
  regex: {
    number: number,
    rgba: rgba,
    rgbaNoBackRefs: rgbaNoBackRefs,
    hsla: hsla,
    hslaNoBackRefs: hslaNoBackRefs,
    hex3: hex3,
    hex6: hex6
  }
};

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function ascending(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}

function descending(a, b) {
  return -1 * ascending(a, b);
}

module.exports = {
  sort: {
    ascending: ascending,
    descending: descending
  }
};

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var memoize = __webpack_require__(19);
var is = __webpack_require__(0);

module.exports = {

  camel2dash: memoize(function (str) {
    return str.replace(/([A-Z])/g, function (v) {
      return '-' + v.toLowerCase();
    });
  }),

  dash2camel: memoize(function (str) {
    return str.replace(/(-\w)/g, function (v) {
      return v[1].toUpperCase();
    });
  }),

  prependCamel: memoize(function (prefix, str) {
    return prefix + str[0].toUpperCase() + str.substring(1);
  }, function (prefix, str) {
    return prefix + '$' + str;
  }),

  capitalize: function capitalize(str) {
    if (is.emptyString(str)) {
      return str;
    }

    return str.charAt(0).toUpperCase() + str.substring(1);
  }

};

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var window = __webpack_require__(4);
var performance = window ? window.performance : null;

var util = {};

var pnow = performance && performance.now ? function () {
  return performance.now();
} : function () {
  return Date.now();
};

var raf = function () {
  if (window) {
    if (window.requestAnimationFrame) {
      return function (fn) {
        window.requestAnimationFrame(fn);
      };
    } else if (window.mozRequestAnimationFrame) {
      return function (fn) {
        window.mozRequestAnimationFrame(fn);
      };
    } else if (window.webkitRequestAnimationFrame) {
      return function (fn) {
        window.webkitRequestAnimationFrame(fn);
      };
    } else if (window.msRequestAnimationFrame) {
      return function (fn) {
        window.msRequestAnimationFrame(fn);
      };
    }
  }

  return function (fn) {
    if (fn) {
      setTimeout(function () {
        fn(pnow());
      }, 1000 / 60);
    }
  };
}();

util.requestAnimationFrame = function (fn) {
  raf(fn);
};

util.performanceNow = pnow;

util.debounce = __webpack_require__(139);

util.now = function () {
  return Date.now();
};

module.exports = util;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(138);


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  (function(root, factory) {
    if (true) {
      return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === 'object') {
      return module.exports = factory();
    } else {
      return root.Heap = factory();
    }
  })(this, function() {
    return Heap;
  });

}).call(this);


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20)))

/***/ }),
/* 140 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20), __webpack_require__(140)))

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(141);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ })
/******/ ]);
});
;
//# sourceMappingURL=scripts.bundle.js.map